<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Base64Coder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.utils</a> &gt; <span class="el_source">Base64Coder.java</span></div><h1>Base64Coder.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Copyright 2003-2010 Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland
 * www.source-code.biz, www.inventec.ch/chdh
 *
 * This module is multi-licensed and may be used under the terms
 * of any of the following licenses:
 *
 *  EPL, Eclipse Public License, V1.0 or later, http://www.eclipse.org/legal
 *  LGPL, GNU Lesser General Public License, V2.1 or later, http://www.gnu.org/licenses/lgpl.html
 *  GPL, GNU General Public License, V2 or later, http://www.gnu.org/licenses/gpl.html
 *  AGPL, GNU Affero General Public License V3 or later, http://www.gnu.org/licenses/agpl.html
 *  AL, Apache License, V2.0 or later, http://www.apache.org/licenses
 *  BSD, BSD License, http://www.opensource.org/licenses/bsd-license.php
 *  MIT, MIT License, http://www.opensource.org/licenses/MIT
 *
 * Please contact the author if you need another license.
 * This module is provided &quot;as is&quot;, without warranties of any kind.
 *
 * Project home page: www.source-code.biz/base64coder/java
 */
package net.sourceforge.plantuml.utils;

/**
 * A Base64 encoder/decoder.
 * 
 * &lt;p&gt;
 * This class is used to encode and decode data in Base64 format as described in
 * RFC 1521.
 * &lt;p&gt;
 * Project home page: &lt;a href=
 * &quot;http://www.source-code.biz/base64coder/java/&quot;&gt;www.source-code.biz/base64coder/java&lt;/a&gt;&lt;br&gt;
 * Author: Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland&lt;br&gt;
 * 
 * @author Christian d'Heureuse, Inventec Informatik AG, Zurich, Switzerland,
 *         www.source-code.biz
 */
//::comment when __MIT__
//Multi-licensed: EPL / LGPL / GPL / AL / BSD / MIT.
//::done
//::uncomment when __MIT__
// // Used license: MIT.
//::done

public class Base64Coder {
	// ::remove file when __HAXE__


	// The line separator string of the operating system.
<span class="nc" id="L52">	private static final String systemLineSeparator = System.getProperty(&quot;line.separator&quot;);</span>

	// Mapping table from 6-bit nibbles to Base64 characters.
<span class="nc" id="L55">	private static final char[] map1 = new char[64];</span>
	static {
<span class="nc" id="L57">		int i = 0;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">		for (char c = 'A'; c &lt;= 'Z'; c++)</span>
<span class="nc" id="L59">			map1[i++] = c;</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		for (char c = 'a'; c &lt;= 'z'; c++)</span>
<span class="nc" id="L61">			map1[i++] = c;</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">		for (char c = '0'; c &lt;= '9'; c++)</span>
<span class="nc" id="L63">			map1[i++] = c;</span>
<span class="nc" id="L64">		map1[i++] = '+';</span>
<span class="nc" id="L65">		map1[i++] = '/';</span>
	}

	// Mapping table from Base64 characters to 6-bit nibbles.
<span class="nc" id="L69">	private static final byte[] map2 = new byte[128];</span>
	static {
<span class="nc bnc" id="L71" title="All 2 branches missed.">		for (int i = 0; i &lt; map2.length; i++)</span>
<span class="nc" id="L72">			map2[i] = -1;</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">		for (int i = 0; i &lt; 64; i++)</span>
<span class="nc" id="L74">			map2[map1[i]] = (byte) i;</span>
<span class="nc" id="L75">	}</span>

	/**
	 * Encodes a string into Base64 format. No blanks or line breaks are inserted.
	 * 
	 * @param s A String to be encoded.
	 * @return A String containing the Base64 encoded data.
	 */
	public static String encodeString(String s) {
<span class="nc" id="L84">		return new String(encode(s.getBytes()));</span>
	}

	/**
	 * Encodes a byte array into Base 64 format and breaks the output into lines of
	 * 76 characters. This method is compatible with
	 * &lt;code&gt;sun.misc.BASE64Encoder.encodeBuffer(byte[])&lt;/code&gt;.
	 * 
	 * @param in An array containing the data bytes to be encoded.
	 * @return A String containing the Base64 encoded data, broken into lines.
	 */
	public static String encodeLines(byte[] in) {
<span class="nc" id="L96">		return encodeLines(in, 0, in.length, 76, systemLineSeparator);</span>
	}

	/**
	 * Encodes a byte array into Base 64 format and breaks the output into lines.
	 * 
	 * @param in            An array containing the data bytes to be encoded.
	 * @param iOff          Offset of the first byte in &lt;code&gt;in&lt;/code&gt; to be
	 *                      processed.
	 * @param iLen          Number of bytes to be processed in &lt;code&gt;in&lt;/code&gt;,
	 *                      starting at &lt;code&gt;iOff&lt;/code&gt;.
	 * @param lineLen       Line length for the output data. Should be a multiple of
	 *                      4.
	 * @param lineSeparator The line separator to be used to separate the output
	 *                      lines.
	 * @return A String containing the Base64 encoded data, broken into lines.
	 */
	public static String encodeLines(byte[] in, int iOff, int iLen, int lineLen, String lineSeparator) {
<span class="nc" id="L114">		int blockLen = (lineLen * 3) / 4;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">		if (blockLen &lt;= 0)</span>
<span class="nc" id="L116">			throw new IllegalArgumentException();</span>
<span class="nc" id="L117">		int lines = (iLen + blockLen - 1) / blockLen;</span>
<span class="nc" id="L118">		int bufLen = ((iLen + 2) / 3) * 4 + lines * lineSeparator.length();</span>
<span class="nc" id="L119">		StringBuilder buf = new StringBuilder(bufLen);</span>
<span class="nc" id="L120">		int ip = 0;</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">		while (ip &lt; iLen) {</span>
<span class="nc" id="L122">			int l = Math.min(iLen - ip, blockLen);</span>
<span class="nc" id="L123">			buf.append(encode(in, iOff + ip, l));</span>
<span class="nc" id="L124">			buf.append(lineSeparator);</span>
<span class="nc" id="L125">			ip += l;</span>
<span class="nc" id="L126">		}</span>
<span class="nc" id="L127">		return buf.toString();</span>
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are
	 * inserted in the output.
	 * 
	 * @param in An array containing the data bytes to be encoded.
	 * @return A character array containing the Base64 encoded data.
	 */
	public static char[] encode(byte[] in) {
<span class="nc" id="L138">		return encode(in, 0, in.length);</span>
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are
	 * inserted in the output.
	 * 
	 * @param in   An array containing the data bytes to be encoded.
	 * @param iLen Number of bytes to process in &lt;code&gt;in&lt;/code&gt;.
	 * @return A character array containing the Base64 encoded data.
	 */
	public static char[] encode(byte[] in, int iLen) {
<span class="nc" id="L150">		return encode(in, 0, iLen);</span>
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are
	 * inserted in the output.
	 * 
	 * @param in   An array containing the data bytes to be encoded.
	 * @param iOff Offset of the first byte in &lt;code&gt;in&lt;/code&gt; to be processed.
	 * @param iLen Number of bytes to process in &lt;code&gt;in&lt;/code&gt;, starting at
	 *             &lt;code&gt;iOff&lt;/code&gt;.
	 * @return A character array containing the Base64 encoded data.
	 */
	public static char[] encode(byte[] in, int iOff, int iLen) {
<span class="nc" id="L164">		int oDataLen = (iLen * 4 + 2) / 3; // output length without padding</span>
<span class="nc" id="L165">		int oLen = ((iLen + 2) / 3) * 4; // output length including padding</span>
<span class="nc" id="L166">		char[] out = new char[oLen];</span>
<span class="nc" id="L167">		int ip = iOff;</span>
<span class="nc" id="L168">		int iEnd = iOff + iLen;</span>
<span class="nc" id="L169">		int op = 0;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">		while (ip &lt; iEnd) {</span>
<span class="nc" id="L171">			int i0 = in[ip++] &amp; 0xff;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">			int i1 = ip &lt; iEnd ? in[ip++] &amp; 0xff : 0;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">			int i2 = ip &lt; iEnd ? in[ip++] &amp; 0xff : 0;</span>
<span class="nc" id="L174">			int o0 = i0 &gt;&gt;&gt; 2;</span>
<span class="nc" id="L175">			int o1 = ((i0 &amp; 3) &lt;&lt; 4) | (i1 &gt;&gt;&gt; 4);</span>
<span class="nc" id="L176">			int o2 = ((i1 &amp; 0xf) &lt;&lt; 2) | (i2 &gt;&gt;&gt; 6);</span>
<span class="nc" id="L177">			int o3 = i2 &amp; 0x3F;</span>
<span class="nc" id="L178">			out[op++] = map1[o0];</span>
<span class="nc" id="L179">			out[op++] = map1[o1];</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">			out[op] = op &lt; oDataLen ? map1[o2] : '=';</span>
<span class="nc" id="L181">			op++;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">			out[op] = op &lt; oDataLen ? map1[o3] : '=';</span>
<span class="nc" id="L183">			op++;</span>
<span class="nc" id="L184">		}</span>
<span class="nc" id="L185">		return out;</span>
	}

	/**
	 * Decodes a string from Base64 format. No blanks or line breaks are allowed
	 * within the Base64 encoded input data.
	 * 
	 * @param s A Base64 String to be decoded.
	 * @return A String containing the decoded data.
	 * @throws IllegalArgumentException If the input is not valid Base64 encoded
	 *                                  data.
	 */
	public static String decodeString(String s) {
<span class="nc" id="L198">		return new String(decode(s));</span>
	}

	/**
	 * Decodes a byte array from Base64 format and ignores line separators, tabs and
	 * blanks. CR, LF, Tab and Space characters are ignored in the input data. This
	 * method is compatible with
	 * &lt;code&gt;sun.misc.BASE64Decoder.decodeBuffer(String)&lt;/code&gt;.
	 * 
	 * @param s A Base64 String to be decoded.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException If the input is not valid Base64 encoded
	 *                                  data.
	 */
	public static byte[] decodeLines(String s) {
<span class="nc" id="L213">		char[] buf = new char[s.length()];</span>
<span class="nc" id="L214">		int p = 0;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">		for (int ip = 0; ip &lt; s.length(); ip++) {</span>
<span class="nc" id="L216">			char c = s.charAt(ip);</span>
<span class="nc bnc" id="L217" title="All 8 branches missed.">			if (c != ' ' &amp;&amp; c != '\r' &amp;&amp; c != '\n' &amp;&amp; c != '\t')</span>
<span class="nc" id="L218">				buf[p++] = c;</span>
		}
<span class="nc" id="L220">		return decode(buf, 0, p);</span>
	}

	/**
	 * Decodes a byte array from Base64 format. No blanks or line breaks are allowed
	 * within the Base64 encoded input data.
	 * 
	 * @param s A Base64 String to be decoded.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException If the input is not valid Base64 encoded
	 *                                  data.
	 */
	public static byte[] decode(String s) {
<span class="nc" id="L233">		return decode(s.toCharArray());</span>
	}

	/**
	 * Decodes a byte array from Base64 format. No blanks or line breaks are allowed
	 * within the Base64 encoded input data.
	 * 
	 * @param in A character array containing the Base64 encoded data.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException If the input is not valid Base64 encoded
	 *                                  data.
	 */
	public static byte[] decode(char[] in) {
<span class="nc" id="L246">		return decode(in, 0, in.length);</span>
	}

	/**
	 * Decodes a byte array from Base64 format. No blanks or line breaks are allowed
	 * within the Base64 encoded input data.
	 * 
	 * @param in   A character array containing the Base64 encoded data.
	 * @param iOff Offset of the first character in &lt;code&gt;in&lt;/code&gt; to be processed.
	 * @param iLen Number of characters to process in &lt;code&gt;in&lt;/code&gt;, starting at
	 *             &lt;code&gt;iOff&lt;/code&gt;.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException If the input is not valid Base64 encoded
	 *                                  data.
	 */
	public static byte[] decode(char[] in, int iOff, int iLen) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">		if (iLen % 4 != 0)</span>
<span class="nc" id="L263">			throw new IllegalArgumentException(&quot;Length of Base64 encoded input string is not a multiple of 4.&quot;);</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">		while (iLen &gt; 0 &amp;&amp; in[iOff + iLen - 1] == '=')</span>
<span class="nc" id="L265">			iLen--;</span>
<span class="nc" id="L266">		int oLen = (iLen * 3) / 4;</span>
<span class="nc" id="L267">		byte[] out = new byte[oLen];</span>
<span class="nc" id="L268">		int ip = iOff;</span>
<span class="nc" id="L269">		int iEnd = iOff + iLen;</span>
<span class="nc" id="L270">		int op = 0;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		while (ip &lt; iEnd) {</span>
<span class="nc" id="L272">			int i0 = in[ip++];</span>
<span class="nc" id="L273">			int i1 = in[ip++];</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">			int i2 = ip &lt; iEnd ? in[ip++] : 'A';</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			int i3 = ip &lt; iEnd ? in[ip++] : 'A';</span>
<span class="nc bnc" id="L276" title="All 8 branches missed.">			if (i0 &gt; 127 || i1 &gt; 127 || i2 &gt; 127 || i3 &gt; 127)</span>
<span class="nc" id="L277">				throw new IllegalArgumentException(&quot;Illegal character in Base64 encoded data.&quot;);</span>
<span class="nc" id="L278">			int b0 = map2[i0];</span>
<span class="nc" id="L279">			int b1 = map2[i1];</span>
<span class="nc" id="L280">			int b2 = map2[i2];</span>
<span class="nc" id="L281">			int b3 = map2[i3];</span>
<span class="nc bnc" id="L282" title="All 8 branches missed.">			if (b0 &lt; 0 || b1 &lt; 0 || b2 &lt; 0 || b3 &lt; 0)</span>
<span class="nc" id="L283">				throw new IllegalArgumentException(&quot;Illegal character in Base64 encoded data.&quot;);</span>
<span class="nc" id="L284">			int o0 = (b0 &lt;&lt; 2) | (b1 &gt;&gt;&gt; 4);</span>
<span class="nc" id="L285">			int o1 = ((b1 &amp; 0xf) &lt;&lt; 4) | (b2 &gt;&gt;&gt; 2);</span>
<span class="nc" id="L286">			int o2 = ((b2 &amp; 3) &lt;&lt; 6) | b3;</span>
<span class="nc" id="L287">			out[op++] = (byte) o0;</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if (op &lt; oLen)</span>
<span class="nc" id="L289">				out[op++] = (byte) o1;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">			if (op &lt; oLen)</span>
<span class="nc" id="L291">				out[op++] = (byte) o2;</span>
<span class="nc" id="L292">		}</span>
<span class="nc" id="L293">		return out;</span>
	}

	// Dummy constructor.
	private Base64Coder() {
	}

} // end class Base64Coder
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>