<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DiagramShape.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">org.stathissideris.ascii2image.graphics</a> &gt; <span class="el_source">DiagramShape.java</span></div><h1>DiagramShape.java</h1><pre class="source lang-java linenums">/**
 * ditaa - Diagrams Through Ascii Art
 * 
 * Copyright (C) 2004-2011 Efstathios Sideris
 *
 * ditaa is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as 
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * ditaa is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with ditaa.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *   
 */
package org.stathissideris.ascii2image.graphics;

import java.awt.Color;
import java.awt.Rectangle;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.stathissideris.ascii2image.core.RenderingOptions;
import org.stathissideris.ascii2image.text.TextGrid;

/**
 * 
 * @author Efstathios Sideris
 */
<span class="nc" id="L38">public class DiagramShape extends DiagramComponent {</span>
	
	private static final boolean DEBUG = false;
	
	public static final int TYPE_SIMPLE = 0;
	public static final int TYPE_ARROWHEAD = 1;
	public static final int TYPE_POINT_MARKER = 2;
	public static final int TYPE_DOCUMENT = 3;
	public static final int TYPE_STORAGE = 4;
	public static final int TYPE_IO = 5;
	public static final int TYPE_DECISION = 6;
	public static final int TYPE_MANUAL_OPERATION = 7; // upside-down trapezoid
	public static final int TYPE_TRAPEZOID = 8; // rightside-up trapezoid
	public static final int TYPE_ELLIPSE = 9;
	public static final int TYPE_CUSTOM = 9999;

	/** The slope of side lines on trapezoids (mo, tr) and parallelograms (io). */
	public static final float SHAPE_SLOPE = 8;

<span class="nc" id="L57">	protected int type = TYPE_SIMPLE;</span>

<span class="nc" id="L59">	private Color fillColor = null;</span>
<span class="nc" id="L60">	private Color strokeColor = Color.black;</span>
	
<span class="nc" id="L62">	private boolean isClosed = false;</span>
<span class="nc" id="L63">	private boolean isStrokeDashed = false;</span>

<span class="nc" id="L65">	protected ArrayList&lt;ShapePoint&gt; points = new ArrayList&lt;ShapePoint&gt;();</span>

<span class="nc" id="L67">	CustomShapeDefinition definition = null;</span>

	public static void main(String[] args) {
<span class="nc" id="L70">	}</span>

	public static DiagramShape createArrowhead(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L73" title="All 2 branches missed.">		if(!grid.isArrowhead(cell)) return null;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		if(grid.isNorthArrowhead(cell)) return createNorthArrowhead(grid, cell, cellXSize, cellYSize);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">		if(grid.isSouthArrowhead(cell)) return createSouthArrowhead(grid, cell, cellXSize, cellYSize);</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">		if(grid.isWestArrowhead(cell)) return createWestArrowhead(grid, cell, cellXSize, cellYSize);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		if(grid.isEastArrowhead(cell)) return createEastArrowhead(grid, cell, cellXSize, cellYSize);</span>
<span class="nc" id="L78">		return null;</span>
	}

	private static DiagramShape createNorthArrowhead(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">		if(!grid.isNorthArrowhead(cell)) return null;</span>
<span class="nc" id="L83">		DiagramShape shape = new DiagramShape();</span>
<span class="nc" id="L84">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L85">			Diagram.getCellMidX(cell,cellXSize),</span>
<span class="nc" id="L86">			Diagram.getCellMinY(cell,cellYSize)));</span>
<span class="nc" id="L87">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L88">			Diagram.getCellMinX(cell,cellXSize),</span>
<span class="nc" id="L89">			Diagram.getCellMaxY(cell,cellYSize)));</span>
<span class="nc" id="L90">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L91">			Diagram.getCellMaxX(cell,cellXSize),</span>
<span class="nc" id="L92">			Diagram.getCellMaxY(cell,cellYSize)));</span>
<span class="nc" id="L93">		shape.setClosed(true);</span>
<span class="nc" id="L94">		shape.setFillColor(Color.black);</span>
<span class="nc" id="L95">		shape.setStrokeColor(Color.black);</span>
<span class="nc" id="L96">		shape.setType(TYPE_ARROWHEAD);</span>
<span class="nc" id="L97">		return shape;</span>
	}

	private static DiagramShape createSouthArrowhead(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L101" title="All 2 branches missed.">		if(!grid.isSouthArrowhead(cell)) return null;</span>
<span class="nc" id="L102">		DiagramShape shape = new DiagramShape();</span>
<span class="nc" id="L103">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L104">			Diagram.getCellMinX(cell,cellXSize),</span>
<span class="nc" id="L105">			Diagram.getCellMinY(cell,cellYSize)));</span>
<span class="nc" id="L106">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L107">			Diagram.getCellMidX(cell,cellXSize),</span>
<span class="nc" id="L108">			Diagram.getCellMaxY(cell,cellYSize)));</span>
<span class="nc" id="L109">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L110">			Diagram.getCellMaxX(cell,cellXSize),</span>
<span class="nc" id="L111">			Diagram.getCellMinY(cell,cellYSize)));</span>
<span class="nc" id="L112">		shape.setClosed(true);</span>
<span class="nc" id="L113">		shape.setFillColor(Color.black);</span>
<span class="nc" id="L114">		shape.setStrokeColor(Color.black);</span>
<span class="nc" id="L115">		shape.setType(TYPE_ARROWHEAD);</span>
<span class="nc" id="L116">		return shape;</span>
	}

	private static DiagramShape createWestArrowhead(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L120" title="All 2 branches missed.">		if(!grid.isWestArrowhead(cell)) return null;</span>
<span class="nc" id="L121">		DiagramShape shape = new DiagramShape();</span>
<span class="nc" id="L122">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L123">			Diagram.getCellMaxX(cell,cellXSize),</span>
<span class="nc" id="L124">			Diagram.getCellMinY(cell,cellYSize)));</span>
<span class="nc" id="L125">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L126">			Diagram.getCellMinX(cell,cellXSize),</span>
<span class="nc" id="L127">			Diagram.getCellMidY(cell,cellYSize)));</span>
<span class="nc" id="L128">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L129">			Diagram.getCellMaxX(cell,cellXSize),</span>
<span class="nc" id="L130">			Diagram.getCellMaxY(cell,cellYSize)));</span>
<span class="nc" id="L131">		shape.setClosed(true);</span>
<span class="nc" id="L132">		shape.setFillColor(Color.black);</span>
<span class="nc" id="L133">		shape.setStrokeColor(Color.black);</span>
<span class="nc" id="L134">		shape.setType(TYPE_ARROWHEAD);</span>
<span class="nc" id="L135">		return shape;</span>
	}
	
	private static DiagramShape createEastArrowhead(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if(!grid.isEastArrowhead(cell)) return null;</span>
<span class="nc" id="L140">		DiagramShape shape = new DiagramShape();</span>
<span class="nc" id="L141">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L142">			Diagram.getCellMinX(cell,cellXSize),</span>
<span class="nc" id="L143">			Diagram.getCellMinY(cell,cellYSize)));</span>
<span class="nc" id="L144">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L145">			Diagram.getCellMaxX(cell,cellXSize),</span>
<span class="nc" id="L146">			Diagram.getCellMidY(cell,cellYSize)));</span>
<span class="nc" id="L147">		shape.addToPoints(new ShapePoint(</span>
<span class="nc" id="L148">			Diagram.getCellMinX(cell,cellXSize),</span>
<span class="nc" id="L149">			Diagram.getCellMaxY(cell,cellYSize)));</span>
<span class="nc" id="L150">		shape.setClosed(true);</span>
<span class="nc" id="L151">		shape.setFillColor(Color.black);</span>
<span class="nc" id="L152">		shape.setStrokeColor(Color.black);</span>
<span class="nc" id="L153">		shape.setType(TYPE_ARROWHEAD);</span>
<span class="nc" id="L154">		return shape;</span>
	}

	public static DiagramShape createSmallLine(TextGrid grid, TextGrid.Cell cell, int cellXSize, int cellYSize) {
<span class="nc bnc" id="L158" title="All 2 branches missed.">		if (grid.isLine(cell)) {</span>
<span class="nc" id="L159">			DiagramShape shape = new DiagramShape();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">			if (grid.isHorizontalLine(cell)) {</span>
<span class="nc" id="L161">				shape.addToPoints(</span>
					new ShapePoint(
						cell.x * cellXSize,
						cell.y * cellYSize + cellYSize / 2));
<span class="nc" id="L165">				shape.addToPoints(</span>
					new ShapePoint(
						cell.x * cellXSize + cellXSize - 1,
						cell.y * cellYSize + cellYSize / 2));
<span class="nc bnc" id="L169" title="All 2 branches missed.">			} else if (grid.isVerticalLine(cell)) {</span>
<span class="nc" id="L170">				shape.addToPoints(</span>
					new ShapePoint(
						cell.x * cellXSize + cellXSize / 2,
						cell.y * cellYSize));
<span class="nc" id="L174">				shape.addToPoints(</span>
					new ShapePoint(
						cell.x * cellXSize + cellXSize / 2,
						cell.y * cellYSize + cellYSize - 1));
			}
			
			//the -1 above, make a difference: the second point
			//should not fall into the next cell, because this
			//results in a failure of a proper end-of-line
			//plotting correction
<span class="nc" id="L184">			return shape;</span>
		}
<span class="nc" id="L186">		return null;</span>
	}

	public void addToPoints(ShapePoint point){
<span class="nc" id="L190">		points.add(point);</span>
<span class="nc" id="L191">	}</span>
	
	public Iterator getPointsIterator(){
<span class="nc" id="L194">		return points.iterator();</span>
	}
	
	public void scale(float factor){
<span class="nc" id="L198">		Iterator it = getPointsIterator();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">		while(it.hasNext()){</span>
<span class="nc" id="L200">			ShapePoint point = (ShapePoint) it.next();</span>
<span class="nc" id="L201">			point.x *= factor;</span>
<span class="nc" id="L202">			point.y *= factor;</span>
<span class="nc" id="L203">		}</span>
<span class="nc" id="L204">	}</span>
	
	public boolean isEmpty(){
<span class="nc" id="L207">		return points.isEmpty();</span>
	}
	
	public boolean isFilled(){
<span class="nc bnc" id="L211" title="All 2 branches missed.">		return (fillColor != null);</span>
	}
	
	public void setIsNotFilled(){
<span class="nc" id="L215">		fillColor = null;</span>
<span class="nc" id="L216">	}</span>
	
	public boolean isPointLinesEnd(ShapePoint point){
<span class="nc bnc" id="L219" title="All 2 branches missed.">		if(isClosed()) return false; //no line-ends in closed shapes!</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if(point == points.get(0)) return true;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if(point == points.get(points.size() - 1)) return true;</span>
<span class="nc" id="L222">		return false;</span>
	}
	
	//TODO: method in development: isRectangle()
	public boolean isRectangle(){
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if(points.size() != 4) return false;</span>
<span class="nc" id="L228">		ShapePoint p1 = (ShapePoint) points.get(0);</span>
<span class="nc" id="L229">		ShapePoint p2 = (ShapePoint) points.get(1);</span>
<span class="nc" id="L230">		ShapePoint p3 = (ShapePoint) points.get(2);</span>
<span class="nc" id="L231">		ShapePoint p4 = (ShapePoint) points.get(3);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">		if(p1.isInLineWith(p2) </span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">			&amp;&amp; p2.isInLineWith(p3)</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			&amp;&amp; p3.isInLineWith(p4)</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">			&amp;&amp; p4.isInLineWith(p1)) return true;</span>
<span class="nc" id="L236">		return false;</span>
	}
	
	/**
	 * Crude way to determine which of the two shapes is smaller,
	 * based just on their bounding boxes. Used in markup
	 * assignment precendence.
	 * 
	 * @param other
	 * @return
	 */
	public boolean isSmallerThan(DiagramShape other){
<span class="nc" id="L248">		Rectangle bounds = getBounds();</span>
<span class="nc" id="L249">		Rectangle otherBounds = other.getBounds();</span>
		
<span class="nc" id="L251">		int area = bounds.height * bounds.width;</span>
<span class="nc" id="L252">		int otherArea = otherBounds.height * otherBounds.width;</span>
		
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if(area &lt; otherArea) {</span>
<span class="nc" id="L255">			return true;</span>
		}
<span class="nc" id="L257">		return false;</span>
	}
	
	/**
	 * @return
	 */
	public Color getFillColor() {
<span class="nc" id="L264">		return fillColor;</span>
	}

	/**
	 * @return
	 */
	public Color getStrokeColor() {
<span class="nc" id="L271">		return strokeColor;</span>
	}

	/**
	 * @param color
	 */
	public void setFillColor(Color color) {
<span class="nc" id="L278">		fillColor = color;</span>
<span class="nc" id="L279">	}</span>

	/**
	 * @param color
	 */
	public void setStrokeColor(Color color) {
<span class="nc" id="L285">		strokeColor = color;</span>
<span class="nc" id="L286">	}</span>

	/**
	 * @return
	 */
	public boolean isClosed() {
<span class="nc" id="L292">		return isClosed;</span>
	}

	/**
	 * @param b
	 */
	public void setClosed(boolean b) {
<span class="nc" id="L299">		isClosed = b;</span>
<span class="nc" id="L300">	}</span>

	public void printDebug(){
<span class="nc" id="L303">		System.out.print(&quot;DiagramShape: &quot;);</span>
<span class="nc" id="L304">		System.out.println(points.size()+&quot; points&quot;);</span>
<span class="nc" id="L305">	}</span>

	/**
	 * @return
	 */
	public ArrayList getPoints() {
<span class="nc" id="L311">		return points;</span>
	}

	public ShapePoint getPoint(int i) {
<span class="nc" id="L315">		return (ShapePoint) points.get(i);</span>
	}

	public void setPoint(int i, ShapePoint point) {
<span class="nc" id="L319">		points.set(i, point);</span>
<span class="nc" id="L320">	}</span>


	public boolean equals(Object object){
<span class="nc" id="L324">		DiagramShape shape = null;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">		if(!(object instanceof DiagramShape)) { return false; }</span>
<span class="nc" id="L326">		else shape = (DiagramShape) object;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if(getPoints().size() != shape.getPoints().size()) return false;</span>
		
		if(DEBUG) System.out.println(&quot;comparing shapes:&quot;);
		
		if(DEBUG) System.out.println(&quot;points1: &quot;);
<span class="nc" id="L332">		HashMap points1 = new HashMap();</span>
<span class="nc" id="L333">		Iterator it = getPointsIterator(); </span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">		while(it.hasNext()){</span>
<span class="nc" id="L335">			ShapePoint point = (ShapePoint) it.next(); </span>
<span class="nc" id="L336">			points1.put( &quot;&quot;+((int) point.x)+&quot;,&quot;+((int) point.y), null);</span>
			if(DEBUG) System.out.println(((int) point.x)+&quot;, &quot;+((int) point.y));
<span class="nc" id="L338">		}</span>
		
		if(DEBUG) System.out.println(&quot;points2: &quot;);
<span class="nc" id="L341">		HashMap points2 = new HashMap();</span>
<span class="nc" id="L342">		it = shape.getPointsIterator(); </span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">		while(it.hasNext()){</span>
<span class="nc" id="L344">			ShapePoint point = (ShapePoint) it.next(); </span>
<span class="nc" id="L345">			points2.put( &quot;&quot;+((int) point.x)+&quot;,&quot;+((int) point.y), null);</span>
			if(DEBUG) System.out.println(((int) point.x)+&quot;, &quot;+((int) point.y));
<span class="nc" id="L347">		}</span>
		
<span class="nc" id="L349">		it = points1.keySet().iterator();</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		while(it.hasNext()){</span>
<span class="nc" id="L351">			String key = (String) it.next();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">			if(!points2.containsKey(key)) {</span>
				if (DEBUG)
					System.out.println(&quot;\tare not equal&quot;);
<span class="nc" id="L355">				return false;</span>
			} 
<span class="nc" id="L357">		}</span>
		if (DEBUG)
			System.out.println(&quot;\tare equal&quot;);
<span class="nc" id="L360">		return true;</span>
	}

	public GeneralPath makeIntoPath() {
<span class="nc" id="L364">		int size = getPoints().size();</span>
		
<span class="nc bnc" id="L366" title="All 2 branches missed.">		if(size &lt; 2) return null;</span>
		
<span class="nc" id="L368">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L369">		ShapePoint point = (ShapePoint) getPoints().get(0);</span>
<span class="nc" id="L370">		path.moveTo((int) point.x, (int) point.y);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">		for(int i = 1; i &lt; size; i++){</span>
<span class="nc" id="L372">			point = (ShapePoint) getPoints().get(i);</span>
<span class="nc" id="L373">			path.lineTo((int) point.x, (int) point.y);</span>
		}
<span class="nc bnc" id="L375" title="All 4 branches missed.">		if(isClosed() &amp;&amp; size &gt; 2){</span>
<span class="nc" id="L376">			path.closePath();</span>
		}
<span class="nc" id="L378">		return path;</span>
	}

	public GeneralPath makeMarkerPath(Diagram diagram){
<span class="nc bnc" id="L382" title="All 2 branches missed.">		if(points.size() != 1) return null;</span>
<span class="nc" id="L383">		ShapePoint center = (ShapePoint) this.getPoint(0);</span>
<span class="nc" id="L384">		float diameter =</span>
<span class="nc" id="L385">			(float) 0.7 * Math.min(diagram.getCellWidth(), diagram.getCellHeight());</span>
<span class="nc" id="L386">		return new GeneralPath(new Ellipse2D.Float(</span>
			center.x - diameter/2,
			center.y - diameter/2,
			diameter,
			diameter));
	}

	public Rectangle getBounds(){
<span class="nc" id="L394">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L395">		return bounds;</span>
	}
	
	public GeneralPath makeIntoRenderPath(Diagram diagram, RenderingOptions options) {
<span class="nc" id="L399">		int size = getPoints().size();</span>
		
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if(getType() == TYPE_POINT_MARKER){</span>
<span class="nc" id="L402">			return makeMarkerPath(diagram);</span>
		}
		
<span class="nc bnc" id="L405" title="All 4 branches missed.">		if(getType() == TYPE_DOCUMENT &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L406">			return makeDocumentPath(diagram);</span>
		}

<span class="nc bnc" id="L409" title="All 4 branches missed.">		if(getType() == TYPE_STORAGE &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L410">			return makeStoragePath(diagram);</span>
		}

<span class="nc bnc" id="L413" title="All 4 branches missed.">		if(getType() == TYPE_IO &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L414">			return makeIOPath(diagram, options);</span>
		}

<span class="nc bnc" id="L417" title="All 4 branches missed.">		if(getType() == TYPE_DECISION &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L418">			return makeDecisionPath(diagram);</span>
		}

<span class="nc bnc" id="L421" title="All 4 branches missed.">		if(getType() == TYPE_MANUAL_OPERATION &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L422">			return makeTrapezoidPath(diagram, options, true);</span>
		}

<span class="nc bnc" id="L425" title="All 4 branches missed.">		if(getType() == TYPE_TRAPEZOID &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L426">			return makeTrapezoidPath(diagram, options, false);</span>
		}

<span class="nc bnc" id="L429" title="All 4 branches missed.">		if(getType() == TYPE_ELLIPSE &amp;&amp; points.size() == 4){</span>
<span class="nc" id="L430">			return makeEllipsePath(diagram);</span>
		}

<span class="nc bnc" id="L433" title="All 2 branches missed.">		if(size &lt; 2) return null;</span>

<span class="nc" id="L435">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L436">		ShapePoint point = (ShapePoint) getPoints().get(0);</span>
<span class="nc" id="L437">		TextGrid.Cell cell = diagram.getCellFor(point);</span>
		//path.moveTo((int) point.x, (int) point.y);
<span class="nc" id="L439">		ShapePoint previous = (ShapePoint) getPoints().get(size - 1);</span>
<span class="nc" id="L440">		ShapePoint next = (ShapePoint) getPoints().get(1);</span>
		ShapePoint entryPoint;
		ShapePoint exitPoint;
		
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if(point.getType() == ShapePoint.TYPE_NORMAL){</span>
			//if(isClosed()){
<span class="nc" id="L446">				path.moveTo((int) point.x, (int) point.y);</span>
			/*} else {
				ShapePoint projectionPoint = getCellEdgeProjectionPointBetween(point, next, diagram);
				path.moveTo((int) projectionPoint.x, (int) projectionPoint.y);
			}*/
<span class="nc bnc" id="L451" title="All 2 branches missed.">		} else if(point.getType() == ShapePoint.TYPE_ROUND){</span>
<span class="nc" id="L452">			entryPoint = getCellEdgePointBetween(point, previous, diagram);</span>
<span class="nc" id="L453">			exitPoint = getCellEdgePointBetween(point, next, diagram);</span>
<span class="nc" id="L454">			path.moveTo(entryPoint.x, entryPoint.y);</span>
<span class="nc" id="L455">			path.quadTo(point.x, point.y, exitPoint.x, exitPoint.y);			</span>
		}

<span class="nc bnc" id="L458" title="All 2 branches missed.">		for(int i = 1; i &lt; size; i++){</span>
<span class="nc" id="L459">			previous = point;</span>
<span class="nc" id="L460">			point = (ShapePoint) getPoints().get(i);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">			if(i &lt; size - 1)</span>
<span class="nc" id="L462">				next = (ShapePoint) getPoints().get(i + 1);</span>
<span class="nc" id="L463">			else next = (ShapePoint) getPoints().get(0);</span>

<span class="nc" id="L465">			cell = diagram.getCellFor(point);</span>

<span class="nc bnc" id="L467" title="All 2 branches missed.">			if(point.getType() == ShapePoint.TYPE_NORMAL)</span>
				//if(!isPointLinesEnd(point))
<span class="nc" id="L469">					path.lineTo((int) point.x, (int) point.y);</span>
				/*else { //it is line's end, so we plot it at the projected intersection of the line with the cell's edge
					ShapePoint projectionPoint = getCellEdgeProjectionPointBetween(point, previous, diagram);
					path.lineTo((int) projectionPoint.x, (int) projectionPoint.y);
				}*/
<span class="nc bnc" id="L474" title="All 2 branches missed.">			else if(point.getType() == ShapePoint.TYPE_ROUND){</span>
<span class="nc" id="L475">				entryPoint = getCellEdgePointBetween(point, previous, diagram);</span>
<span class="nc" id="L476">				exitPoint = getCellEdgePointBetween(point, next, diagram);</span>

<span class="nc" id="L478">				path.lineTo(entryPoint.x, entryPoint.y);</span>
<span class="nc" id="L479">				path.quadTo(point.x, point.y, exitPoint.x, exitPoint.y);</span>
				//if(!isPointLinesEnd(next)){
<span class="nc bnc" id="L481" title="All 2 branches missed.">					if(next.getType() == ShapePoint.TYPE_NORMAL)</span>
<span class="nc" id="L482">						path.lineTo(next.x, next.y);</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">					else if(next.getType() == ShapePoint.TYPE_ROUND){</span>
<span class="nc" id="L484">						entryPoint = getCellEdgePointBetween(next, point, diagram);</span>
<span class="nc" id="L485">						path.lineTo(entryPoint.x, entryPoint.y);					</span>
					}
				/*} else {
					entryPoint = getCellEdgeProjectionPointBetween(next, point, diagram);
					path.lineTo(entryPoint.x, entryPoint.y);										
				}*/
			} 
		}
		//TODO: this shouldn't be needed, but it is!
<span class="nc bnc" id="L494" title="All 4 branches missed.">		if(isClosed() &amp;&amp; size &gt; 2){</span>
<span class="nc" id="L495">			path.closePath();</span>
		}
<span class="nc" id="L497">		return path;</span>
	}
	
	public ArrayList getEdges(){
<span class="nc" id="L501">		ArrayList edges = new ArrayList();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">		if(this.points.size() == 1) return edges;</span>
<span class="nc" id="L503">		int noOfPoints = points.size();</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">		for(int i = 0; i &lt; noOfPoints - 1; i++){</span>
<span class="nc" id="L505">			ShapePoint startPoint = (ShapePoint) points.get(i);</span>
<span class="nc" id="L506">			ShapePoint endPoint = (ShapePoint) points.get(i + 1);</span>
<span class="nc" id="L507">			ShapeEdge edge = new ShapeEdge(startPoint, endPoint, this);</span>
<span class="nc" id="L508">			edges.add(edge);</span>
		}
		//if it is closed return edge that connects the
		//last point to the first
<span class="nc bnc" id="L512" title="All 2 branches missed.">		if(this.isClosed()){</span>
<span class="nc" id="L513">			ShapePoint firstPoint = (ShapePoint) points.get(0);</span>
<span class="nc" id="L514">			ShapePoint lastPoint = (ShapePoint) points.get(points.size() - 1);</span>
<span class="nc" id="L515">			ShapeEdge edge = new ShapeEdge(lastPoint, firstPoint, this);</span>
<span class="nc" id="L516">			edges.add(edge);</span>
		}
<span class="nc" id="L518">		return edges;</span>
	}

	/**
	 * Finds the point that represents the intersection between the cell edge
	 * that contains pointInCell and the line connecting pointInCell and
	 * otherPoint.
	 * 
  	 * Returns C, if A is point in cell and B is otherPoint:
	 * &lt;pre&gt;
	 *     Cell
	 *    +-----+
	 *    |  A  |C                 B
	 *    |  *--*------------------*
	 *    |     |
	 *    +-----+
	 *&lt;/pre&gt;
	 *
	 * @param pointInCell
	 * @param otherPoint
	 * @return
	 */
	public ShapePoint getCellEdgePointBetween(ShapePoint pointInCell, ShapePoint otherPoint, Diagram diagram){
<span class="nc bnc" id="L541" title="All 6 branches missed.">		if(pointInCell == null || otherPoint == null || diagram == null)</span>
<span class="nc" id="L542">			throw new IllegalArgumentException(&quot;None of the parameters can be null&quot;);</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">		if(pointInCell.equals(otherPoint))</span>
<span class="nc" id="L544">			throw new IllegalArgumentException(&quot;The two points cannot be the same&quot;);</span>

<span class="nc" id="L546">		ShapePoint result = null;</span>
<span class="nc" id="L547">		TextGrid.Cell cell = diagram.getCellFor(pointInCell);</span>
		
<span class="nc bnc" id="L549" title="All 2 branches missed.">		if(cell == null)</span>
<span class="nc" id="L550">			throw new RuntimeException(&quot;Upexpected error, cannot find cell corresponding to point &quot;+pointInCell+&quot; for diagram &quot;+diagram);</span>
		
<span class="nc bnc" id="L552" title="All 2 branches missed.">		if(otherPoint.isNorthOf(pointInCell))</span>
<span class="nc" id="L553">			result = new ShapePoint(pointInCell.x,</span>
<span class="nc" id="L554">										diagram.getCellMinY(cell));</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">		else if(otherPoint.isSouthOf(pointInCell))</span>
<span class="nc" id="L556">			result = new ShapePoint(pointInCell.x,</span>
<span class="nc" id="L557">										diagram.getCellMaxY(cell));</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">		else if(otherPoint.isWestOf(pointInCell))</span>
<span class="nc" id="L559">			result = new ShapePoint(diagram.getCellMinX(cell),</span>
										pointInCell.y);
<span class="nc bnc" id="L561" title="All 2 branches missed.">		else if(otherPoint.isEastOf(pointInCell))</span>
<span class="nc" id="L562">			result = new ShapePoint(diagram.getCellMaxX(cell),</span>
										pointInCell.y);
		
<span class="nc bnc" id="L565" title="All 2 branches missed.">		if(result == null)</span>
<span class="nc" id="L566">			throw new RuntimeException(&quot;Upexpected error, cannot find cell edge point for points &quot;+pointInCell+&quot; and &quot;+otherPoint+&quot; for diagram &quot;+diagram);</span>

		
<span class="nc" id="L569">		return result;</span>
	}


	/**
	 * 
	 * Returns C, if A is point in cell and B is otherPoint:
	 * 
	 * &lt;pre&gt;
	 *     Cell
	 *    +-----+
	 *    |  A  |                  B
	 *  C *--*--+------------------*
	 *    |     |
	 *    +-----+
	 * &lt;/pre&gt;
	 * 
	 * @param pointInCell
	 * @param otherPoint
	 * @param diagram
	 * @return
	 */

	public ShapePoint getCellEdgeProjectionPointBetween(ShapePoint pointInCell, ShapePoint otherPoint, Diagram diagram){
<span class="nc bnc" id="L593" title="All 6 branches missed.">		if(pointInCell == null || otherPoint == null || diagram == null)</span>
<span class="nc" id="L594">			throw new IllegalArgumentException(&quot;None of the parameters can be null&quot;);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">		if(pointInCell.equals(otherPoint))</span>
<span class="nc" id="L596">			throw new IllegalArgumentException(&quot;The two points cannot be the same: &quot;+pointInCell+&quot; and &quot;+otherPoint+&quot; passed&quot;);</span>

<span class="nc" id="L598">		ShapePoint result = null;</span>
<span class="nc" id="L599">		TextGrid.Cell cell = diagram.getCellFor(pointInCell);</span>
		
<span class="nc bnc" id="L601" title="All 2 branches missed.">		if(cell == null)</span>
<span class="nc" id="L602">			throw new RuntimeException(&quot;Unexpected error, cannot find cell corresponding to point &quot;+pointInCell+&quot; for diagram &quot;+diagram);</span>
		
<span class="nc bnc" id="L604" title="All 2 branches missed.">		if(otherPoint.isNorthOf(pointInCell))</span>
<span class="nc" id="L605">			result = new ShapePoint(pointInCell.x,</span>
<span class="nc" id="L606">										diagram.getCellMaxY(cell));</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">		else if(otherPoint.isSouthOf(pointInCell))</span>
<span class="nc" id="L608">			result = new ShapePoint(pointInCell.x,</span>
<span class="nc" id="L609">										diagram.getCellMinY(cell));</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">		else if(otherPoint.isWestOf(pointInCell))</span>
<span class="nc" id="L611">			result = new ShapePoint(diagram.getCellMaxX(cell),</span>
										pointInCell.y);
<span class="nc bnc" id="L613" title="All 2 branches missed.">		else if(otherPoint.isEastOf(pointInCell))</span>
<span class="nc" id="L614">			result = new ShapePoint(diagram.getCellMinX(cell),</span>
										pointInCell.y);
		
<span class="nc bnc" id="L617" title="All 2 branches missed.">		if(result == null)</span>
<span class="nc" id="L618">			throw new RuntimeException(&quot;Unexpected error, cannot find cell edge point for points &quot;+pointInCell+&quot; and &quot;+otherPoint+&quot; for diagram &quot;+diagram);</span>

		
<span class="nc" id="L621">		return result;</span>
	}

	public boolean contains(ShapePoint point){
<span class="nc" id="L625">		GeneralPath path = makeIntoPath();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">		if(path != null) return path.contains(point);</span>
<span class="nc" id="L627">		return false;</span>
	}

	public boolean contains(Rectangle2D rect){
<span class="nc" id="L631">		GeneralPath path = makeIntoPath();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">		if(path != null) return path.contains(rect);</span>
<span class="nc" id="L633">		return false;</span>
	}

	public boolean intersects(Rectangle2D rect){
<span class="nc" id="L637">		GeneralPath path = makeIntoPath();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">		if(path != null) return path.intersects(rect);</span>
<span class="nc" id="L639">		return false;</span>
	}
	
	public boolean dropsShadow(){
<span class="nc bnc" id="L643" title="All 2 branches missed.">		return (isClosed()</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">				&amp;&amp; getType() != DiagramShape.TYPE_ARROWHEAD</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">				&amp;&amp; getType() != DiagramShape.TYPE_POINT_MARKER</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">				&amp;&amp; !isStrokeDashed());</span>
	}

	/**
	 * @return
	 */
	public int getType() {
<span class="nc" id="L653">		return type;</span>
	}

	/**
	 * @param i
	 */
	public void setType(int i) {
<span class="nc" id="L660">		type = i;</span>
<span class="nc" id="L661">	}</span>
	
	public void moveEndsToCellEdges(TextGrid grid, Diagram diagram){
<span class="nc bnc" id="L664" title="All 2 branches missed.">		if(isClosed()) return;</span>
		
<span class="nc" id="L666">		ShapePoint linesEnd = (ShapePoint) points.get(0);</span>
<span class="nc" id="L667">		ShapePoint nextPoint = (ShapePoint) points.get(1);</span>

<span class="nc" id="L669">		ShapePoint projectionPoint = getCellEdgeProjectionPointBetween(linesEnd, nextPoint, diagram);</span>
		
<span class="nc" id="L671">		linesEnd.moveTo(projectionPoint);</span>

<span class="nc" id="L673">		linesEnd = (ShapePoint) points.get(points.size() - 1);</span>
<span class="nc" id="L674">		nextPoint = (ShapePoint) points.get(points.size() - 2);</span>

<span class="nc" id="L676">		projectionPoint = getCellEdgeProjectionPointBetween(linesEnd, nextPoint, diagram);</span>
		
<span class="nc" id="L678">		linesEnd.moveTo(projectionPoint);</span>
<span class="nc" id="L679">	}</span>
	
	public void connectEndsToAnchors(TextGrid grid, Diagram diagram){
<span class="nc bnc" id="L682" title="All 2 branches missed.">		if(isClosed()) return;</span>

		ShapePoint linesEnd;
		ShapePoint nextPoint;

<span class="nc" id="L687">		linesEnd = (ShapePoint) points.get(0);</span>
<span class="nc" id="L688">		nextPoint = (ShapePoint) points.get(1);</span>
		
<span class="nc" id="L690">		connectEndToAnchors(grid, diagram, nextPoint, linesEnd);</span>
		
<span class="nc" id="L692">		linesEnd = (ShapePoint) points.get(points.size() - 1);</span>
<span class="nc" id="L693">		nextPoint = (ShapePoint) points.get(points.size() - 2);</span>
		
<span class="nc" id="L695">		connectEndToAnchors(grid, diagram, nextPoint, linesEnd);</span>
		
<span class="nc" id="L697">	}</span>
	
	
	//TODO: improve connect Ends To Arrowheads to take direction into account
	private void connectEndToAnchors(
			TextGrid grid,
			Diagram diagram,
			ShapePoint nextPoint,
			ShapePoint linesEnd){

<span class="nc bnc" id="L707" title="All 2 branches missed.">		if(isClosed()) return;</span>

		TextGrid.Cell anchorCell;
<span class="nc" id="L710">		anchorCell = getPossibleAnchorCell(linesEnd, nextPoint, diagram);</span>
		
<span class="nc bnc" id="L712" title="All 2 branches missed.">		if(grid.isArrowhead(anchorCell)){</span>
<span class="nc" id="L713">			linesEnd.x = diagram.getCellMidX(anchorCell);</span>
<span class="nc" id="L714">			linesEnd.y = diagram.getCellMidY(anchorCell);</span>
<span class="nc" id="L715">			linesEnd.setLocked(true);</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">		} else if (grid.isCorner(anchorCell) || grid.isIntersection(anchorCell)){</span>
<span class="nc" id="L717">			linesEnd.x = diagram.getCellMidX(anchorCell);</span>
<span class="nc" id="L718">			linesEnd.y = diagram.getCellMidY(anchorCell);</span>
<span class="nc" id="L719">			linesEnd.setLocked(true);</span>
		}
<span class="nc" id="L721">	}</span>

	/**
	 * Given the end of a line, the next point and a Diagram, it
	 * returns the cell that may contain intersections or arrowheads
	 * to which the line's end should be connected
	 * 
	 * @param linesEnd
	 * @param nextPoint
	 * @param diagram
	 * @return
	 */
	private static TextGrid.Cell getPossibleAnchorCell(
			ShapePoint linesEnd,
			ShapePoint nextPoint,
			Diagram diagram
			){
<span class="nc" id="L738">		ShapePoint cellPoint = null;</span>

<span class="nc bnc" id="L740" title="All 2 branches missed.">		if(nextPoint.isNorthOf(linesEnd))</span>
<span class="nc" id="L741">			cellPoint = new ShapePoint(linesEnd.x, linesEnd.y + diagram.getCellHeight());</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">		if(nextPoint.isSouthOf(linesEnd))</span>
<span class="nc" id="L743">			cellPoint = new ShapePoint(linesEnd.x, linesEnd.y - diagram.getCellHeight());</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">		if(nextPoint.isWestOf(linesEnd))</span>
<span class="nc" id="L745">			cellPoint = new ShapePoint(linesEnd.x + diagram.getCellWidth(), linesEnd.y);</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if(nextPoint.isEastOf(linesEnd))</span>
<span class="nc" id="L747">			cellPoint = new ShapePoint(linesEnd.x - diagram.getCellWidth(), linesEnd.y);</span>

<span class="nc" id="L749">		return diagram.getCellFor(cellPoint);</span>
	}

	
	public String toString(){
<span class="nc" id="L754">		String s = &quot;DiagramShape, &quot;+points.size()+&quot; points: &quot;;</span>
<span class="nc" id="L755">		Iterator it = getPointsIterator();</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">		while(it.hasNext()){</span>
<span class="nc" id="L757">			ShapePoint point = (ShapePoint) it.next(); </span>
<span class="nc" id="L758">			s += point;</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">			if(it.hasNext()) s += &quot; &quot;; </span>
<span class="nc" id="L760">		}</span>
<span class="nc" id="L761">		return s;</span>
	}

	/**
	 * @return
	 */
	public boolean isStrokeDashed() {
<span class="nc" id="L768">		return isStrokeDashed;</span>
	}

	/**
	 * @param b
	 */
	public void setStrokeDashed(boolean b) {
<span class="nc" id="L775">		isStrokeDashed = b;</span>
<span class="nc" id="L776">	}</span>

	private GeneralPath makeStoragePath(Diagram diagram) {
<span class="nc bnc" id="L779" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L780">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L781">		ShapePoint point1 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMinY());</span>
<span class="nc" id="L782">		ShapePoint point2 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMinY());</span>
<span class="nc" id="L783">		ShapePoint point3 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMaxY());</span>
<span class="nc" id="L784">		ShapePoint point4 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMaxY());</span>
		
<span class="nc" id="L786">		ShapePoint pointMidTop = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getMinY());</span>
<span class="nc" id="L787">		ShapePoint pointMidBottom = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getMaxY());</span>
	
<span class="nc" id="L789">		float diameterX = bounds.width;</span>
<span class="nc" id="L790">		float diameterY = 0.75f * diagram.getCellHeight();</span>
	
		//control point offset X, and Y
<span class="nc" id="L793">		float cpOffsetX = bounds.width / 6;</span>
<span class="nc" id="L794">		float cpOffsetYTop = diagram.getCellHeight() / 2;</span>
<span class="nc" id="L795">		float cpOffsetYBottom = 10 * diagram.getCellHeight() / 14;</span>
		//float cpOffsetYBottom = cpOffsetYTop; 
	
<span class="nc" id="L798">		GeneralPath path = new GeneralPath();</span>
	
		//top of cylinder
<span class="nc" id="L801">		path.moveTo(point1.x, point1.y);</span>
<span class="nc" id="L802">		path.curveTo(</span>
			point1.x + cpOffsetX, point1.y + cpOffsetYTop,
			point2.x - cpOffsetX, point2.y + cpOffsetYTop,
			point2.x, point2.y
			);
<span class="nc" id="L807">		path.curveTo(</span>
			point2.x - cpOffsetX, point2.y - cpOffsetYTop,
			point1.x + cpOffsetX, point1.y - cpOffsetYTop,
			point1.x, point1.y
			);
	
		//side of cylinder
<span class="nc" id="L814">		path.moveTo(point1.x, point1.y);</span>
<span class="nc" id="L815">		path.lineTo(point4.x, point4.y);</span>
		
<span class="nc" id="L817">		path.curveTo(</span>
			point4.x + cpOffsetX, point4.y + cpOffsetYBottom,
			point3.x - cpOffsetX, point3.y + cpOffsetYBottom,
			point3.x, point3.y
			);
	
<span class="nc" id="L823">		path.lineTo(point2.x, point2.y);		</span>
		
<span class="nc" id="L825">		return path;</span>
	}

	private GeneralPath makeDocumentPath(Diagram diagram) {
<span class="nc bnc" id="L829" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L830">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L831">		ShapePoint point1 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMinY());</span>
<span class="nc" id="L832">		ShapePoint point2 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMinY());</span>
<span class="nc" id="L833">		ShapePoint point3 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMaxY());</span>
<span class="nc" id="L834">		ShapePoint point4 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMaxY());</span>
		
<span class="nc" id="L836">		ShapePoint pointMid = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getMaxY());</span>
		
<span class="nc" id="L838">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L839">		path.moveTo(point1.x, point1.y);</span>
<span class="nc" id="L840">		path.lineTo(point2.x, point2.y);</span>
<span class="nc" id="L841">		path.lineTo(point3.x, point3.y);</span>
	
		//int controlDX = diagram.getCellWidth();
		//int controlDY = diagram.getCellHeight() / 2;
		
<span class="nc" id="L846">		int controlDX = bounds.width / 6;</span>
<span class="nc" id="L847">		int controlDY = bounds.height / 8;</span>
		
<span class="nc" id="L849">		path.quadTo(pointMid.x + controlDX, pointMid.y - controlDY, pointMid.x, pointMid.y);</span>
<span class="nc" id="L850">		path.quadTo(pointMid.x - controlDX, pointMid.y + controlDY, point4.x, point4.y);</span>
<span class="nc" id="L851">		path.closePath();</span>
		
<span class="nc" id="L853">		return path;</span>
	}

	// to draw a circle with 4 Bezier curves, set the control points at this ratio of
	// the radius above &amp; below the side points
	// thanks to G. Adam Stanislav, http://whizkidtech.redprince.net/bezier/circle/
<span class="nc" id="L859">	private static final float KAPPA = 4f * ((float) Math.sqrt(2) - 1) / 3f;</span>

	private GeneralPath makeEllipsePath(Diagram diagram) {
<span class="nc bnc" id="L862" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L863">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L864">		float xOff = (float) bounds.getWidth() * 0.5f * KAPPA;</span>
<span class="nc" id="L865">		float yOff = (float) bounds.getHeight() * 0.5f * KAPPA;</span>
<span class="nc" id="L866">		ShapePoint pointMid = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getCenterY());</span>

<span class="nc" id="L868">		ShapePoint left = new ShapePoint((float)bounds.getMinX(), (float)pointMid.getY());</span>
<span class="nc" id="L869">		ShapePoint right = new ShapePoint((float)bounds.getMaxX(), (float)pointMid.getY());</span>
<span class="nc" id="L870">		ShapePoint top = new ShapePoint((float)pointMid.getX(), (float)bounds.getMinY());</span>
<span class="nc" id="L871">		ShapePoint bottom = new ShapePoint((float)pointMid.getX(), (float)bounds.getMaxY());</span>

<span class="nc" id="L873">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L874">		path.moveTo(top.x, top.y);</span>
<span class="nc" id="L875">		path.curveTo(top.x + xOff, top.y, right.x, right.y - yOff, right.x, right.y);</span>
<span class="nc" id="L876">		path.curveTo(right.x, right.y + yOff, bottom.x + xOff, bottom.y, bottom.x, bottom.y);</span>
<span class="nc" id="L877">		path.curveTo(bottom.x - xOff, bottom.y, left.x, left.y + yOff, left.x, left.y);</span>
<span class="nc" id="L878">		path.curveTo(left.x, left.y - yOff, top.x - xOff, top.y, top.x, top.y);</span>
<span class="nc" id="L879">		path.closePath();</span>

<span class="nc" id="L881">		return path;</span>
	}

	private GeneralPath makeTrapezoidPath(Diagram diagram, RenderingOptions options, boolean inverted) {
<span class="nc bnc" id="L885" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L886">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">		float offset = options.isFixedSlope() ? bounds.height / SHAPE_SLOPE : diagram.getCellWidth() * 0.5f;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">		if (inverted) offset = -offset;</span>
<span class="nc" id="L889">		ShapePoint ul = new ShapePoint((float)bounds.getMinX() + offset, (float)bounds.getMinY());</span>
<span class="nc" id="L890">		ShapePoint ur = new ShapePoint((float)bounds.getMaxX() - offset, (float)bounds.getMinY());</span>
<span class="nc" id="L891">		ShapePoint br = new ShapePoint((float)bounds.getMaxX() + offset, (float)bounds.getMaxY());</span>
<span class="nc" id="L892">		ShapePoint bl = new ShapePoint((float)bounds.getMinX() - offset, (float)bounds.getMaxY());</span>

<span class="nc" id="L894">		ShapePoint pointMid = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getMaxY());</span>

<span class="nc" id="L896">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L897">		path.moveTo(ul.x, ul.y);</span>
<span class="nc" id="L898">		path.lineTo(ur.x, ur.y);</span>
<span class="nc" id="L899">		path.lineTo(br.x, br.y);</span>
<span class="nc" id="L900">		path.lineTo(bl.x, bl.y);</span>
<span class="nc" id="L901">		path.closePath();</span>

<span class="nc" id="L903">		return path;</span>
	}

	private GeneralPath makeDecisionPath(Diagram diagram) {
<span class="nc bnc" id="L907" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L908">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L909">		ShapePoint pointMid = new ShapePoint((float)bounds.getCenterX(), (float)bounds.getCenterY());</span>
<span class="nc" id="L910">		ShapePoint left = new ShapePoint((float)bounds.getMinX(), (float)pointMid.getY());</span>
<span class="nc" id="L911">		ShapePoint right = new ShapePoint((float)bounds.getMaxX(), (float)pointMid.getY());</span>
<span class="nc" id="L912">		ShapePoint top = new ShapePoint((float)pointMid.getX(), (float)bounds.getMinY());</span>
<span class="nc" id="L913">		ShapePoint bottom = new ShapePoint((float)pointMid.getX(), (float)bounds.getMaxY());</span>

<span class="nc" id="L915">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L916">		path.moveTo(left.x, left.y);</span>
<span class="nc" id="L917">		path.lineTo(top.x, top.y);</span>
<span class="nc" id="L918">		path.lineTo(right.x, right.y);</span>
<span class="nc" id="L919">		path.lineTo(bottom.x, bottom.y);</span>

<span class="nc" id="L921">		path.closePath();</span>

<span class="nc" id="L923">		return path;</span>
	}

	private GeneralPath makeIOPath(Diagram diagram, RenderingOptions options) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">		if(points.size() != 4) return null;</span>
<span class="nc" id="L928">		Rectangle bounds = makeIntoPath().getBounds();</span>
<span class="nc" id="L929">		ShapePoint point1 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMinY());</span>
<span class="nc" id="L930">		ShapePoint point2 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMinY());</span>
<span class="nc" id="L931">		ShapePoint point3 = new ShapePoint((float)bounds.getMaxX(), (float)bounds.getMaxY());</span>
<span class="nc" id="L932">		ShapePoint point4 = new ShapePoint((float)bounds.getMinX(), (float)bounds.getMaxY());</span>
	
<span class="nc bnc" id="L934" title="All 2 branches missed.">        float offset = options.isFixedSlope() ? bounds.height / SHAPE_SLOPE : diagram.getCellWidth() * 0.5f;</span>
		
<span class="nc" id="L936">		GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L937">		path.moveTo(point1.x + offset, point1.y);</span>
<span class="nc" id="L938">		path.lineTo(point2.x + offset, point2.y);</span>
<span class="nc" id="L939">		path.lineTo(point3.x - offset, point3.y);</span>
<span class="nc" id="L940">		path.lineTo(point4.x - offset, point4.y);</span>
<span class="nc" id="L941">		path.closePath();</span>
		
<span class="nc" id="L943">		return path;</span>
	}

	public CustomShapeDefinition getDefinition() {
<span class="nc" id="L947">		return definition;</span>
	}

	public void setDefinition(CustomShapeDefinition definition) {
<span class="nc" id="L951">		this.definition = definition;</span>
<span class="nc" id="L952">	}</span>

	/**
	 * See http://mathworld.wolfram.com/PolygonArea.html
	 * 
	 * @return the overall area of the shape
	 */
	public double calculateArea() {
<span class="nc bnc" id="L960" title="All 2 branches missed.">		if(points.size() == 0) return 0;</span>
		
<span class="nc" id="L962">		double area = 0;</span>
		
<span class="nc bnc" id="L964" title="All 2 branches missed.">		for(int i = 0; i &lt; points.size() - 1; i++){</span>
<span class="nc" id="L965">			ShapePoint point1 = points.get(i);</span>
<span class="nc" id="L966">			ShapePoint point2 = points.get(i + 1);</span>
<span class="nc" id="L967">			area += point1.x * point2.y;</span>
<span class="nc" id="L968">			area -= point2.x * point1.y;</span>
		}
<span class="nc" id="L970">		ShapePoint point1 = points.get(points.size() - 1);</span>
<span class="nc" id="L971">		ShapePoint point2 = points.get(0);</span>
<span class="nc" id="L972">		area += point1.x * point2.y;</span>
<span class="nc" id="L973">		area -= point2.x * point1.y;</span>
		
<span class="nc" id="L975">		return Math.abs(area / 2);</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>