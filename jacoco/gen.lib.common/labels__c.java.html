<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>labels__c.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">gen.lib.common</a> &gt; <span class="el_source">labels__c.java</span></div><h1>labels__c.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of Smetana.
 * Smetana is a partial translation of Graphviz/Dot sources from C to Java.
 *
 * (C) Copyright 2009-2022, Arnaud Roques
 *
 * This translation is distributed under the same Licence as the original C program:
 * 
 *************************************************************************
 * Copyright (c) 2011 AT&amp;T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 * LICENSE (&quot;AGREEMENT&quot;). [Eclipse Public License - v 1.0]
 * 
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package gen.lib.common;
import static gen.lib.cgraph.edge__c.aghead;
import static gen.lib.cgraph.graph__c.agisdirected;
import static gen.lib.cgraph.id__c.agnameof;
import static gen.lib.cgraph.obj__c.agobjkind;
import static gen.lib.cgraph.obj__c.agraphof;
import static gen.lib.cgraph.obj__c.agroot;
import static gen.lib.common.htmltable__c.make_html_label;
import static gen.lib.common.utils__c.htmlEntityUTF8;
import static smetana.core.JUtils.EQ_CSTRING;
import static smetana.core.Macro.AGEDGE;
import static smetana.core.Macro.AGNODE;
import static smetana.core.Macro.AGRAPH;
import static smetana.core.Macro.ED_head_port;
import static smetana.core.Macro.ED_label;
import static smetana.core.Macro.ED_tail_port;
import static smetana.core.Macro.GD_charset;
import static smetana.core.Macro.GD_gvc;
import static smetana.core.Macro.GD_label;
import static smetana.core.Macro.LT_HTML;
import static smetana.core.Macro.LT_RECD;
import static smetana.core.Macro.M_agtail;
import static smetana.core.Macro.ND_label;
import static smetana.core.Macro.UNSUPPORTED;
import static smetana.core.Macro.hackInitDimensionFromLabel;
import static smetana.core.debug.SmetanaDebug.ENTERING;
import static smetana.core.debug.SmetanaDebug.LEAVING;

import gen.annotation.Difficult;
import gen.annotation.Doc;
import gen.annotation.Original;
import gen.annotation.Reviewed;
import gen.annotation.Unused;
import h.ST_Agedge_s;
import h.ST_Agnode_s;
import h.ST_Agobj_s;
import h.ST_Agraph_s;
import h.ST_GVC_s;
import h.ST_pointf;
import h.ST_port;
import h.ST_textlabel_t;
import h.ST_textspan_t;
import smetana.core.CArray;
import smetana.core.CString;
import smetana.core.Globals;
import smetana.core.Memory;
import smetana.core.ZType;
import smetana.core.__ptr__;
import smetana.core.debug.SmetanaDebug;

<span class="nc" id="L96">public class labels__c {</span>




@Reviewed(when = &quot;13/11/2020&quot;)
@Difficult
@Doc(&quot;Compute size of a string and store size&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/common/labels.c&quot;, name=&quot;storeline&quot;, key=&quot;4wkeqik2dt7ecr64ej6ltbnvb&quot;, definition=&quot;static void storeline(GVC_t *gvc, textlabel_t *lp, char *line, char terminator)&quot;)
public static void storeline(Globals zz, ST_GVC_s gvc, ST_textlabel_t lp, CString line, char terminator) {
<span class="fc" id="L106">ENTERING(&quot;4wkeqik2dt7ecr64ej6ltbnvb&quot;,&quot;storeline&quot;);</span>
try {
<span class="fc" id="L108">    final ST_pointf size = new ST_pointf();</span>
<span class="fc" id="L109">    ST_textspan_t span = null;</span>
<span class="fc" id="L110">    int oldsz = lp.nspans + 1;</span>
    
<span class="fc" id="L112">    lp.span = CArray.&lt;ST_textspan_t&gt;REALLOC__(oldsz + 1, lp.span, ZType.ST_textspan_t);</span>
<span class="fc" id="L113">    span = lp.span.get__(lp.nspans);</span>
<span class="fc" id="L114">    span.str = line;</span>
<span class="fc" id="L115">    span.just = terminator;</span>

	// WE CHEAT
<span class="fc" id="L118">	zz.tf.name = lp.fontname;</span>
<span class="fc" id="L119">	zz.tf.size = lp.fontsize;</span>
<span class="fc" id="L120">	size.x = 0.0;</span>
<span class="fc" id="L121">	size.y = (int)(lp.fontsize * 1.20);</span>
<span class="fc" id="L122">	hackInitDimensionFromLabel(size, line.getContent());</span>
<span class="fc" id="L123">    SmetanaDebug.LOG(&quot;storeline line.getContent()=&quot;+line.getContent()+&quot; size=&quot;+size);</span>
<span class="fc" id="L124">	span.size.y = (int)size.y;</span>

<span class="fc" id="L126">    lp.nspans++;</span>
    /* width = max line width */
<span class="fc" id="L128">    lp.dimen.x = Math.max(lp.dimen.x, size.x);</span>
    /* accumulate height */
<span class="fc" id="L130">    lp.dimen.y = lp.dimen.y + size.y;</span>
<span class="fc" id="L131">    SmetanaDebug.LOG(&quot;storeline &quot;+lp);</span>
} finally {
<span class="fc" id="L133">LEAVING(&quot;4wkeqik2dt7ecr64ej6ltbnvb&quot;,&quot;storeline&quot;);</span>
}
<span class="fc" id="L135">}</span>




@Reviewed(when = &quot;12/11/2020&quot;)
@Doc(&quot;Parse simple label&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/common/labels.c&quot;, name=&quot;make_simple_label&quot;, key=&quot;22ar72ye93a8ntj8pagnt5b5k&quot;, definition=&quot;void make_simple_label(GVC_t * gvc, textlabel_t * lp)&quot;)
public static void make_simple_label(Globals zz, ST_GVC_s gvc, ST_textlabel_t lp) {
<span class="fc" id="L144">ENTERING(&quot;22ar72ye93a8ntj8pagnt5b5k&quot;,&quot;make_simple_label&quot;);</span>
try {
    char c;
<span class="fc" id="L147">    CString p, line, lineptr, str = lp.text;</span>
<span class="fc" id="L148">    char bytee = 0x00;</span>
    
<span class="fc" id="L150">    lp.dimen.x = lp.dimen.y = 0.0;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">    if (str.charAt(0) == '\0')</span>
<span class="nc" id="L152">	return;</span>
    
<span class="fc" id="L154">    line = lineptr = null;</span>
<span class="fc" id="L155">    p = str;</span>
<span class="fc" id="L156">    line = lineptr = CString.gmalloc((p.length() + 1));</span>
<span class="fc" id="L157">    line.setCharAt(0, '\0');</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">    while ((c = p.charAt(0))!='\0') {</span>
<span class="fc" id="L159">    p = p.plus_(1);</span>
<span class="fc" id="L160">	bytee = c;</span>
	/* wingraphviz allows a combination of ascii and big-5. The latter
         * is a two-byte encoding, with the first byte in 0xA1-0xFE, and
         * the second in 0x40-0x7e or 0xa1-0xfe. We assume that the input
         * is well-formed, but check that we don't go past the ending '\0'.
         */
<span class="pc bpc" id="L166" title="5 of 6 branches missed.">	if ((lp.charset == 2) &amp;&amp; 0xA1 &lt;= bytee &amp;&amp; bytee &lt;= 0xFE) {</span>
<span class="nc" id="L167">UNSUPPORTED(&quot;6la63t1mnqv30shyyp3yfroxb&quot;); // 	    *lineptr++ = c;</span>
<span class="nc" id="L168">UNSUPPORTED(&quot;ebmmarxykvf76hmfmjuk0ssjz&quot;); // 	    c = *p++;</span>
<span class="nc" id="L169">UNSUPPORTED(&quot;6la63t1mnqv30shyyp3yfroxb&quot;); // 	    *lineptr++ = c;</span>
<span class="nc" id="L170">UNSUPPORTED(&quot;1kri3b36twfj4t7bvjbrt6dhs&quot;); // 	    if (!c) /* NB. Protect against unexpected string end here */</span>
<span class="nc" id="L171">UNSUPPORTED(&quot;9ekmvj13iaml5ndszqyxa8eq&quot;); // 		break;</span>
	} else {
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">	    if (c == '\\') {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">		switch (p.charAt(0)) {</span>
		case 'n':
		case 'l':
		case 'r':
<span class="nc" id="L178">		    lineptr.setCharAt(0, '\0');</span>
<span class="nc" id="L179">		    lineptr = lineptr.plus_(1);</span>
<span class="nc" id="L180">		    storeline(zz, gvc, lp, line, p.charAt(0));</span>
<span class="nc" id="L181">		    line = lineptr;</span>
<span class="nc" id="L182">		    break;</span>
		default:
<span class="nc" id="L184">		    lineptr.setCharAt(0, p.charAt(0));</span>
<span class="nc" id="L185">		    lineptr = lineptr.plus_(1);</span>
		}
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (p.charAt(0)!='\0')</span>
<span class="nc" id="L188">		    p = p.plus_(1);</span>
		/* tcldot can enter real linend characters */
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">	    } else if (c == '\n') {</span>
<span class="nc" id="L191">		    lineptr.setCharAt(0, '\0');</span>
<span class="nc" id="L192">		    lineptr = lineptr.plus_(1);</span>
<span class="nc" id="L193">		storeline(zz, gvc, lp, line, 'n');</span>
<span class="nc" id="L194">		line = lineptr;</span>
	    } else {
<span class="fc" id="L196">	    lineptr.setCharAt(0, c);</span>
<span class="fc" id="L197">	    lineptr = lineptr.plus_(1);</span>
	    }
	}
    }
    
    
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if (!EQ_CSTRING(line, lineptr)) {</span>
<span class="fc" id="L204">	lineptr.setCharAt(0, '\0');</span>
<span class="fc" id="L205">	lineptr = lineptr.plus_(1);</span>
<span class="fc" id="L206">	storeline(zz, gvc, lp, line, 'n');</span>
    }
    
<span class="fc" id="L209">    lp.space.___(lp.dimen);</span>
} finally {
<span class="fc" id="L211">LEAVING(&quot;22ar72ye93a8ntj8pagnt5b5k&quot;,&quot;make_simple_label&quot;);</span>
}
<span class="fc" id="L213">}</span>




@Reviewed(when = &quot;12/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/common/labels.c&quot;, name=&quot;&quot;, key=&quot;ecq5lydlrjrlaz8o6vm6svc8i&quot;, definition=&quot;textlabel_t *make_label(void *obj, char *str, int kind, double fontsize, char *fontname, char *fontcolor)&quot;)
public static ST_textlabel_t make_label(Globals zz, ST_Agobj_s obj, CString str, int kind, double fontsize, CString fontname, CString fontcolor) {
<span class="fc" id="L221">ENTERING(&quot;ecq5lydlrjrlaz8o6vm6svc8i&quot;,&quot;make_label&quot;);</span>
try {
<span class="fc" id="L223">	ST_textlabel_t rv = new ST_textlabel_t();</span>
<span class="fc" id="L224">    ST_Agraph_s g = null, sg = null;</span>
<span class="fc" id="L225">    ST_Agnode_s n = null;</span>
<span class="fc" id="L226">    ST_Agedge_s e = null;</span>
<span class="fc" id="L227">        CString s = null;</span>
        
        
<span class="pc bpc" id="L230" title="1 of 4 branches missed.">    switch (agobjkind(obj)) {</span>
    case AGRAPH:
<span class="fc" id="L232">        sg = (ST_Agraph_s)obj;</span>
<span class="fc" id="L233">	g = (ST_Agraph_s) sg.root;</span>
<span class="fc" id="L234">	break;</span>
    case AGNODE:
<span class="fc" id="L236">        n = (ST_Agnode_s)obj;</span>
<span class="fc" id="L237">	g = agroot(agraphof(n));</span>
<span class="fc" id="L238">	break;</span>
    case AGEDGE:
<span class="fc" id="L240">        e = (ST_Agedge_s)obj;</span>
<span class="fc" id="L241">	g = agroot(agraphof(aghead(e)));</span>
	break;
    }
<span class="fc" id="L244">    rv.fontname =  fontname;</span>
<span class="fc" id="L245">    rv.fontcolor = fontcolor;</span>
<span class="fc" id="L246">    rv.fontsize = fontsize;</span>
<span class="fc" id="L247">    rv.charset = GD_charset(g);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">    if ((kind &amp; LT_RECD)!=0) {</span>
<span class="fc" id="L249">	rv.text = str.strdup();</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if ((kind &amp; LT_HTML)!=0) {</span>
<span class="nc" id="L251">	    rv.html = (true);</span>
	}
    }
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">    else if (kind == LT_HTML) {</span>
<span class="nc" id="L255">	rv.text = str.strdup();</span>
<span class="nc" id="L256">	rv.html = true;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">	if (make_html_label(obj, rv)!=0) {</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">	    switch (agobjkind(obj)) {</span>
    case AGRAPH:
<span class="nc" id="L260">	        UNSUPPORTED(&quot;agerr(AGPREV, in label of graph %s\n,agnameof(sg));&quot;);</span>
<span class="nc" id="L261">		break;</span>
    case AGNODE:
<span class="nc" id="L263">	        UNSUPPORTED(&quot;agerr(AGPREV, in label of node %s\n, agnameof(n));&quot;);</span>
<span class="nc" id="L264">		break;</span>
    case AGEDGE:
<span class="nc" id="L266">		UNSUPPORTED(&quot;agerr(AGPREV, in label of edge %s %s %s\n,&quot;);</span>
//		        agnameof(((((((Agobj_t*)(e))-&gt;tag).objtype) == 3? (e): ((e)+1))-&gt;node)), agisdirected(g)?&quot;-&gt;&quot;:&quot;--&quot;, agnameof(((((((Agobj_t*)(e))-&gt;tag).objtype) == 2? (e): ((e)-1))-&gt;node)));
<span class="nc" id="L268">		break;</span>
	    }
	}
    }
    else {
        //assert(kind == (0 &lt;&lt; 1));
	/* This call just processes the graph object based escape sequences. The formatting escape
         * sequences (\n, \l, \r) are processed in make_simple_label. That call also replaces \\ with \.
         */
<span class="fc" id="L277">	rv.text = strdup_and_subst_obj0(zz, str, obj, 0);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        switch (rv.charset) {</span>
    case 1:
<span class="nc" id="L280">	    UNSUPPORTED(&quot;s = latin1ToUTF8(rv-&gt;text);&quot;);</span>
<span class="nc" id="L281">	    break;</span>
	default: /* UTF8 */
<span class="fc" id="L283">	    s = htmlEntityUTF8(rv.text, g);</span>
	    break;
	}
<span class="fc" id="L286">        Memory.free(rv.text);</span>
<span class="fc" id="L287">        rv.text = s;</span>
<span class="fc" id="L288">	make_simple_label(zz, GD_gvc(g), rv);</span>
    }
<span class="fc" id="L290">    return rv;</span>
} finally {
<span class="fc" id="L292">LEAVING(&quot;ecq5lydlrjrlaz8o6vm6svc8i&quot;,&quot;make_label&quot;);</span>
}
}




/* strdup_and_subst_obj0:
 * Replace various escape sequences with the name of the associated
 * graph object. A double backslash \\ can be used to avoid a replacement.
 * If escBackslash is true, convert \\ to \; else leave alone. All other dyads 
 * of the form \. are passed through unchanged.
 */
@Difficult
@Reviewed(when = &quot;12/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/common/labels.c&quot;, name=&quot;&quot;, key=&quot;ajohywvjbrvkc7zca2uew6ghm&quot;, definition=&quot;static char *strdup_and_subst_obj0 (char *str, void *obj, int escBackslash)&quot;)
public static CString strdup_and_subst_obj0(Globals zz, CString str, ST_Agobj_s obj, int escBackslash) {
<span class="fc" id="L309">ENTERING(&quot;ajohywvjbrvkc7zca2uew6ghm&quot;,&quot;strdup_and_subst_obj0&quot;);</span>
try {
    char c; CString s, p, t, newstr;
<span class="fc" id="L312">    CString tp_str = new CString(&quot;&quot;), hp_str = new CString(&quot;&quot;);</span>
<span class="fc" id="L313">    CString g_str = new CString(&quot;\\G&quot;), n_str = new CString(&quot;\\N&quot;), e_str = new CString(&quot;\\E&quot;),</span>
<span class="fc" id="L314">	h_str = new CString(&quot;\\H&quot;), t_str = new CString(&quot;\\T&quot;), l_str = new CString(&quot;\\L&quot;);</span>
<span class="fc" id="L315">    int g_len = 2, n_len = 2, e_len = 2,</span>
<span class="fc" id="L316">	h_len = 2, t_len = 2, l_len = 2,</span>
<span class="fc" id="L317">	tp_len = 0, hp_len = 0;</span>
<span class="fc" id="L318">    int newlen = 0;</span>
<span class="fc" id="L319">    int isEdge = 0;</span>
    ST_textlabel_t tl;
<span class="fc" id="L321">    final ST_port pt = new ST_port();</span>
    
    
    /* prepare substitution strings */
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">    switch (agobjkind(obj)) {</span>
	case AGRAPH:
<span class="fc" id="L327">	    g_str = agnameof(zz, (ST_Agraph_s)obj);</span>
<span class="fc" id="L328">	    g_len = g_str.length();</span>
<span class="fc" id="L329">	    tl = GD_label((ST_Agraph_s)obj);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">	    if (tl!=null) {</span>
<span class="nc" id="L331">		l_str = tl.text;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">	    	if (str!=null) l_len = l_str.length();</span>
	    }
	    break;
	case AGNODE:
<span class="fc" id="L336">	    g_str = agnameof(zz, agraphof(obj));</span>
<span class="fc" id="L337">	    g_len = g_str.length();</span>
<span class="fc" id="L338">	    n_str = agnameof(zz, obj);</span>
<span class="fc" id="L339">	    n_len = n_str.length();</span>
<span class="fc" id="L340">	    tl = ND_label((ST_Agnode_s)obj);</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">	    if (tl!=null) {</span>
<span class="fc" id="L342">		l_str = tl.text;</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">	    	if (str!=null) l_len = l_str.length();</span>
	    }
	    break;
	case AGEDGE:
<span class="fc" id="L347">	    isEdge = 1;</span>
<span class="fc" id="L348">	    g_str = agnameof(zz, agroot(agraphof((M_agtail((ST_Agedge_s)obj)))));</span>
<span class="fc" id="L349">	    g_len = g_str.length();</span>
<span class="fc" id="L350">	    t_str = agnameof(zz, M_agtail((ST_Agedge_s)obj));</span>
<span class="fc" id="L351">	    t_len = t_str.length();</span>
<span class="fc" id="L352">	    pt.___(ED_tail_port((ST_Agedge_s)obj));</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">	    if ((tp_str = pt.name)!=null)</span>
<span class="nc" id="L354">	        tp_len = tp_str.length();</span>
<span class="fc" id="L355">	    h_str = agnameof(zz, aghead((obj)));</span>
<span class="fc" id="L356">	    h_len = h_str.length();</span>
<span class="fc" id="L357">	    pt.___(ED_head_port((ST_Agedge_s)obj));</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">	    if ((hp_str = pt.name)!=null)</span>
<span class="nc" id="L359">		hp_len = hp_str.length();</span>
<span class="fc" id="L360">	    h_len = h_str.length();</span>
<span class="fc" id="L361">	    tl = ED_label((ST_Agedge_s)obj);</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">	    if (tl!=null) {</span>
<span class="nc" id="L363">	    	l_str = tl.text;</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">	    	if (str!=null) l_len = l_str.length();</span>
	    }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">	    if (agisdirected(agroot(agraphof(M_agtail((ST_Agedge_s)obj)))))</span>
<span class="fc" id="L367">		e_str = new CString(&quot;-&gt;&quot;);</span>
	    else
<span class="nc" id="L369">		e_str = new CString(&quot;--&quot;);</span>
<span class="pc bpc" id="L370" title="2 of 4 branches missed.">	    e_len = t_len + (tp_len!=0?tp_len+1:0) + 2 + h_len + (hp_len!=0?hp_len+1:0);</span>
	    break;
    }
    /* two passes over str.
     *
     * first pass prepares substitution strings and computes 
     * total length for newstring required from malloc.
     */
<span class="fc" id="L378">    for (s = str; ;) {</span>
<span class="fc" id="L379">    c = s.charAt(0);</span>
<span class="fc" id="L380">    s = s.plus_(1);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">    if (c=='\0') break;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">	if (c == '\\') {</span>
<span class="fc" id="L383">	  c = s.charAt(0);</span>
<span class="fc" id="L384">	  s = s.plus_(1);</span>
<span class="pc bpc" id="L385" title="7 of 8 branches missed.">	    switch (c) {</span>
	    case 'G':
<span class="nc" id="L387">		newlen += g_len;</span>
<span class="nc" id="L388">		break;</span>
	    case 'N':
<span class="fc" id="L390">		newlen += n_len;</span>
<span class="fc" id="L391">		break;</span>
	    case 'E':
<span class="nc" id="L393">		newlen += e_len;</span>
<span class="nc" id="L394">		break;</span>
	    case 'H':
<span class="nc" id="L396">		newlen += h_len;</span>
<span class="nc" id="L397">		break;</span>
	    case 'T':
<span class="nc" id="L399">		newlen += t_len;</span>
<span class="nc" id="L400">		break; </span>
	    case 'L':
<span class="nc" id="L402">		newlen += l_len;</span>
<span class="nc" id="L403">		break; </span>
	    case '\\':
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (escBackslash!=0) {</span>
<span class="nc" id="L406">		    newlen += 1;</span>
<span class="nc" id="L407">		    break; </span>
		}
		/* Fall through */
	    default:  /* leave other escape sequences unmodified, e.g. \n \l \r */
<span class="nc" id="L411">		newlen += 2;</span>
	    }
	} else {
<span class="fc" id="L414">	    newlen++;</span>
	}
    }
    /* allocate new string */
<span class="fc" id="L418">    newstr = CString.gmalloc(newlen + 1);</span>
    
    
    /* second pass over str assembles new string */
<span class="fc" id="L422">    p = newstr;</span>
<span class="fc" id="L423">    for (s = str; ;) {</span>
<span class="fc" id="L424">    c = s.charAt(0);</span>
<span class="fc" id="L425">    s = s.plus_(1);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (c=='\0') break;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">	if (c == '\\') {</span>
<span class="fc" id="L428">	  c = s.charAt(0);</span>
<span class="fc" id="L429">	  s = s.plus_(1);</span>
<span class="pc bpc" id="L430" title="7 of 8 branches missed.">	    switch (c) {</span>
	    case 'G':
<span class="nc" id="L432">		UNSUPPORTED(&quot;for (t = g_str; (*p = *t++); p++);&quot;);</span>
<span class="nc" id="L433">		break;</span>
	    case 'N':
<span class="fc" id="L435">		for (t = n_str; ; ) {</span>
<span class="fc" id="L436">		p.setCharAt(0, t.charAt(0));</span>
<span class="fc" id="L437">		t = t.plus_(1);</span>
<span class="fc bfc" id="L438" title="All 2 branches covered.">		if (p.charAt(0)=='\0') break;</span>
<span class="fc" id="L439">		p = p.plus_(1);</span>
		}
		break;
	    case 'E':
<span class="nc" id="L443">		UNSUPPORTED(&quot;if (isEdge) {&quot;);</span>
/*		    for (t = t_str; (*p = *t++); p++);
		    if (tp_len) {
			*p++ = ':';
			for (t = tp_str; (*p = *t++); p++);
		    }
		    for (t = e_str; (*p = *t++); p++);
		    for (t = h_str; (*p = *t++); p++);
		    if (hp_len) {
			*p++ = ':';
			for (t = hp_str; (*p = *t++); p++);
		    }
		}*/
<span class="nc" id="L456">		break;</span>
	    case 'T':
<span class="nc" id="L458">		UNSUPPORTED(&quot;for (t = t_str; (*p = *t++); p++);&quot;);</span>
<span class="nc" id="L459">		break;</span>
	    case 'H':
<span class="nc" id="L461">		UNSUPPORTED(&quot;for (t = h_str; (*p = *t++); p++);&quot;);</span>
<span class="nc" id="L462">		break;</span>
	    case 'L':
<span class="nc" id="L464">		UNSUPPORTED(&quot;for (t = l_str; (*p = *t++); p++);&quot;);</span>
<span class="nc" id="L465">		break;</span>
	    case '\\':
<span class="nc" id="L467">		UNSUPPORTED(&quot;if (escBackslash) {&quot;);</span>
/*		    *p++ = '\\';
		    break; 
		}*/
		/* Fall through */
	    default:  /* leave other escape sequences unmodified, e.g. \n \l \r */
<span class="nc" id="L473">	    p.setCharAt(0, '\\');</span>
<span class="nc" id="L474">	    p = p.plus_(1);</span>
<span class="nc" id="L475">	    p.setCharAt(0, c);</span>
<span class="nc" id="L476">	    p = p.plus_(1);</span>
<span class="nc" id="L477">		break;</span>
	    }
	} else {
<span class="fc" id="L480">	    p.setCharAt(0, c);</span>
<span class="fc" id="L481">	    p = p.plus_(1);</span>
	}
    }
<span class="fc" id="L484">    p.setCharAt(0, '\0');</span>
<span class="fc" id="L485">    p = p.plus_(1);</span>
<span class="fc" id="L486">    return newstr;</span>
} finally {
<span class="fc" id="L488">LEAVING(&quot;ajohywvjbrvkc7zca2uew6ghm&quot;,&quot;strdup_and_subst_obj0&quot;);</span>
}
}




//3 af2a0cdl8ld7bbq0qu0rt1d8z
// char *strdup_and_subst_obj(char *str, void *obj) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/common/labels.c&quot;, name=&quot;&quot;, key=&quot;af2a0cdl8ld7bbq0qu0rt1d8z&quot;, definition=&quot;char *strdup_and_subst_obj(char *str, void *obj)&quot;)
public static CString strdup_and_subst_obj(CString str, __ptr__ obj) {
<span class="nc" id="L500">ENTERING(&quot;af2a0cdl8ld7bbq0qu0rt1d8z&quot;,&quot;strdup_and_subst_obj&quot;);</span>
try {
<span class="nc" id="L502"> UNSUPPORTED(&quot;7eeocxzl6qhtvcv7gnh73o7d1&quot;); // char *strdup_and_subst_obj(char *str, void *obj)</span>
<span class="nc" id="L503">UNSUPPORTED(&quot;erg9i1970wdri39osu8hx2a6e&quot;); // {</span>
<span class="nc" id="L504">UNSUPPORTED(&quot;67419rdrhawe7vudn882sohkd&quot;); //     return strdup_and_subst_obj0 (str, obj, 1);</span>
<span class="nc" id="L505">UNSUPPORTED(&quot;c24nfmv9i7o5eoqaymbibp7m7&quot;); // }</span>

<span class="nc" id="L507">throw new UnsupportedOperationException();</span>
} finally {
<span class="nc" id="L509">LEAVING(&quot;af2a0cdl8ld7bbq0qu0rt1d8z&quot;,&quot;strdup_and_subst_obj&quot;);</span>
}
}



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>