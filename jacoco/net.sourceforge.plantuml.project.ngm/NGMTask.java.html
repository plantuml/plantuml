<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NGMTask.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.project.ngm</a> &gt; <span class="el_source">NGMTask.java</span></div><h1>NGMTask.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 * 
 *
 */
package net.sourceforge.plantuml.project.ngm;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * Represents an abstract scheduled task in the New Gantt Model (NGM).
 *
 * &lt;p&gt;
 * This model is built around three independent notions:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Total effort&lt;/b&gt; — an {@link NGMTotalEffort} expressing the total amount of
 *       work associated with the task, typically in person-time
 *       (for example, person-seconds or person-hours).&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;b&gt;Allocation&lt;/b&gt; — an {@link NGMAllocation} representing the effective
 *       full-time-equivalent (FTE) assigned to the task
 *       (e.g., 1 = 100%, 1/2 = 50%, 5/7 = weekdays only, 2 = two persons).&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;b&gt;Duration&lt;/b&gt; — a {@link Duration} representing the calendar span
 *       between the start and end instants.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * These three quantities must remain conceptually independent. Confusing them leads to
 * incorrect scheduling behaviour. The goal of NGM is to provide a clean and unambiguous
 * task model using {@code java.time} and explicit resource-allocation logic.
 * &lt;/p&gt;
 *
 *
 * &lt;h3&gt;Task behaviour&lt;/h3&gt;
 *
 * &lt;p&gt;
 * At the scheduling level, a task can behave in one of two ways:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;Fixed-total-effort task&lt;/b&gt;: The total effort is intrinsic and does not change.
 *       The scheduled duration is computed from the total effort and the allocation.
 *       Example: “this task requires 80 hours of work”.&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;b&gt;Fixed-duration task&lt;/b&gt;: The calendar span is intrinsic and does not change.
 *       The total effort becomes a derived quantity and depends on the allocation.
 *       Example: “crossing the Atlantic takes 7 days regardless of crew size”.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * This distinction is crucial: without it, the scheduler cannot make consistent
 * decisions about resource allocation, overlapping tasks, or long-running schedules.
 * &lt;/p&gt;
 *
 *
 * &lt;h3&gt;Why allocation is final&lt;/h3&gt;
 *
 * &lt;p&gt;
 * The allocation represents the &lt;em&gt;structural capacity&lt;/em&gt; assigned to the task.
 * It may influence start date, end date, duration, or total effort (depending on the
 * task type), but it is not modified by them.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * By contrast, the temporal attributes (&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;,
 * &lt;code&gt;duration&lt;/code&gt;) as well as the total effort (for fixed-duration tasks) may
 * vary depending on scheduling decisions, calendars, dependencies, or external constraints.
 * &lt;/p&gt;
 *
 *
 * &lt;h3&gt;Factory methods&lt;/h3&gt;
 *
 * &lt;p&gt;
 * The static factory methods
 * {@link #withFixedDuration(NGMAllocation, Duration)} and
 * {@link #withFixedTotalEffort(NGMAllocation, NGMTotalEffort)}
 * create concrete implementations representing these two behaviours.
 * &lt;/p&gt;
 */
public abstract class NGMTask {


	protected final NGMAllocation allocation;

	/**
	 * Creates a new task with a fixed workload allocation.
	 *
	 * @param workload the constant full-time-equivalent allocation applied to this
	 *                 task
	 */
<span class="fc" id="L125">	protected NGMTask(NGMAllocation allocation) {</span>
<span class="fc" id="L126">		this.allocation = allocation;</span>
<span class="fc" id="L127">	}</span>

	/**
	 * Returns the current start instant of the task.
	 *
	 * &lt;p&gt;
	 * The start and end instants are not independent values in the NGM model.
	 * They form a coherent scheduled window derived from the task type
	 * (fixed-duration vs fixed-total-effort), the allocation, and the
	 * scheduling constraints.
	 * &lt;/p&gt;
	 *
	 * @return the scheduled start instant
	 */
	public abstract LocalDateTime getStart();

	/**
	 * Sets (anchors) the start instant of the task.
	 *
	 * &lt;p&gt;
	 * This method is a scheduling input. Calling it triggers a recomputation of
	 * the task's scheduled window. As a consequence, after this call:
	 * &lt;/p&gt;
	 *
	 * &lt;ul&gt;
	 *   &lt;li&gt;{@link #getStart()} will reflect the newly anchored start, and&lt;/li&gt;
	 *   &lt;li&gt;{@link #getEnd()} will be recalculated to maintain a consistent task model.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * The exact recomputation rules depend on the concrete task type and may take into
	 * account the intrinsic duration or total effort, the constant allocation, and
	 * the scheduling calendar.
	 * &lt;/p&gt;
	 *
	 * @param start the start instant to anchor for scheduling
	 */
	public abstract void setStart(LocalDateTime start);

	/**
	 * Returns the current end instant of the task.
	 *
	 * &lt;p&gt;
	 * The start and end instants are not independent values in the NGM model.
	 * They form a coherent scheduled window derived from the task type
	 * (fixed-duration vs fixed-total-effort), the allocation, and the
	 * scheduling constraints.
	 * &lt;/p&gt;
	 *
	 * @return the scheduled end instant
	 */
	public abstract LocalDateTime getEnd();

	/**
	 * Sets (anchors) the end instant of the task.
	 *
	 * &lt;p&gt;
	 * This method is a scheduling input. Calling it triggers a recomputation of
	 * the task's scheduled window. As a consequence, after this call:
	 * &lt;/p&gt;
	 *
	 * &lt;ul&gt;
	 *   &lt;li&gt;{@link #getEnd()} will reflect the newly anchored end, and&lt;/li&gt;
	 *   &lt;li&gt;{@link #getStart()} will be recalculated to maintain a consistent task model.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * The exact recomputation rules depend on the concrete task type and may take into
	 * account the intrinsic duration or total effort, the constant allocation, and
	 * the scheduling calendar.
	 * &lt;/p&gt;
	 *
	 * @param end the end instant to anchor for scheduling
	 */
	public abstract void setEnd(LocalDateTime end);


	/**
	 * Returns the effective scheduled duration of the task.
	 *
	 * &lt;p&gt;
	 * This value is not always equal to &lt;code&gt;end - start&lt;/code&gt;. In practice, the
	 * duration depends on:
	 * &lt;/p&gt;
	 *
	 * &lt;ul&gt;
	 * &lt;li&gt;the start and end instants,&lt;/li&gt;
	 * &lt;li&gt;the working calendar (non-working days, holidays, weekends),&lt;/li&gt;
	 * &lt;li&gt;whether the task is fixed-load or fixed-duration.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * For a fixed-duration task, the duration is intrinsic and constant even if the
	 * start or end dates shift due to calendar constraints. For a fixed-load task,
	 * the duration must be computed from the intrinsic load, the assigned workload
	 * (FTE), and the working calendar.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Because of these factors, the duration may represent the scheduled &quot;active
	 * working time&quot; rather than a simple chronological difference.
	 * &lt;/p&gt;
	 *
	 * @return the computed scheduled duration of the task
	 */
	public abstract Duration getDuration();

	/**
	 * Returns the total effort associated with this task.
	 *
	 * &lt;p&gt;
	 * The term &lt;b&gt;total effort&lt;/b&gt; refers to the overall amount of work required to
	 * complete the task, independent of the calendar span. It is typically
	 * expressed in person-time (for example, person-seconds or person-hours).
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Depending on the concrete task type, this value may be:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;b&gt;intrinsic (fixed)&lt;/b&gt; — the effort is defined directly by the user and
	 * does not change when dates or allocation change (e.g., “this task requires 80
	 * hours of work”).&lt;/li&gt;
	 * &lt;li&gt;&lt;b&gt;computed (derived)&lt;/b&gt; — the effort is calculated from other defining
	 * properties such as the task’s duration, the effective allocation, and any
	 * scheduling constraints.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * In other words, this method provides a single, consistent access point to the
	 * task’s “work quantity”, whether that quantity is a primary input or a
	 * secondary result of the scheduling model.
	 * &lt;/p&gt;
	 *
	 * @return the intrinsic or computed total effort of the task
	 */
	public abstract NGMTotalEffort getTotalEffort();

	/**
	 * Returns the constant allocation applied to the task.
	 *
	 * &lt;p&gt;
	 * The &lt;b&gt;allocation&lt;/b&gt; represents the effective full-time-equivalent (FTE)
	 * assigned to the task. It describes the resource intensity available for
	 * executing the work, and therefore influences derived scheduling properties.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Examples of typical meanings:
	 * &lt;/p&gt;
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;1&lt;/code&gt; — one full-time equivalent (100%).&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;1/2&lt;/code&gt; — half-time allocation (50%).&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;2&lt;/code&gt; — two full-time equivalents (two people at 100%).&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;5/7&lt;/code&gt; — an allocation constrained to weekdays only, if your
	 * model uses such fractions to represent availability patterns.&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * This method returns the constant allocation associated with the task
	 * instance. Task types that support variable or time-sliced allocations may
	 * override or complement this behaviour with more advanced APIs as the model
	 * evolves.
	 * &lt;/p&gt;
	 *
	 * @return the constant FTE allocation applied to the task
	 */
	public NGMAllocation getAllocation() {
<span class="nc" id="L295">		return allocation;</span>
	}

	/**
	 * Creates a task whose duration is intrinsic (fixed) and does not depend on the
	 * assigned allocation.
	 *
	 * &lt;p&gt;
	 * In this type of task, the duration is the defining property: it remains
	 * constant regardless of how many resources are allocated.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * When a scheduling calendar is applied, the &lt;em&gt;start&lt;/em&gt; and/or &lt;em&gt;end&lt;/em&gt;
	 * instants may shift to satisfy availability constraints (for example,
	 * when certain days are closed or non-working). However, the overall scheduled
	 * duration represented by this task remains unchanged.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * The total effort is then derived from the allocation applied over this
	 * fixed-duration window.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Example: a ship crossing the Atlantic takes a fixed number of days; assigning
	 * more or fewer crew members does not shorten or extend the trip, it only
	 * changes the total effort performed during that period.
	 * &lt;/p&gt;
	 *
	 * @param allocation the constant full-time-equivalent allocation applied to the task
	 * @param duration   the intrinsic fixed calendar duration of the task
	 * @return a new fixed-duration task
	 */
	public static NGMTask withFixedDuration(NGMAllocation allocation, Duration duration) {
<span class="fc" id="L330">		return new NGMTaskFixedDuration(allocation, duration);</span>
	}

	/**
	 * Creates a task whose total effort is intrinsic (fixed) and does not depend on the
	 * assigned allocation.
	 *
	 * &lt;p&gt;
	 * In this type of task, the total amount of work is the defining property:
	 * regardless of the calendar duration, the task requires a fixed quantity of
	 * person-time (for example, person-seconds or person-hours).
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * The actual scheduled duration will be derived from the available allocation
	 * (FTE) and the scheduling constraints.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Example: implementing a feature requires “80 hours of work”. Allocating
	 * additional resources reduces the duration, while reducing resources increases
	 * it. The intrinsic total effort itself does not change.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method will eventually return a concrete {@code NGMTask} implementation
	 * representing this behaviour. For now, it throws
	 * {@link UnsupportedOperationException} because the model is still under
	 * construction.
	 * &lt;/p&gt;
	 *
	 * @param allocation  the constant full-time-equivalent allocation applied to the task
	 * @param totalEffort the intrinsic amount of work required for this task
	 * @return a new fixed-total-effort task (when implemented)
	 */
	public static NGMTask withFixedTotalEffort(NGMAllocation allocation, NGMTotalEffort totalEffort) {
<span class="fc" id="L366">		return new NGMTaskFixedTotalEffort(allocation, totalEffort);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>