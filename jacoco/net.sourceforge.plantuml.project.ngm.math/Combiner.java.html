<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Combiner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.project.ngm.math</a> &gt; <span class="el_source">Combiner.java</span></div><h1>Combiner.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques, Mario Ku≈°ek
 * 
 *
 */
package net.sourceforge.plantuml.project.ngm.math;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

/**
 * Utilities to combine multiple {@link PiecewiseConstant} functions.
 *
 * &lt;p&gt;
 * In the New Gantt Model context, {@link PiecewiseConstant} typically represents
 * a time-dependent workload allocation expressed as a {@link Fraction}.
 * &lt;/p&gt;
 */
<span class="nc" id="L55">public class Combiner {</span>
	/**
	 * Combines several workload functions by summing their values.
	 *
	 * &lt;p&gt;
	 * This operation is meant to model multiple resources assigned to the same task.
	 * For example, if two people are each allocated at 1/2 on a given day, the
	 * resulting combined workload for that day is 1 (i.e., one full-time equivalent).
	 * &lt;/p&gt;
	 *
	 * @param functions the workload functions to add
	 * @return a new {@link PiecewiseConstant} representing the summed allocation
	 */
	public static PiecewiseConstant sum(PiecewiseConstant... functions) {
<span class="nc" id="L69">		throw new UnsupportedOperationException(&quot;Work in progress&quot;);</span>
	}

	/**
	 * Combines several functions by multiplying their values.
	 *
	 * &lt;p&gt;
	 * This operation is particularly useful to combine an &quot;assignment&quot; with
	 * an &quot;availability calendar&quot;.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Availability calendars typically use only {@code 0} and {@code 1} to indicate
	 * closed/open periods. Multiplying a workload allocation by such a calendar
	 * acts as a logical AND:
	 * &lt;/p&gt;
	 *
	 * &lt;ul&gt;
	 *   &lt;li&gt;{@code 1 * allocation = allocation} (open period)&lt;/li&gt;
	 *   &lt;li&gt;{@code 0 * allocation = 0} (closed period)&lt;/li&gt;
	 * &lt;/ul&gt;
	 *
	 * &lt;p&gt;
	 * This allows you to automatically &quot;mask&quot; allocations during non-working times.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * It also allows combining calendars with each other. When multiple
	 * availability calendars are multiplied, the result represents the
	 * intersection of their opening periods: the combined calendar is open
	 * only when all input calendars are open.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * For example, you may have one calendar for weekday business days,
	 * another for public holidays, and another for daily working hours.
	 * Multiplying them yields a single calendar that is open only when all
	 * these constraints are simultaneously satisfied.
	 * &lt;/p&gt;
	 *
	 * @param functions the functions to multiply
	 * @return a new {@link PiecewiseConstant} representing the combined result
	 */
	public static PiecewiseConstant product(PiecewiseConstant... functions) {
<span class="fc" id="L113">		return CombinedPiecewiseConstant.of(Fraction.PRODUCT)</span>
<span class="fc" id="L114">				.with(functions);</span>
	}
	
	
	/**
	 * A {@link PiecewiseConstant} that combines multiple functions using a specified
	 * operation.
	 *
	 * &lt;p&gt;
	 * This class allows flexible combination of workload functions by applying
	 * a user-defined operation (e.g., sum, product) to their values at each instant.
	 * &lt;/p&gt;
	 */
	public static class CombinedPiecewiseConstant extends AbstractPiecewiseConstant {
		
		/** The functions to combine. */
		private final List&lt;PiecewiseConstant&gt; functions;
		
		/** The operation used to combine function values. */
		private final BiFunction&lt;Fraction, Fraction, Fraction&gt; valueCombiner;
		
		/** 
		 * Constructs a CombinedPiecewiseConstant with the specified functions and combiner.
		 * 
		 * @param functions the functions to combine
		 * @param valueCombiner the operation to combine function values
		 */
<span class="fc" id="L141">		private CombinedPiecewiseConstant(List&lt;PiecewiseConstant&gt; functions, BiFunction&lt;Fraction, Fraction, Fraction&gt; valueCombiner) {</span>
<span class="fc" id="L142">			Objects.requireNonNull(functions, &quot;functions must not be null&quot;);</span>
<span class="fc" id="L143">			Objects.requireNonNull(valueCombiner, &quot;valueCombiner must not be null&quot;);</span>
			
<span class="fc" id="L145">			this.functions = functions;</span>
<span class="fc" id="L146">			this.valueCombiner = valueCombiner;</span>
<span class="fc" id="L147">		}</span>
		
		/** 
		 * Constructs an empty CombinedPiecewiseConstant with the specified combiner.
		 * 
		 * @param valueCombiner the operation to combine function values
		 */
<span class="fc" id="L154">		private CombinedPiecewiseConstant(BiFunction&lt;Fraction, Fraction, Fraction&gt; valueCombiner) {</span>
<span class="fc" id="L155">			this.valueCombiner = valueCombiner;</span>
<span class="fc" id="L156">			this.functions = Collections.emptyList();</span>
<span class="fc" id="L157">		}</span>

		
		/**
		 * Retrieves the segment at the specified instant by combining segments
		 * from all constituent functions.
		 * 
		 * @param instant the time instant to query
		 * @return the combined segment at this instant
		 * @throws IllegalStateException if less than two functions are present
		 */
		@Override
		public Segment segmentAt(LocalDateTime instant, TimeDirection direction) {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">			if(functions.size() &lt; 2) {</span>
<span class="nc" id="L171">				throw new IllegalStateException(&quot;At least two functions are required for combination&quot;);</span>
			}
			
<span class="fc" id="L174">			List&lt;Segment&gt; segments = functions.stream()</span>
<span class="fc" id="L175">					.map(f -&gt; f.segmentAt(instant, direction))</span>
<span class="fc" id="L176">					 .collect(Collectors.toList());</span>
			
<span class="fc" id="L178">			return Segment.intersection(segments, valueCombiner);</span>
		}
		
		/**
		 * Creates a new CombinedPiecewiseConstant with the specified value combiner but without any functions.
		 * 
		 * @param valueCombiner the operation to combine function values
		 * @return a new CombinedPiecewiseConstant instance
		 */
		public static CombinedPiecewiseConstant of(BiFunction&lt;Fraction, Fraction, Fraction&gt; valueCombiner) {
<span class="fc" id="L188">			return new CombinedPiecewiseConstant(valueCombiner);</span>
		}
		
		/**
		 * Returns a new CombinedPiecewiseConstant that includes the specified functions.
		 * 
		 * @param functions the functions to add
		 * @return a new CombinedPiecewiseConstant with the added functions
		 */
		public CombinedPiecewiseConstant with(List&lt;PiecewiseConstant&gt; functions) {
<span class="fc" id="L198">			List&lt;PiecewiseConstant&gt; newFunctions = new ArrayList&lt;&gt;(this.functions);</span>
<span class="fc" id="L199">			newFunctions.addAll(functions);</span>
<span class="fc" id="L200">			return new CombinedPiecewiseConstant(newFunctions, valueCombiner);</span>
		}
		
		/**
		 * Returns a new CombinedPiecewiseConstant that includes the specified functions.
		 * 
		 * @param functions the functions to add
		 * @return a new CombinedPiecewiseConstant with the added functions
		 */
		public CombinedPiecewiseConstant with(PiecewiseConstant... functions) {
<span class="fc" id="L210">			return with(Arrays.asList(functions));</span>
		}
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>