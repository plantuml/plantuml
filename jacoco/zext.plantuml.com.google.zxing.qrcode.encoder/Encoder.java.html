<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Encoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">zext.plantuml.com.google.zxing.qrcode.encoder</a> &gt; <span class="el_source">Encoder.java</span></div><h1>Encoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package zext.plantuml.com.google.zxing.qrcode.encoder;

import java.io.UnsupportedEncodingException;
import java.util.Hashtable;
import java.util.Vector;

import zext.plantuml.com.google.zxing.EncodeHintType;
import zext.plantuml.com.google.zxing.WriterException;
import zext.plantuml.com.google.zxing.common.BitArray;
import zext.plantuml.com.google.zxing.common.CharacterSetECI;
import zext.plantuml.com.google.zxing.common.ECI;
import zext.plantuml.com.google.zxing.common.reedsolomon.GF256;
import zext.plantuml.com.google.zxing.common.reedsolomon.ReedSolomonEncoder;
import zext.plantuml.com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import zext.plantuml.com.google.zxing.qrcode.decoder.Mode;
import zext.plantuml.com.google.zxing.qrcode.decoder.Version;

/**
 * @author satorux@google.com (Satoru Takabayashi) - creator
 * @author dswitkin@google.com (Daniel Switkin) - ported from C++
 */
public final class Encoder {

  // The original table is defined in the table 5 of JISX0510:2004 (p.19).
<span class="fc" id="L41">  private static final int[] ALPHANUMERIC_TABLE = {</span>
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 0x00-0x0f
      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 0x10-0x1f
      36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,  // 0x20-0x2f
      0,   1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,  // 0x30-0x3f
      -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,  // 0x40-0x4f
      25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,  // 0x50-0x5f
  };

  static final String DEFAULT_BYTE_MODE_ENCODING = &quot;ISO-8859-1&quot;;

  private Encoder() {
  }

  // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
  // Basically it applies four rules and summate all penalties.
  private static int calculateMaskPenalty(ByteMatrix matrix) {
<span class="fc" id="L58">    int penalty = 0;</span>
<span class="fc" id="L59">    penalty += MaskUtil.applyMaskPenaltyRule1(matrix);</span>
<span class="fc" id="L60">    penalty += MaskUtil.applyMaskPenaltyRule2(matrix);</span>
<span class="fc" id="L61">    penalty += MaskUtil.applyMaskPenaltyRule3(matrix);</span>
<span class="fc" id="L62">    penalty += MaskUtil.applyMaskPenaltyRule4(matrix);</span>
<span class="fc" id="L63">    return penalty;</span>
  }

  /**
   *  Encode &quot;bytes&quot; with the error correction level &quot;ecLevel&quot;. The encoding mode will be chosen
   * internally by chooseMode(). On success, store the result in &quot;qrCode&quot;.
   *
   * We recommend you to use QRCode.EC_LEVEL_L (the lowest level) for
   * &quot;getECLevel&quot; since our primary use is to show QR code on desktop screens. We don't need very
   * strong error correction for this purpose.
   *
   * Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()
   * with which clients can specify the encoding mode. For now, we don't need the functionality.
   */
  public static void encode(String content, ErrorCorrectionLevel ecLevel, QRCode qrCode)
      throws WriterException {
<span class="nc" id="L79">    encode(content, ecLevel, null, qrCode);</span>
<span class="nc" id="L80">  }</span>

  public static void encode(String content, ErrorCorrectionLevel ecLevel, Hashtable hints,
      QRCode qrCode) throws WriterException {

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">    String encoding = hints == null ? null : (String) hints.get(EncodeHintType.CHARACTER_SET);</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">    if (encoding == null) {</span>
<span class="nc" id="L87">      encoding = DEFAULT_BYTE_MODE_ENCODING;</span>
    }

    // Step 1: Choose the mode (encoding).
<span class="fc" id="L91">    Mode mode = chooseMode(content, encoding);</span>

    // Step 2: Append &quot;bytes&quot; into &quot;dataBits&quot; in appropriate encoding.
<span class="fc" id="L94">    BitArray dataBits = new BitArray();</span>
<span class="fc" id="L95">    appendBytes(content, mode, dataBits, encoding);</span>
    // Step 3: Initialize QR code that can contain &quot;dataBits&quot;.
<span class="fc" id="L97">    int numInputBytes = dataBits.getSizeInBytes();</span>
<span class="fc" id="L98">    initQRCode(numInputBytes, ecLevel, mode, qrCode);</span>

    // Step 4: Build another bit vector that contains header and data.
<span class="fc" id="L101">    BitArray headerAndDataBits = new BitArray();</span>

    // Step 4.5: Append ECI message if applicable
<span class="pc bpc" id="L104" title="2 of 4 branches missed.">    if (mode == Mode.BYTE &amp;&amp; !DEFAULT_BYTE_MODE_ENCODING.equals(encoding)) {</span>
<span class="fc" id="L105">      CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">      if (eci != null) {</span>
<span class="nc" id="L107">        appendECI(eci, headerAndDataBits);</span>
      }
    }

<span class="fc" id="L111">    appendModeInfo(mode, headerAndDataBits);</span>

<span class="pc bpc" id="L113" title="1 of 2 branches missed.">    int numLetters = mode.equals(Mode.BYTE) ? dataBits.getSizeInBytes() : content.length();</span>
<span class="fc" id="L114">    appendLengthInfo(numLetters, qrCode.getVersion(), mode, headerAndDataBits);</span>
<span class="fc" id="L115">    headerAndDataBits.appendBitArray(dataBits);</span>

    // Step 5: Terminate the bits properly.
<span class="fc" id="L118">    terminateBits(qrCode.getNumDataBytes(), headerAndDataBits);</span>

    // Step 6: Interleave data bits with error correction code.
<span class="fc" id="L121">    BitArray finalBits = new BitArray();</span>
<span class="fc" id="L122">    interleaveWithECBytes(headerAndDataBits, qrCode.getNumTotalBytes(), qrCode.getNumDataBytes(),</span>
<span class="fc" id="L123">        qrCode.getNumRSBlocks(), finalBits);</span>

    // Step 7: Choose the mask pattern and set to &quot;qrCode&quot;.
<span class="fc" id="L126">    ByteMatrix matrix = new ByteMatrix(qrCode.getMatrixWidth(), qrCode.getMatrixWidth());</span>
<span class="fc" id="L127">    qrCode.setMaskPattern(chooseMaskPattern(finalBits, qrCode.getECLevel(), qrCode.getVersion(),</span>
        matrix));

    // Step 8.  Build the matrix and set it to &quot;qrCode&quot;.
<span class="fc" id="L131">    MatrixUtil.buildMatrix(finalBits, qrCode.getECLevel(), qrCode.getVersion(),</span>
<span class="fc" id="L132">        qrCode.getMaskPattern(), matrix);</span>
<span class="fc" id="L133">    qrCode.setMatrix(matrix);</span>
    // Step 9.  Make sure we have a valid QR Code.
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    if (!qrCode.isValid()) {</span>
<span class="nc" id="L136">      throw new WriterException(&quot;Invalid QR code: &quot; + qrCode.toString());</span>
    }
<span class="fc" id="L138">  }</span>

  /**
   * @return the code point of the table used in alphanumeric mode or
   *  -1 if there is no corresponding code in the table.
   */
  static int getAlphanumericCode(int code) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">    if (code &lt; ALPHANUMERIC_TABLE.length) {</span>
<span class="nc" id="L146">      return ALPHANUMERIC_TABLE[code];</span>
    }
<span class="fc" id="L148">    return -1;</span>
  }

  public static Mode chooseMode(String content) {
<span class="nc" id="L152">    return chooseMode(content, null);</span>
  }

  /**
   * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
   * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
   */
  public static Mode chooseMode(String content, String encoding) {
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (&quot;Shift_JIS&quot;.equals(encoding)) {</span>
      // Choose Kanji mode if all input are double-byte characters
<span class="nc bnc" id="L162" title="All 2 branches missed.">      return isOnlyDoubleByteKanji(content) ? Mode.KANJI : Mode.BYTE;</span>
    }
<span class="fc" id="L164">    boolean hasNumeric = false;</span>
<span class="fc" id="L165">    boolean hasAlphanumeric = false;</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">    for (int i = 0; i &lt; content.length(); ++i) {</span>
<span class="fc" id="L167">      char c = content.charAt(i);</span>
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">      if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="nc" id="L169">        hasNumeric = true;</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      } else if (getAlphanumericCode(c) != -1) {</span>
<span class="nc" id="L171">        hasAlphanumeric = true;</span>
      } else {
<span class="fc" id="L173">        return Mode.BYTE;</span>
      }
    }
<span class="nc bnc" id="L176" title="All 2 branches missed.">    if (hasAlphanumeric) {</span>
<span class="nc" id="L177">      return Mode.ALPHANUMERIC;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    } else if (hasNumeric) {</span>
<span class="nc" id="L179">      return Mode.NUMERIC;</span>
    }
<span class="nc" id="L181">    return Mode.BYTE;</span>
  }

  private static boolean isOnlyDoubleByteKanji(String content) {
    byte[] bytes;
    try {
<span class="nc" id="L187">      bytes = content.getBytes(&quot;Shift_JIS&quot;);</span>
<span class="nc" id="L188">    } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L189">      return false;</span>
<span class="nc" id="L190">    }</span>
<span class="nc" id="L191">    int length = bytes.length;</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    if (length % 2 != 0) {</span>
<span class="nc" id="L193">      return false;</span>
    }
<span class="nc bnc" id="L195" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i += 2) {</span>
<span class="nc" id="L196">      int byte1 = bytes[i] &amp; 0xFF;</span>
<span class="nc bnc" id="L197" title="All 8 branches missed.">      if ((byte1 &lt; 0x81 || byte1 &gt; 0x9F) &amp;&amp; (byte1 &lt; 0xE0 || byte1 &gt; 0xEB)) {</span>
<span class="nc" id="L198">        return false;</span>
      }
    }
<span class="nc" id="L201">    return true;</span>
  }

  private static int chooseMaskPattern(BitArray bits, ErrorCorrectionLevel ecLevel, int version,
      ByteMatrix matrix) throws WriterException {

<span class="fc" id="L207">    int minPenalty = Integer.MAX_VALUE;  // Lower penalty is better.</span>
<span class="fc" id="L208">    int bestMaskPattern = -1;</span>
    // We try all mask patterns to choose the best one.
<span class="fc bfc" id="L210" title="All 2 branches covered.">    for (int maskPattern = 0; maskPattern &lt; QRCode.NUM_MASK_PATTERNS; maskPattern++) {</span>
<span class="fc" id="L211">      MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);</span>
<span class="fc" id="L212">      int penalty = calculateMaskPenalty(matrix);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">      if (penalty &lt; minPenalty) {</span>
<span class="fc" id="L214">        minPenalty = penalty;</span>
<span class="fc" id="L215">        bestMaskPattern = maskPattern;</span>
      }
    }
<span class="fc" id="L218">    return bestMaskPattern;</span>
  }

  /**
   * Initialize &quot;qrCode&quot; according to &quot;numInputBytes&quot;, &quot;ecLevel&quot;, and &quot;mode&quot;. On success,
   * modify &quot;qrCode&quot;.
   */
  private static void initQRCode(int numInputBytes, ErrorCorrectionLevel ecLevel, Mode mode,
      QRCode qrCode) throws WriterException {
<span class="fc" id="L227">    qrCode.setECLevel(ecLevel);</span>
<span class="fc" id="L228">    qrCode.setMode(mode);</span>

    // In the following comments, we use numbers of Version 7-H.
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">    for (int versionNum = 1; versionNum &lt;= 40; versionNum++) {</span>
<span class="fc" id="L232">      Version version = Version.getVersionForNumber(versionNum);</span>
      // numBytes = 196
<span class="fc" id="L234">      int numBytes = version.getTotalCodewords();</span>
      // getNumECBytes = 130
<span class="fc" id="L236">      Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);</span>
<span class="fc" id="L237">      int numEcBytes = ecBlocks.getTotalECCodewords();</span>
      // getNumRSBlocks = 5
<span class="fc" id="L239">      int numRSBlocks = ecBlocks.getNumBlocks();</span>
      // getNumDataBytes = 196 - 130 = 66
<span class="fc" id="L241">      int numDataBytes = numBytes - numEcBytes;</span>
      // We want to choose the smallest version which can contain data of &quot;numInputBytes&quot; + some
      // extra bits for the header (mode info and length info). The header can be three bytes
      // (precisely 4 + 16 bits) at most. Hence we do +3 here.
<span class="fc bfc" id="L245" title="All 2 branches covered.">      if (numDataBytes &gt;= numInputBytes + 3) {</span>
        // Yay, we found the proper rs block info!
<span class="fc" id="L247">        qrCode.setVersion(versionNum);</span>
<span class="fc" id="L248">        qrCode.setNumTotalBytes(numBytes);</span>
<span class="fc" id="L249">        qrCode.setNumDataBytes(numDataBytes);</span>
<span class="fc" id="L250">        qrCode.setNumRSBlocks(numRSBlocks);</span>
        // getNumECBytes = 196 - 66 = 130
<span class="fc" id="L252">        qrCode.setNumECBytes(numEcBytes);</span>
        // matrix width = 21 + 6 * 4 = 45
<span class="fc" id="L254">        qrCode.setMatrixWidth(version.getDimensionForVersion());</span>
<span class="fc" id="L255">        return;</span>
      }
    }
<span class="nc" id="L258">    throw new WriterException(&quot;Cannot find proper rs block info (input data too big?)&quot;);</span>
  }

  /**
   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
   */
  static void terminateBits(int numDataBytes, BitArray bits) throws WriterException {
<span class="fc" id="L265">    int capacity = numDataBytes &lt;&lt; 3;</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">    if (bits.getSize() &gt; capacity) {</span>
<span class="nc" id="L267">      throw new WriterException(&quot;data bits cannot fit in the QR Code&quot; + bits.getSize() + &quot; &gt; &quot; +</span>
          capacity);
    }
<span class="pc bpc" id="L270" title="1 of 4 branches missed.">    for (int i = 0; i &lt; 4 &amp;&amp; bits.getSize() &lt; capacity; ++i) {</span>
<span class="fc" id="L271">      bits.appendBit(false);</span>
    }
    // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.
    // If the last byte isn't 8-bit aligned, we'll add padding bits.
<span class="fc" id="L275">    int numBitsInLastByte = bits.getSize() &amp; 0x07;    </span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    if (numBitsInLastByte &gt; 0) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">      for (int i = numBitsInLastByte; i &lt; 8; i++) {</span>
<span class="nc" id="L278">        bits.appendBit(false);</span>
      }
    }
    // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).
<span class="fc" id="L282">    int numPaddingBytes = numDataBytes - bits.getSizeInBytes();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">    for (int i = 0; i &lt; numPaddingBytes; ++i) {</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">      bits.appendBits(((i &amp; 0x01) == 0) ? 0xEC : 0x11, 8);</span>
    }
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">    if (bits.getSize() != capacity) {</span>
<span class="nc" id="L287">      throw new WriterException(&quot;Bits size does not equal capacity&quot;);</span>
    }
<span class="fc" id="L289">  }</span>

  /**
   * Get number of data bytes and number of error correction bytes for block id &quot;blockID&quot;. Store
   * the result in &quot;numDataBytesInBlock&quot;, and &quot;numECBytesInBlock&quot;. See table 12 in 8.5.1 of
   * JISX0510:2004 (p.30)
   */
  static void getNumDataBytesAndNumECBytesForBlockID(int numTotalBytes, int numDataBytes,
      int numRSBlocks, int blockID, int[] numDataBytesInBlock,
      int[] numECBytesInBlock) throws WriterException {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">    if (blockID &gt;= numRSBlocks) {</span>
<span class="nc" id="L300">      throw new WriterException(&quot;Block ID too large&quot;);</span>
    }
    // numRsBlocksInGroup2 = 196 % 5 = 1
<span class="fc" id="L303">    int numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;</span>
    // numRsBlocksInGroup1 = 5 - 1 = 4
<span class="fc" id="L305">    int numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;</span>
    // numTotalBytesInGroup1 = 196 / 5 = 39
<span class="fc" id="L307">    int numTotalBytesInGroup1 = numTotalBytes / numRSBlocks;</span>
    // numTotalBytesInGroup2 = 39 + 1 = 40
<span class="fc" id="L309">    int numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;</span>
    // numDataBytesInGroup1 = 66 / 5 = 13
<span class="fc" id="L311">    int numDataBytesInGroup1 = numDataBytes / numRSBlocks;</span>
    // numDataBytesInGroup2 = 13 + 1 = 14
<span class="fc" id="L313">    int numDataBytesInGroup2 = numDataBytesInGroup1 + 1;</span>
    // numEcBytesInGroup1 = 39 - 13 = 26
<span class="fc" id="L315">    int numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;</span>
    // numEcBytesInGroup2 = 40 - 14 = 26
<span class="fc" id="L317">    int numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;</span>
    // Sanity checks.
    // 26 = 26
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (numEcBytesInGroup1 != numEcBytesInGroup2) {</span>
<span class="nc" id="L321">      throw new WriterException(&quot;EC bytes mismatch&quot;);</span>
    }
    // 5 = 4 + 1.
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2) {</span>
<span class="nc" id="L325">      throw new WriterException(&quot;RS blocks mismatch&quot;);</span>
    }
    // 196 = (13 + 26) * 4 + (14 + 26) * 1
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">    if (numTotalBytes !=</span>
        ((numDataBytesInGroup1 + numEcBytesInGroup1) *
            numRsBlocksInGroup1) +
            ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                numRsBlocksInGroup2)) {
<span class="nc" id="L333">      throw new WriterException(&quot;Total bytes mismatch&quot;);</span>
    }

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">    if (blockID &lt; numRsBlocksInGroup1) {</span>
<span class="fc" id="L337">      numDataBytesInBlock[0] = numDataBytesInGroup1;</span>
<span class="fc" id="L338">      numECBytesInBlock[0] = numEcBytesInGroup1;</span>
    } else {
<span class="nc" id="L340">      numDataBytesInBlock[0] = numDataBytesInGroup2;</span>
<span class="nc" id="L341">      numECBytesInBlock[0] = numEcBytesInGroup2;</span>
    }
<span class="fc" id="L343">  }</span>

  /**
   * Interleave &quot;bits&quot; with corresponding error correction bytes. On success, store the result in
   * &quot;result&quot;. The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
   */
  static void interleaveWithECBytes(BitArray bits, int numTotalBytes,
      int numDataBytes, int numRSBlocks, BitArray result) throws WriterException {

    // &quot;bits&quot; must have &quot;getNumDataBytes&quot; bytes of data.
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">    if (bits.getSizeInBytes() != numDataBytes) {</span>
<span class="nc" id="L354">      throw new WriterException(&quot;Number of bits and data bytes does not match&quot;);</span>
    }

    // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll
    // store the divided data bytes blocks and error correction bytes blocks into &quot;blocks&quot;.
<span class="fc" id="L359">    int dataBytesOffset = 0;</span>
<span class="fc" id="L360">    int maxNumDataBytes = 0;</span>
<span class="fc" id="L361">    int maxNumEcBytes = 0;</span>

    // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.
<span class="fc" id="L364">    Vector blocks = new Vector(numRSBlocks);</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">    for (int i = 0; i &lt; numRSBlocks; ++i) {</span>
<span class="fc" id="L367">      int[] numDataBytesInBlock = new int[1];</span>
<span class="fc" id="L368">      int[] numEcBytesInBlock = new int[1];</span>
<span class="fc" id="L369">      getNumDataBytesAndNumECBytesForBlockID(</span>
          numTotalBytes, numDataBytes, numRSBlocks, i,
          numDataBytesInBlock, numEcBytesInBlock);

<span class="fc" id="L373">      int size = numDataBytesInBlock[0];</span>
<span class="fc" id="L374">      byte[] dataBytes = new byte[size];</span>
<span class="fc" id="L375">      bits.toBytes(8*dataBytesOffset, dataBytes, 0, size);</span>
<span class="fc" id="L376">      byte[] ecBytes = generateECBytes(dataBytes, numEcBytesInBlock[0]);</span>
<span class="fc" id="L377">      blocks.addElement(new BlockPair(dataBytes, ecBytes));</span>

<span class="fc" id="L379">      maxNumDataBytes = Math.max(maxNumDataBytes, size);</span>
<span class="fc" id="L380">      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);</span>
<span class="fc" id="L381">      dataBytesOffset += numDataBytesInBlock[0];</span>
    }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">    if (numDataBytes != dataBytesOffset) {</span>
<span class="nc" id="L384">      throw new WriterException(&quot;Data bytes does not match offset&quot;);</span>
    }

    // First, place data blocks.
<span class="fc bfc" id="L388" title="All 2 branches covered.">    for (int i = 0; i &lt; maxNumDataBytes; ++i) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">      for (int j = 0; j &lt; blocks.size(); ++j) {</span>
<span class="fc" id="L390">        byte[] dataBytes = ((BlockPair) blocks.elementAt(j)).getDataBytes();</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (i &lt; dataBytes.length) {</span>
<span class="fc" id="L392">          result.appendBits(dataBytes[i], 8);</span>
        }
      }
    }
    // Then, place error correction blocks.
<span class="fc bfc" id="L397" title="All 2 branches covered.">    for (int i = 0; i &lt; maxNumEcBytes; ++i) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">      for (int j = 0; j &lt; blocks.size(); ++j) {</span>
<span class="fc" id="L399">        byte[] ecBytes = ((BlockPair) blocks.elementAt(j)).getErrorCorrectionBytes();</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (i &lt; ecBytes.length) {</span>
<span class="fc" id="L401">          result.appendBits(ecBytes[i], 8);</span>
        }
      }
    }
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">    if (numTotalBytes != result.getSizeInBytes()) {  // Should be same.</span>
<span class="nc" id="L406">      throw new WriterException(&quot;Interleaving error: &quot; + numTotalBytes + &quot; and &quot; +</span>
<span class="nc" id="L407">          result.getSizeInBytes() + &quot; differ.&quot;);</span>
    }
<span class="fc" id="L409">  }</span>

  static byte[] generateECBytes(byte[] dataBytes, int numEcBytesInBlock) {
<span class="fc" id="L412">    int numDataBytes = dataBytes.length;</span>
<span class="fc" id="L413">    int[] toEncode = new int[numDataBytes + numEcBytesInBlock];</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">    for (int i = 0; i &lt; numDataBytes; i++) {</span>
<span class="fc" id="L415">      toEncode[i] = dataBytes[i] &amp; 0xFF;</span>
    }
<span class="fc" id="L417">    new ReedSolomonEncoder(GF256.QR_CODE_FIELD).encode(toEncode, numEcBytesInBlock);</span>

<span class="fc" id="L419">    byte[] ecBytes = new byte[numEcBytesInBlock];</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">    for (int i = 0; i &lt; numEcBytesInBlock; i++) {</span>
<span class="fc" id="L421">      ecBytes[i] = (byte) toEncode[numDataBytes + i];</span>
    }
<span class="fc" id="L423">    return ecBytes;</span>
  }

  /**
   * Append mode info. On success, store the result in &quot;bits&quot;.
   */
  static void appendModeInfo(Mode mode, BitArray bits) {
<span class="fc" id="L430">    bits.appendBits(mode.getBits(), 4);</span>
<span class="fc" id="L431">  }</span>


  /**
   * Append length info. On success, store the result in &quot;bits&quot;.
   */
  static void appendLengthInfo(int numLetters, int version, Mode mode, BitArray bits)
      throws WriterException {
<span class="fc" id="L439">    int numBits = mode.getCharacterCountBits(Version.getVersionForNumber(version));</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">    if (numLetters &gt; ((1 &lt;&lt; numBits) - 1)) {</span>
<span class="nc" id="L441">      throw new WriterException(numLetters + &quot;is bigger than&quot; + ((1 &lt;&lt; numBits) - 1));</span>
    }
<span class="fc" id="L443">    bits.appendBits(numLetters, numBits);</span>
<span class="fc" id="L444">  }</span>

  /**
   * Append &quot;bytes&quot; in &quot;mode&quot; mode (encoding) into &quot;bits&quot;. On success, store the result in &quot;bits&quot;.
   */
  static void appendBytes(String content, Mode mode, BitArray bits, String encoding)
      throws WriterException {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">    if (mode.equals(Mode.NUMERIC)) {</span>
<span class="nc" id="L452">      appendNumericBytes(content, bits);</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">    } else if (mode.equals(Mode.ALPHANUMERIC)) {</span>
<span class="nc" id="L454">      appendAlphanumericBytes(content, bits);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    } else if (mode.equals(Mode.BYTE)) {</span>
<span class="fc" id="L456">      append8BitBytes(content, bits, encoding);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">    } else if (mode.equals(Mode.KANJI)) {</span>
<span class="nc" id="L458">      appendKanjiBytes(content, bits);</span>
    } else {
<span class="nc" id="L460">      throw new WriterException(&quot;Invalid mode: &quot; + mode);</span>
    }
<span class="fc" id="L462">  }</span>

  static void appendNumericBytes(String content, BitArray bits) {
<span class="nc" id="L465">    int length = content.length();</span>
<span class="nc" id="L466">    int i = 0;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L468">      int num1 = content.charAt(i) - '0';</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if (i + 2 &lt; length) {</span>
        // Encode three numeric letters in ten bits.
<span class="nc" id="L471">        int num2 = content.charAt(i + 1) - '0';</span>
<span class="nc" id="L472">        int num3 = content.charAt(i + 2) - '0';</span>
<span class="nc" id="L473">        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);</span>
<span class="nc" id="L474">        i += 3;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">      } else if (i + 1 &lt; length) {</span>
        // Encode two numeric letters in seven bits.
<span class="nc" id="L477">        int num2 = content.charAt(i + 1) - '0';</span>
<span class="nc" id="L478">        bits.appendBits(num1 * 10 + num2, 7);</span>
<span class="nc" id="L479">        i += 2;</span>
<span class="nc" id="L480">      } else {</span>
        // Encode one numeric letter in four bits.
<span class="nc" id="L482">        bits.appendBits(num1, 4);</span>
<span class="nc" id="L483">        i++;</span>
      }
<span class="nc" id="L485">    }</span>
<span class="nc" id="L486">  }</span>

  static void appendAlphanumericBytes(String content, BitArray bits) throws WriterException {
<span class="nc" id="L489">    int length = content.length();</span>
<span class="nc" id="L490">    int i = 0;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">    while (i &lt; length) {</span>
<span class="nc" id="L492">      int code1 = getAlphanumericCode(content.charAt(i));</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">      if (code1 == -1) {</span>
<span class="nc" id="L494">        throw new WriterException();</span>
      }
<span class="nc bnc" id="L496" title="All 2 branches missed.">      if (i + 1 &lt; length) {</span>
<span class="nc" id="L497">        int code2 = getAlphanumericCode(content.charAt(i + 1));</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (code2 == -1) {</span>
<span class="nc" id="L499">          throw new WriterException();</span>
        }
        // Encode two alphanumeric letters in 11 bits.
<span class="nc" id="L502">        bits.appendBits(code1 * 45 + code2, 11);</span>
<span class="nc" id="L503">        i += 2;</span>
<span class="nc" id="L504">      } else {</span>
        // Encode one alphanumeric letter in six bits.
<span class="nc" id="L506">        bits.appendBits(code1, 6);</span>
<span class="nc" id="L507">        i++;</span>
      }
<span class="nc" id="L509">    }</span>
<span class="nc" id="L510">  }</span>

  static void append8BitBytes(String content, BitArray bits, String encoding)
      throws WriterException {
    byte[] bytes;
    try {
<span class="fc" id="L516">      bytes = content.getBytes(encoding);</span>
<span class="nc" id="L517">    } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L518">      throw new WriterException(uee.toString());</span>
<span class="fc" id="L519">    }</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">    for (int i = 0; i &lt; bytes.length; ++i) {</span>
<span class="fc" id="L521">      bits.appendBits(bytes[i], 8);</span>
    }
<span class="fc" id="L523">  }</span>

  static void appendKanjiBytes(String content, BitArray bits) throws WriterException {
    byte[] bytes;
    try {
<span class="nc" id="L528">      bytes = content.getBytes(&quot;Shift_JIS&quot;);</span>
<span class="nc" id="L529">    } catch (UnsupportedEncodingException uee) {</span>
<span class="nc" id="L530">      throw new WriterException(uee.toString());</span>
<span class="nc" id="L531">    }</span>
<span class="nc" id="L532">    int length = bytes.length;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">    for (int i = 0; i &lt; length; i += 2) {</span>
<span class="nc" id="L534">      int byte1 = bytes[i] &amp; 0xFF;</span>
<span class="nc" id="L535">      int byte2 = bytes[i + 1] &amp; 0xFF;</span>
<span class="nc" id="L536">      int code = (byte1 &lt;&lt; 8) | byte2;</span>
<span class="nc" id="L537">      int subtracted = -1;</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">      if (code &gt;= 0x8140 &amp;&amp; code &lt;= 0x9ffc) {</span>
<span class="nc" id="L539">        subtracted = code - 0x8140;</span>
<span class="nc bnc" id="L540" title="All 4 branches missed.">      } else if (code &gt;= 0xe040 &amp;&amp; code &lt;= 0xebbf) {</span>
<span class="nc" id="L541">        subtracted = code - 0xc140;</span>
      }
<span class="nc bnc" id="L543" title="All 2 branches missed.">      if (subtracted == -1) {</span>
<span class="nc" id="L544">        throw new WriterException(&quot;Invalid byte sequence&quot;);</span>
      }
<span class="nc" id="L546">      int encoded = ((subtracted &gt;&gt; 8) * 0xc0) + (subtracted &amp; 0xff);</span>
<span class="nc" id="L547">      bits.appendBits(encoded, 13);</span>
    }
<span class="nc" id="L549">  }</span>

  private static void appendECI(ECI eci, BitArray bits) {
<span class="nc" id="L552">    bits.appendBits(Mode.ECI.getBits(), 4);</span>
    // This is correct for values up to 127, which is all we need now.
<span class="nc" id="L554">    bits.appendBits(eci.getValue(), 8);</span>
<span class="nc" id="L555">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>