<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MaskUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">zext.plantuml.com.google.zxing.qrcode.encoder</a> &gt; <span class="el_source">MaskUtil.java</span></div><h1>MaskUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package zext.plantuml.com.google.zxing.qrcode.encoder;

/**
 * @author satorux@google.com (Satoru Takabayashi) - creator
 * @author dswitkin@google.com (Daniel Switkin) - ported from C++
 */
public final class MaskUtil {
    // ::remove folder when __HAXE__

  private MaskUtil() {
    // do nothing
  }

  // Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
  // give penalty to them. Example: 00000 or 11111.
  public static int applyMaskPenaltyRule1(ByteMatrix matrix) {
<span class="nc" id="L33">    return applyMaskPenaltyRule1Internal(matrix, true) + applyMaskPenaltyRule1Internal(matrix, false);</span>
  }

  // Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
  // penalty to them.
  public static int applyMaskPenaltyRule2(ByteMatrix matrix) {
<span class="nc" id="L39">    int penalty = 0;</span>
<span class="nc" id="L40">    byte[][] array = matrix.getArray();</span>
<span class="nc" id="L41">    int width = matrix.getWidth();</span>
<span class="nc" id="L42">    int height = matrix.getHeight();</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">    for (int y = 0; y &lt; height - 1; ++y) {</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">      for (int x = 0; x &lt; width - 1; ++x) {</span>
<span class="nc" id="L45">        int value = array[y][x];</span>
<span class="nc bnc" id="L46" title="All 6 branches missed.">        if (value == array[y][x + 1] &amp;&amp; value == array[y + 1][x] &amp;&amp; value == array[y + 1][x + 1]) {</span>
<span class="nc" id="L47">          penalty += 3;</span>
        }
      }
    }
<span class="nc" id="L51">    return penalty;</span>
  }

  // Apply mask penalty rule 3 and return the penalty. Find consecutive cells of 00001011101 or
  // 10111010000, and give penalty to them.  If we find patterns like 000010111010000, we give
  // penalties twice (i.e. 40 * 2).
  public static int applyMaskPenaltyRule3(ByteMatrix matrix) {
<span class="nc" id="L58">    int penalty = 0;</span>
<span class="nc" id="L59">    byte[][] array = matrix.getArray();</span>
<span class="nc" id="L60">    int width = matrix.getWidth();</span>
<span class="nc" id="L61">    int height = matrix.getHeight();</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    for (int y = 0; y &lt; height; ++y) {</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">      for (int x = 0; x &lt; width; ++x) {</span>
        // Tried to simplify following conditions but failed.
<span class="nc bnc" id="L65" title="All 36 branches missed.">        if (x + 6 &lt; width &amp;&amp;</span>
            array[y][x] == 1 &amp;&amp;
            array[y][x +  1] == 0 &amp;&amp;
            array[y][x +  2] == 1 &amp;&amp;
            array[y][x +  3] == 1 &amp;&amp;
            array[y][x +  4] == 1 &amp;&amp;
            array[y][x +  5] == 0 &amp;&amp;
            array[y][x +  6] == 1 &amp;&amp;
            ((x + 10 &lt; width &amp;&amp;
                array[y][x +  7] == 0 &amp;&amp;
                array[y][x +  8] == 0 &amp;&amp;
                array[y][x +  9] == 0 &amp;&amp;
                array[y][x + 10] == 0) ||
                (x - 4 &gt;= 0 &amp;&amp;
                    array[y][x -  1] == 0 &amp;&amp;
                    array[y][x -  2] == 0 &amp;&amp;
                    array[y][x -  3] == 0 &amp;&amp;
                    array[y][x -  4] == 0))) {
<span class="nc" id="L83">          penalty += 40;</span>
        }
<span class="nc bnc" id="L85" title="All 36 branches missed.">        if (y + 6 &lt; height &amp;&amp;</span>
            array[y][x] == 1  &amp;&amp;
            array[y +  1][x] == 0  &amp;&amp;
            array[y +  2][x] == 1  &amp;&amp;
            array[y +  3][x] == 1  &amp;&amp;
            array[y +  4][x] == 1  &amp;&amp;
            array[y +  5][x] == 0  &amp;&amp;
            array[y +  6][x] == 1 &amp;&amp;
            ((y + 10 &lt; height &amp;&amp;
                array[y +  7][x] == 0 &amp;&amp;
                array[y +  8][x] == 0 &amp;&amp;
                array[y +  9][x] == 0 &amp;&amp;
                array[y + 10][x] == 0) ||
                (y - 4 &gt;= 0 &amp;&amp;
                    array[y -  1][x] == 0 &amp;&amp;
                    array[y -  2][x] == 0 &amp;&amp;
                    array[y -  3][x] == 0 &amp;&amp;
                    array[y -  4][x] == 0))) {
<span class="nc" id="L103">          penalty += 40;</span>
        }
      }
    }
<span class="nc" id="L107">    return penalty;</span>
  }

  // Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
  // penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance. Examples:
  // -   0% =&gt; 100
  // -  40% =&gt;  20
  // -  45% =&gt;  10
  // -  50% =&gt;   0
  // -  55% =&gt;  10
  // -  55% =&gt;  20
  // - 100% =&gt; 100
  public static int applyMaskPenaltyRule4(ByteMatrix matrix) {
<span class="nc" id="L120">    int numDarkCells = 0;</span>
<span class="nc" id="L121">    byte[][] array = matrix.getArray();</span>
<span class="nc" id="L122">    int width = matrix.getWidth();</span>
<span class="nc" id="L123">    int height = matrix.getHeight();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    for (int y = 0; y &lt; height; ++y) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      for (int x = 0; x &lt; width; ++x) {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (array[y][x] == 1) {</span>
<span class="nc" id="L127">          numDarkCells += 1;</span>
        }
      }
    }
<span class="nc" id="L131">    int numTotalCells = matrix.getHeight() * matrix.getWidth();</span>
<span class="nc" id="L132">    double darkRatio = (double) numDarkCells / numTotalCells;</span>
<span class="nc" id="L133">    return Math.abs((int) (darkRatio * 100 - 50)) / 5 * 10;</span>
  }

  // Return the mask bit for &quot;getMaskPattern&quot; at &quot;x&quot; and &quot;y&quot;. See 8.8 of JISX0510:2004 for mask
  // pattern conditions.
  public static boolean getDataMaskBit(int maskPattern, int x, int y) {
<span class="nc bnc" id="L139" title="All 2 branches missed.">    if (!QRCode.isValidMaskPattern(maskPattern)) {</span>
<span class="nc" id="L140">      throw new IllegalArgumentException(&quot;Invalid mask pattern&quot;);</span>
    }
    int intermediate, temp;
<span class="nc bnc" id="L143" title="All 9 branches missed.">    switch (maskPattern) {</span>
      case 0:
<span class="nc" id="L145">        intermediate = (y + x) &amp; 0x1;</span>
<span class="nc" id="L146">        break;</span>
      case 1:
<span class="nc" id="L148">        intermediate = y &amp; 0x1;</span>
<span class="nc" id="L149">        break;</span>
      case 2:
<span class="nc" id="L151">        intermediate = x % 3;</span>
<span class="nc" id="L152">        break;</span>
      case 3:
<span class="nc" id="L154">        intermediate = (y + x) % 3;</span>
<span class="nc" id="L155">        break;</span>
      case 4:
<span class="nc" id="L157">        intermediate = ((y &gt;&gt;&gt; 1) + (x / 3)) &amp; 0x1;</span>
<span class="nc" id="L158">        break;</span>
      case 5:
<span class="nc" id="L160">        temp = y * x;</span>
<span class="nc" id="L161">        intermediate = (temp &amp; 0x1) + (temp % 3);</span>
<span class="nc" id="L162">        break;</span>
      case 6:
<span class="nc" id="L164">        temp = y * x;</span>
<span class="nc" id="L165">        intermediate = (((temp &amp; 0x1) + (temp % 3)) &amp; 0x1);</span>
<span class="nc" id="L166">        break;</span>
      case 7:
<span class="nc" id="L168">        temp = y * x;</span>
<span class="nc" id="L169">        intermediate = (((temp % 3) + ((y + x) &amp; 0x1)) &amp; 0x1);</span>
<span class="nc" id="L170">        break;</span>
      default:
<span class="nc" id="L172">        throw new IllegalArgumentException(&quot;Invalid mask pattern: &quot; + maskPattern);</span>
    }
<span class="nc bnc" id="L174" title="All 2 branches missed.">    return intermediate == 0;</span>
  }

  // Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
  // vertical and horizontal orders respectively.
  private static int applyMaskPenaltyRule1Internal(ByteMatrix matrix, boolean isHorizontal) {
<span class="nc" id="L180">    int penalty = 0;</span>
<span class="nc" id="L181">    int numSameBitCells = 0;</span>
<span class="nc" id="L182">    int prevBit = -1;</span>
    // Horizontal mode:
    //   for (int i = 0; i &lt; matrix.height(); ++i) {
    //     for (int j = 0; j &lt; matrix.width(); ++j) {
    //       int bit = matrix.get(i, j);
    // Vertical mode:
    //   for (int i = 0; i &lt; matrix.width(); ++i) {
    //     for (int j = 0; j &lt; matrix.height(); ++j) {
    //       int bit = matrix.get(j, i);
<span class="nc bnc" id="L191" title="All 2 branches missed.">    int iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    int jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();</span>
<span class="nc" id="L193">    byte[][] array = matrix.getArray();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">    for (int i = 0; i &lt; iLimit; ++i) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">      for (int j = 0; j &lt; jLimit; ++j) {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">        int bit = isHorizontal ? array[i][j] : array[j][i];</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (bit == prevBit) {</span>
<span class="nc" id="L198">          numSameBitCells += 1;</span>
          // Found five repetitive cells with the same color (bit).
          // We'll give penalty of 3.
<span class="nc bnc" id="L201" title="All 2 branches missed.">          if (numSameBitCells == 5) {</span>
<span class="nc" id="L202">            penalty += 3;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">          } else if (numSameBitCells &gt; 5) {</span>
            // After five repetitive cells, we'll add the penalty one
            // by one.
<span class="nc" id="L206">            penalty += 1;</span>
          }
        } else {
<span class="nc" id="L209">          numSameBitCells = 1;  // Include the cell itself.</span>
<span class="nc" id="L210">          prevBit = bit;</span>
        }
      }
<span class="nc" id="L213">      numSameBitCells = 0;  // Clear at each row/column.</span>
    }
<span class="nc" id="L215">    return penalty;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>