<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ASCIIMathTeXImg.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.math</a> &gt; <span class="el_source">ASCIIMathTeXImg.java</span></div><h1>ASCIIMathTeXImg.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Translated and refactored by:  Arnaud Roques
 * Contribution: The-Lum
 *
 */

/*
This is a Java port of https://github.com/asciimath/asciimathml/blob/master/asciimath-based/ASCIIMathTeXImg.js

ASCIIMathTeXImg.js itself is based on ASCIIMathML, Version 1.4.7 Aug 30, 2005, (c) Peter Jipsen http://www.chapman.edu/~jipsen
Modified with TeX conversion for IMG rendering Sept 6, 2006 (c) David Lippman http://www.pierce.ctc.edu/dlippman
  Updated to match ver 2.2 Mar 3, 2014
  Latest at https://github.com/mathjax/asciimathml

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package net.sourceforge.plantuml.math;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

<span class="fc" id="L71">public class ASCIIMathTeXImg {</span>

	private int aAMnestingDepth;
	private Ttype aAMpreviousSymbol;
	private Ttype aAMcurrentSymbol;

	private String slice(String str, int start, int end) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">		if (end &gt; str.length()) {</span>
<span class="fc" id="L79">			return str.substring(start);</span>
		}
<span class="fc" id="L81">		return str.substring(start, end);</span>
	}

	private String slice(String str, int start) {
<span class="fc" id="L85">		return str.substring(start);</span>
	}

	private String substr(String str, int pos, int len) {
<span class="fc bfc" id="L89" title="All 2 branches covered.">		if (pos + len &gt; str.length()) {</span>
<span class="fc" id="L90">			return str.substring(pos);</span>
		}
<span class="fc" id="L92">		return str.substring(pos, pos + len);</span>
	}

	// Token types
<span class="fc" id="L96">	private enum Ttype {</span>
<span class="fc" id="L97">		CONST, UNARY, BINARY, INFIX, LEFTBRACKET, RIGHTBRACKET,</span>
<span class="fc" id="L98">		SPACE, UNDEROVER, DEFINITION, LEFTRIGHT, TEXT;</span>
	}

	// Flag
<span class="fc" id="L102">	private enum Flag {</span>
<span class="fc" id="L103">		ACC, VAL, FUNC, INVISIBLE, NOTEXCOPY;</span>
	}

	static class Tuple {
		private final String input;
		private final String tag;
		private final String output;
		private final String tex;
		private final Ttype ttype;

		private final String[] rewriteleftright;
		private final Collection&lt;Flag&gt; flags;

		private Tuple(String[] rewriteleftright, String input, String tag, String output, String tex, Ttype ttype,
<span class="fc" id="L117">				Flag... flags) {</span>
<span class="fc" id="L118">			this.input = input;</span>
<span class="fc" id="L119">			this.tag = tag;</span>
<span class="fc" id="L120">			this.output = output;</span>
<span class="fc" id="L121">			this.tex = tex;</span>
<span class="fc" id="L122">			this.ttype = ttype;</span>
<span class="fc" id="L123">			this.flags = Arrays.asList(flags);</span>
<span class="fc" id="L124">			this.rewriteleftright = rewriteleftright;</span>
<span class="fc" id="L125">		}</span>

<span class="fc" id="L127">		private Tuple(String input, String tag, String output, String tex, Ttype ttype, Flag... flags) {</span>
<span class="fc" id="L128">			this.input = input;</span>
<span class="fc" id="L129">			this.tag = tag;</span>
<span class="fc" id="L130">			this.output = output;</span>
<span class="fc" id="L131">			this.tex = tex;</span>
<span class="fc" id="L132">			this.ttype = ttype;</span>
<span class="fc" id="L133">			this.flags = Arrays.asList(flags);</span>
<span class="fc" id="L134">			this.rewriteleftright = null;</span>
<span class="fc" id="L135">		}</span>

		public boolean hasFlag(Flag flagName) {
<span class="fc" id="L138">			return flags.contains(flagName);</span>
		}
	}

<span class="fc" id="L142">	private static final Tuple aAMsqrt  = new Tuple(&quot;sqrt&quot;    , &quot;msqrt&quot;, &quot;sqrt&quot;    , null, Ttype.UNARY );</span>
<span class="fc" id="L143">	private static final Tuple aAMroot  = new Tuple(&quot;root&quot;    , &quot;mroot&quot;, &quot;root&quot;    , null, Ttype.BINARY);</span>
<span class="fc" id="L144">	private static final Tuple aAMfrac  = new Tuple(&quot;frac&quot;    , &quot;mfrac&quot;, &quot;/&quot;       , null, Ttype.BINARY);</span>
<span class="fc" id="L145">	private static final Tuple aAMdiv   = new Tuple(&quot;/&quot;       , &quot;mfrac&quot;, &quot;/&quot;       , null, Ttype.INFIX );</span>
<span class="fc" id="L146">	private static final Tuple aAMover  = new Tuple(&quot;stackrel&quot;, &quot;mover&quot;, &quot;stackrel&quot;, null, Ttype.BINARY);</span>
<span class="fc" id="L147">	private static final Tuple aAMsub   = new Tuple(&quot;_&quot;       , &quot;msub&quot; , &quot;_&quot;       , null, Ttype.INFIX );</span>
<span class="fc" id="L148">	private static final Tuple aAMsup   = new Tuple(&quot;^&quot;       , &quot;msup&quot; , &quot;^&quot;       , null, Ttype.INFIX );</span>
<span class="fc" id="L149">	private static final Tuple aAMtext  = new Tuple(&quot;text&quot;    , &quot;mtext&quot;, &quot;text&quot;    , null, Ttype.TEXT  );</span>
<span class="fc" id="L150">	private static final Tuple aAMmbox  = new Tuple(&quot;mbox&quot;    , &quot;mtext&quot;, &quot;mbox&quot;    , null, Ttype.TEXT  );</span>
<span class="fc" id="L151">	private static final Tuple aAMquote = new Tuple(&quot;\&quot;&quot;      , &quot;mtext&quot;, &quot;mbox&quot;    , null, Ttype.TEXT  );</span>

<span class="fc" id="L153">	private static final List&lt;Tuple&gt; aAMsymbols = new ArrayList&lt;&gt;(Arrays.asList(new Tuple[] { //</span>
			// some greek symbols
			new Tuple(&quot;alpha&quot;     , &quot;mi&quot;, &quot;\u03B1&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;beta&quot;      , &quot;mi&quot;, &quot;\u03B2&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;chi&quot;       , &quot;mi&quot;, &quot;\u03C7&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;delta&quot;     , &quot;mi&quot;, &quot;\u03B4&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Delta&quot;     , &quot;mo&quot;, &quot;\u0394&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;epsi&quot;      , &quot;mi&quot;, &quot;\u03B5&quot;, &quot;epsilon&quot;, Ttype.CONST     ), //
			new Tuple(&quot;varepsilon&quot;, &quot;mi&quot;, &quot;\u025B&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;eta&quot;       , &quot;mi&quot;, &quot;\u03B7&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;gamma&quot;     , &quot;mi&quot;, &quot;\u03B3&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Gamma&quot;     , &quot;mo&quot;, &quot;\u0393&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;iota&quot;      , &quot;mi&quot;, &quot;\u03B9&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;kappa&quot;     , &quot;mi&quot;, &quot;\u03BA&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;lambda&quot;    , &quot;mi&quot;, &quot;\u03BB&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Lambda&quot;    , &quot;mo&quot;, &quot;\u039B&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;lamda&quot;     , &quot;mi&quot;, &quot;lambda&quot;, null     , Ttype.DEFINITION), //
			new Tuple(&quot;Lamda&quot;     , &quot;mi&quot;, &quot;Lambda&quot;, null     , Ttype.DEFINITION), //
			new Tuple(&quot;mu&quot;        , &quot;mi&quot;, &quot;\u03BC&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;nu&quot;        , &quot;mi&quot;, &quot;\u03BD&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;omega&quot;     , &quot;mi&quot;, &quot;\u03C9&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Omega&quot;     , &quot;mo&quot;, &quot;\u03A9&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;phi&quot;       , &quot;mi&quot;, &quot;\u03C6&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;varphi&quot;    , &quot;mi&quot;, &quot;\u03D5&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Phi&quot;       , &quot;mo&quot;, &quot;\u03A6&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;pi&quot;        , &quot;mi&quot;, &quot;\u03C0&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Pi&quot;        , &quot;mo&quot;, &quot;\u03A0&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;psi&quot;       , &quot;mi&quot;, &quot;\u03C8&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Psi&quot;       , &quot;mi&quot;, &quot;\u03A8&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;rho&quot;       , &quot;mi&quot;, &quot;\u03C1&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;sigma&quot;     , &quot;mi&quot;, &quot;\u03C3&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Sigma&quot;     , &quot;mo&quot;, &quot;\u03A3&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;tau&quot;       , &quot;mi&quot;, &quot;\u03C4&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;theta&quot;     , &quot;mi&quot;, &quot;\u03B8&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;vartheta&quot;  , &quot;mi&quot;, &quot;\u03D1&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Theta&quot;     , &quot;mo&quot;, &quot;\u0398&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;upsilon&quot;   , &quot;mi&quot;, &quot;\u03C5&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;xi&quot;        , &quot;mi&quot;, &quot;\u03BE&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;Xi&quot;        , &quot;mo&quot;, &quot;\u039E&quot;, null     , Ttype.CONST     ), //
			new Tuple(&quot;zeta&quot;      , &quot;mi&quot;, &quot;\u03B6&quot;, null     , Ttype.CONST     ), //

			// binary operation symbols
			new Tuple(&quot;*&quot;       , &quot;mo&quot;    , &quot;\u22C5&quot;  , &quot;cdot&quot;     , Ttype.CONST                                ), //
			new Tuple(&quot;**&quot;      , &quot;mo&quot;    , &quot;\u2217&quot;  , &quot;ast&quot;      , Ttype.CONST                                ), //
			new Tuple(&quot;***&quot;     , &quot;mo&quot;    , &quot;\u22C6&quot;  , &quot;star&quot;     , Ttype.CONST                                ), //
			new Tuple(&quot;//&quot;      , &quot;mo&quot;    , &quot;/&quot;       , &quot;/&quot;        , Ttype.CONST      , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;\\\\&quot;    , &quot;mo&quot;    , &quot;\\&quot;      , &quot;backslash&quot;, Ttype.CONST                                ), //
			new Tuple(&quot;setminus&quot;, &quot;mo&quot;    , &quot;\\&quot;      , null       , Ttype.CONST                                ), //
			new Tuple(&quot;xx&quot;      , &quot;mo&quot;    , &quot;\u00D7&quot;  , &quot;times&quot;    , Ttype.CONST                                ), //
			new Tuple(&quot;|&gt;&lt;&quot;     , &quot;mo&quot;    , &quot;\u22C9&quot;  , &quot;ltimes&quot;   , Ttype.CONST                                ), //
			new Tuple(&quot;&gt;&lt;|&quot;     , &quot;mo&quot;    , &quot;\u22CA&quot;  , &quot;rtimes&quot;   , Ttype.CONST                                ), //
			new Tuple(&quot;|&gt;&lt;|&quot;    , &quot;mo&quot;    , &quot;\u22C8&quot;  , &quot;bowtie&quot;   , Ttype.CONST                                ), //
			new Tuple(&quot;-:&quot;      , &quot;mo&quot;    , &quot;\u00F7&quot;  , &quot;div&quot;      , Ttype.CONST                                ), //
			new Tuple(&quot;divide&quot;  , &quot;mo&quot;    , &quot;-:&quot;      , null       , Ttype.DEFINITION                           ), //
			new Tuple(&quot;@&quot;       , &quot;mo&quot;    , &quot;\u2218&quot;  , &quot;circ&quot;     , Ttype.CONST                                ), //
			new Tuple(&quot;o+&quot;      , &quot;mo&quot;    , &quot;\u2295&quot;  , &quot;oplus&quot;    , Ttype.CONST                                ), //
			new Tuple(&quot;ox&quot;      , &quot;mo&quot;    , &quot;\u2297&quot;  , &quot;otimes&quot;   , Ttype.CONST                                ), //
			new Tuple(&quot;o.&quot;      , &quot;mo&quot;    , &quot;\u2299&quot;  , &quot;odot&quot;     , Ttype.CONST                                ), //
			new Tuple(&quot;sum&quot;     , &quot;mo&quot;    , &quot;\u2211&quot;  , null       , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;prod&quot;    , &quot;mo&quot;    , &quot;\u220F&quot;  , null       , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;^^&quot;      , &quot;mo&quot;    , &quot;\u2227&quot;  , &quot;wedge&quot;    , Ttype.CONST                                ), //
			new Tuple(&quot;^^^&quot;     , &quot;mo&quot;    , &quot;\u22C0&quot;  , &quot;bigwedge&quot; , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;vv&quot;      , &quot;mo&quot;    , &quot;\u2228&quot;  , &quot;vee&quot;      , Ttype.CONST                                ), //
			new Tuple(&quot;vvv&quot;     , &quot;mo&quot;    , &quot;\u22C1&quot;  , &quot;bigvee&quot;   , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;nn&quot;      , &quot;mo&quot;    , &quot;\u2229&quot;  , &quot;cap&quot;      , Ttype.CONST                                ), //
			new Tuple(&quot;nnn&quot;     , &quot;mo&quot;    , &quot;\u22C2&quot;  , &quot;bigcap&quot;   , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;uu&quot;      , &quot;mo&quot;    , &quot;\u222A&quot;  , &quot;cup&quot;      , Ttype.CONST                                ), //
			new Tuple(&quot;uuu&quot;     , &quot;mo&quot;    , &quot;\u22C3&quot;  , &quot;bigcup&quot;   , Ttype.UNDEROVER                            ), //
			new Tuple(&quot;overset&quot; , &quot;mover&quot; , &quot;stackrel&quot;, null       , Ttype.BINARY                               ), //
			new Tuple(&quot;underset&quot;, &quot;munder&quot;, &quot;stackrel&quot;, null       , Ttype.BINARY                               ), //

			// binary relation symbols
			new Tuple(&quot;!=&quot;   , &quot;mo&quot;, &quot;\u2260&quot; , &quot;ne&quot;                , Ttype.CONST     ), //
			new Tuple(&quot;:=&quot;   , &quot;mo&quot;, &quot;:=&quot;     , null                , Ttype.CONST     ), //
			new Tuple(&quot;lt&quot;   , &quot;mo&quot;, &quot;&lt;&quot;      , null                , Ttype.CONST     ), //
			new Tuple(&quot;gt&quot;   , &quot;mo&quot;, &quot;&gt;&quot;      , null                , Ttype.CONST     ), //
			new Tuple(&quot;&lt;=&quot;   , &quot;mo&quot;, &quot;\u2264&quot; , &quot;le&quot;                , Ttype.CONST     ), //
			new Tuple(&quot;lt=&quot;  , &quot;mo&quot;, &quot;\u2264&quot; , &quot;leq&quot;               , Ttype.CONST     ), //
			new Tuple(&quot;gt=&quot;  , &quot;mo&quot;, &quot;\u2265&quot; , &quot;geq&quot;               , Ttype.CONST     ), //
			new Tuple(&quot;&gt;=&quot;   , &quot;mo&quot;, &quot;\u2265&quot; , &quot;ge&quot;                , Ttype.CONST     ), //
			new Tuple(&quot;mlt&quot;  , &quot;mo&quot;, &quot;\u226A&quot; , &quot;ll&quot;                , Ttype.CONST     ), //
			new Tuple(&quot;mgt&quot;  , &quot;mo&quot;, &quot;\u226B&quot; , &quot;gg&quot;                , Ttype.CONST     ), //
			new Tuple(&quot;-&lt;&quot;   , &quot;mo&quot;, &quot;\u227A&quot; , &quot;prec&quot;              , Ttype.CONST     ), //
			new Tuple(&quot;-lt&quot;  , &quot;mo&quot;, &quot;\u227A&quot; , null                , Ttype.CONST     ), //
			new Tuple(&quot;&gt;-&quot;   , &quot;mo&quot;, &quot;\u227B&quot; , &quot;succ&quot;              , Ttype.CONST     ), //
			new Tuple(&quot;-&lt;=&quot;  , &quot;mo&quot;, &quot;\u2AAF&quot; , &quot;preceq&quot;            , Ttype.CONST     ), //
			new Tuple(&quot;&gt;-=&quot;  , &quot;mo&quot;, &quot;\u2AB0&quot; , &quot;succeq&quot;            , Ttype.CONST     ), //
			new Tuple(&quot;in&quot;   , &quot;mo&quot;, &quot;\u2208&quot; , null                , Ttype.CONST     ), //
			new Tuple(&quot;!in&quot;  , &quot;mo&quot;, &quot;\u2209&quot; , &quot;notin&quot;             , Ttype.CONST     ), //
			new Tuple(&quot;sub&quot;  , &quot;mo&quot;, &quot;\u2282&quot; , &quot;subset&quot;            , Ttype.CONST     ), //
			new Tuple(&quot;sup&quot;  , &quot;mo&quot;, &quot;\u2283&quot; , &quot;supset&quot;            , Ttype.CONST     ), //
			new Tuple(&quot;sube&quot; , &quot;mo&quot;, &quot;\u2286&quot; , &quot;subseteq&quot;          , Ttype.CONST     ), //
			new Tuple(&quot;supe&quot; , &quot;mo&quot;, &quot;\u2287&quot; , &quot;supseteq&quot;          , Ttype.CONST     ), //
			new Tuple(&quot;-=&quot;   , &quot;mo&quot;, &quot;\u2261&quot; , &quot;equiv&quot;             , Ttype.CONST     ), //
			new Tuple(&quot;~=&quot;   , &quot;mo&quot;, &quot;\u2245&quot; , &quot;stackrel{\\sim}{=}&quot;, Ttype.CONST     , Flag.NOTEXCOPY), //
			new Tuple(&quot;cong&quot; , &quot;mo&quot;, &quot;~=&quot;     , null                , Ttype.DEFINITION), //
			new Tuple(&quot;~&quot;    , &quot;mo&quot;, &quot;\u223C&quot; , &quot;sim&quot;               , Ttype.CONST     ), //
			new Tuple(&quot;~~&quot;   , &quot;mo&quot;, &quot;\u2248&quot; , &quot;approx&quot;            , Ttype.CONST     ), //
			new Tuple(&quot;prop&quot; , &quot;mo&quot;, &quot;\u221D&quot; , &quot;propto&quot;            , Ttype.CONST     ), //

			// logical symbols
			new Tuple(&quot;and&quot;    , &quot;mtext&quot;, &quot;and&quot;   , null            , Ttype.SPACE     ), //
			new Tuple(&quot;or&quot;     , &quot;mtext&quot;, &quot;or&quot;    , null            , Ttype.SPACE     ), //
			new Tuple(&quot;not&quot;    , &quot;mo&quot;   , &quot;\u00AC&quot;, &quot;neg&quot;           , Ttype.CONST     ), //
			new Tuple(&quot;=&gt;&quot;     , &quot;mo&quot;   , &quot;\u21D2&quot;, &quot;Rightarrow&quot;    , Ttype.CONST     ), //
			new Tuple(&quot;implies&quot;, &quot;mo&quot;   , &quot;=&gt;&quot;    , null            , Ttype.DEFINITION), //
			new Tuple(&quot;if&quot;     , &quot;mo&quot;   , &quot;if&quot;    , null            , Ttype.SPACE     ), //
			new Tuple(&quot;&lt;=&gt;&quot;    , &quot;mo&quot;   , &quot;\u21D4&quot;, &quot;Leftrightarrow&quot;, Ttype.CONST     ), //
			new Tuple(&quot;iff&quot;    , &quot;mo&quot;   , &quot;&lt;=&gt;&quot;   , null            , Ttype.DEFINITION), //
			new Tuple(&quot;AA&quot;     , &quot;mo&quot;   , &quot;\u2200&quot;, &quot;forall&quot;        , Ttype.CONST     ), //
			new Tuple(&quot;EE&quot;     , &quot;mo&quot;   , &quot;\u2203&quot;, &quot;exists&quot;        , Ttype.CONST     ), //
			new Tuple(&quot;_|_&quot;    , &quot;mo&quot;   , &quot;\u22A5&quot;, &quot;bot&quot;           , Ttype.CONST     ), //
			new Tuple(&quot;TT&quot;     , &quot;mo&quot;   , &quot;\u22A4&quot;, &quot;top&quot;           , Ttype.CONST     ), //
			new Tuple(&quot;|--&quot;    , &quot;mo&quot;   , &quot;\u22A2&quot;, &quot;vdash&quot;         , Ttype.CONST     ), //
			new Tuple(&quot;|==&quot;    , &quot;mo&quot;   , &quot;\u22A8&quot;, &quot;models&quot;        , Ttype.CONST     ), //

			// grouping brackets
			new Tuple(&quot;(&quot;      , &quot;mo&quot;, &quot;(&quot;      , null    , Ttype.LEFTBRACKET  , Flag.VAL                ), //
			new Tuple(&quot;)&quot;      , &quot;mo&quot;, &quot;)&quot;      , null    , Ttype.RIGHTBRACKET , Flag.VAL                ), //
			new Tuple(&quot;[&quot;      , &quot;mo&quot;, &quot;[&quot;      , null    , Ttype.LEFTBRACKET  , Flag.VAL                ), //
			new Tuple(&quot;]&quot;      , &quot;mo&quot;, &quot;]&quot;      , null    , Ttype.RIGHTBRACKET , Flag.VAL                ), //
			new Tuple(&quot;left(&quot;  , &quot;mo&quot;, &quot;(&quot;      , &quot;(&quot;     , Ttype.LEFTBRACKET  , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;right)&quot; , &quot;mo&quot;, &quot;)&quot;      , &quot;)&quot;     , Ttype.RIGHTBRACKET , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;left[&quot;  , &quot;mo&quot;, &quot;[&quot;      , &quot;[&quot;     , Ttype.LEFTBRACKET  , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;right]&quot; , &quot;mo&quot;, &quot;]&quot;      , &quot;]&quot;     , Ttype.RIGHTBRACKET , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;{&quot;      , &quot;mo&quot;, &quot;{&quot;      , &quot;lbrace&quot;, Ttype.LEFTBRACKET                            ), //
			new Tuple(&quot;}&quot;      , &quot;mo&quot;, &quot;}&quot;      , &quot;rbrace&quot;, Ttype.RIGHTBRACKET                           ), //
			new Tuple(&quot;|&quot;      , &quot;mo&quot;, &quot;|&quot;      , null    , Ttype.LEFTRIGHT    , Flag.VAL                ), //
			new Tuple(&quot;|:&quot;     , &quot;mo&quot;, &quot;|&quot;      , &quot;|&quot;     , Ttype.LEFTRIGHT    , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;:|&quot;     , &quot;mo&quot;, &quot;|&quot;      , &quot;|&quot;     , Ttype.RIGHTBRACKET , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;:|:&quot;    , &quot;mo&quot;, &quot;|&quot;      , &quot;|&quot;     , Ttype.CONST        , Flag.VAL, Flag.NOTEXCOPY), //
			new Tuple(&quot;(:&quot;     , &quot;mo&quot;, &quot;\u2329&quot; , &quot;langle&quot;, Ttype.LEFTBRACKET                            ), //
			new Tuple(&quot;:)&quot;     , &quot;mo&quot;, &quot;\u232A&quot; , &quot;rangle&quot;, Ttype.RIGHTBRACKET                           ), //
			new Tuple(&quot;&lt;&lt;&quot;     , &quot;mo&quot;, &quot;\u2329&quot; , &quot;langle&quot;, Ttype.LEFTBRACKET                            ), //
			new Tuple(&quot;&gt;&gt;&quot;     , &quot;mo&quot;, &quot;\u232A&quot; , &quot;rangle&quot;, Ttype.RIGHTBRACKET                           ), //
			new Tuple(&quot;{:&quot;     , &quot;mo&quot;, &quot;{:&quot;     , null    , Ttype.LEFTBRACKET  , Flag.INVISIBLE          ), //
			new Tuple(&quot;:}&quot;     , &quot;mo&quot;, &quot;:}&quot;     , null    , Ttype.RIGHTBRACKET , Flag.INVISIBLE          ), //

			// miscellaneous symbols
			new Tuple(&quot;int&quot;      , &quot;mo&quot;, &quot;\u222B&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;dx&quot;       , &quot;mi&quot;, &quot;{:d x:}&quot;                  , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;dy&quot;       , &quot;mi&quot;, &quot;{:d y:}&quot;                  , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;dz&quot;       , &quot;mi&quot;, &quot;{:d z:}&quot;                  , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;dt&quot;       , &quot;mi&quot;, &quot;{:d t:}&quot;                  , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;oint&quot;     , &quot;mo&quot;, &quot;\u222E&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;del&quot;      , &quot;mo&quot;, &quot;\u2202&quot;                   , &quot;partial&quot;  , Ttype.CONST                           ), //
			new Tuple(&quot;grad&quot;     , &quot;mo&quot;, &quot;\u2207&quot;                   , &quot;nabla&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;+-&quot;       , &quot;mo&quot;, &quot;\u00B1&quot;                   , &quot;pm&quot;       , Ttype.CONST                           ), //
			new Tuple(&quot;-+&quot;       , &quot;mo&quot;, &quot;\u2213&quot;                   , &quot;mp&quot;       , Ttype.CONST                           ), //
			new Tuple(&quot;O/&quot;       , &quot;mo&quot;, &quot;\u2205&quot;                   , &quot;emptyset&quot; , Ttype.CONST                           ), //
			new Tuple(&quot;oo&quot;       , &quot;mo&quot;, &quot;\u221E&quot;                   , &quot;infty&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;aleph&quot;    , &quot;mo&quot;, &quot;\u2135&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;...&quot;      , &quot;mo&quot;, &quot;...&quot;                      , &quot;ldots&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;:.&quot;       , &quot;mo&quot;, &quot;\u2234&quot;                   , &quot;therefore&quot;, Ttype.CONST                           ), //
			new Tuple(&quot;:'&quot;       , &quot;mo&quot;, &quot;\u2235&quot;                   , &quot;because&quot;  , Ttype.CONST                           ), //
			new Tuple(&quot;/_&quot;       , &quot;mo&quot;, &quot;\u2220&quot;                   , &quot;angle&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;/_\\&quot;     , &quot;mo&quot;, &quot;\u25B3&quot;                   , &quot;triangle&quot; , Ttype.CONST                           ), //
			new Tuple(&quot;\\ &quot;      , &quot;mo&quot;, &quot;\u00A0&quot;                   , null       , Ttype.CONST      , Flag.VAL           ), //
			new Tuple(&quot;frown&quot;    , &quot;mo&quot;, &quot;\u2322&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;%&quot;        , &quot;mo&quot;, &quot;%&quot;                        , &quot;%&quot;        , Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;quad&quot;     , &quot;mo&quot;, &quot;\u00A0\u00A0&quot;             , null       , Ttype.CONST                           ), //
			new Tuple(&quot;qquad&quot;    , &quot;mo&quot;, &quot;\u00A0\u00A0\u00A0\u00A0&quot; , null       , Ttype.CONST                           ), //
			new Tuple(&quot;cdots&quot;    , &quot;mo&quot;, &quot;\u22EF&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;vdots&quot;    , &quot;mo&quot;, &quot;\u22EE&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;ddots&quot;    , &quot;mo&quot;, &quot;\u22F1&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;diamond&quot;  , &quot;mo&quot;, &quot;\u22C4&quot;                   , null       , Ttype.CONST                           ), //
			new Tuple(&quot;square&quot;   , &quot;mo&quot;, &quot;\u25A1&quot;                   , &quot;boxempty&quot; , Ttype.CONST                           ), //
			new Tuple(&quot;|__&quot;      , &quot;mo&quot;, &quot;\u230A&quot;                   , &quot;lfloor&quot;   , Ttype.CONST                           ), //
			new Tuple(&quot;__|&quot;      , &quot;mo&quot;, &quot;\u230B&quot;                   , &quot;rfloor&quot;   , Ttype.CONST                           ), //
			new Tuple(&quot;|~&quot;       , &quot;mo&quot;, &quot;\u2308&quot;                   , &quot;lceil&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;lceiling&quot; , &quot;mo&quot;, &quot;|~&quot;                       , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;~|&quot;       , &quot;mo&quot;, &quot;\u2309&quot;                   , &quot;rceil&quot;    , Ttype.CONST                           ), //
			new Tuple(&quot;rceiling&quot; , &quot;mo&quot;, &quot;~|&quot;                       , null       , Ttype.DEFINITION                      ), //
			new Tuple(&quot;CC&quot;       , &quot;mo&quot;, &quot;\u2102&quot;                   , &quot;mathbb{C}&quot;, Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;NN&quot;       , &quot;mo&quot;, &quot;\u2115&quot;                   , &quot;mathbb{N}&quot;, Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;QQ&quot;       , &quot;mo&quot;, &quot;\u211A&quot;                   , &quot;mathbb{Q}&quot;, Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;RR&quot;       , &quot;mo&quot;, &quot;\u211D&quot;                   , &quot;mathbb{R}&quot;, Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;ZZ&quot;       , &quot;mo&quot;, &quot;\u2124&quot;                   , &quot;mathbb{Z}&quot;, Ttype.CONST      , Flag.NOTEXCOPY     ), //
			new Tuple(&quot;f&quot;        , &quot;mi&quot;, &quot;f&quot;                        , null       , Ttype.UNARY      , Flag.FUNC, Flag.VAL), //
			new Tuple(&quot;g&quot;        , &quot;mi&quot;, &quot;g&quot;                        , null       , Ttype.UNARY      , Flag.FUNC, Flag.VAL), //
			new Tuple(&quot;prime&quot;    , &quot;mo&quot;, &quot;\u2032&quot;                   , &quot;'&quot;        , Ttype.CONST      , Flag.VAL , Flag.NOTEXCOPY), //
			new Tuple(&quot;''&quot;       , &quot;mo&quot;, &quot;''&quot;                       , null       , Ttype.CONST      , Flag.VAL           ), //
			new Tuple(&quot;'''&quot;      , &quot;mo&quot;, &quot;'''&quot;                      , null       , Ttype.CONST      , Flag.VAL           ), //
			new Tuple(&quot;''''&quot;     , &quot;mo&quot;, &quot;''''&quot;                     , null       , Ttype.CONST      , Flag.VAL           ), //

			// standard functions
			new Tuple(&quot;lim&quot;   , &quot;mo&quot;, &quot;lim&quot;   , null, Ttype.UNDEROVER           ), //
			new Tuple(&quot;Lim&quot;   , &quot;mo&quot;, &quot;Lim&quot;   , null, Ttype.UNDEROVER           ), //
			new Tuple(&quot;sin&quot;   , &quot;mo&quot;, &quot;sin&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;cos&quot;   , &quot;mo&quot;, &quot;cos&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;tan&quot;   , &quot;mo&quot;, &quot;tan&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;arcsin&quot;, &quot;mo&quot;, &quot;arcsin&quot;, null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;arccos&quot;, &quot;mo&quot;, &quot;arccos&quot;, null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;arctan&quot;, &quot;mo&quot;, &quot;arctan&quot;, null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;sinh&quot;  , &quot;mo&quot;, &quot;sinh&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;cosh&quot;  , &quot;mo&quot;, &quot;cosh&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;tanh&quot;  , &quot;mo&quot;, &quot;tanh&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;cot&quot;   , &quot;mo&quot;, &quot;cot&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;coth&quot;  , &quot;mo&quot;, &quot;coth&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;sech&quot;  , &quot;mo&quot;, &quot;sech&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;csch&quot;  , &quot;mo&quot;, &quot;csch&quot;  , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;sec&quot;   , &quot;mo&quot;, &quot;sec&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;csc&quot;   , &quot;mo&quot;, &quot;csc&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;log&quot;   , &quot;mo&quot;, &quot;log&quot;   , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(&quot;ln&quot;    , &quot;mo&quot;, &quot;ln&quot;    , null, Ttype.UNARY    , Flag.FUNC), //
			new Tuple(new String[] { &quot;|&quot;       , &quot;|&quot;        }, &quot;abs&quot;  , &quot;mo&quot;, &quot;abs&quot;  , null, Ttype.UNARY, Flag.NOTEXCOPY), //
			new Tuple(new String[] { &quot;\\|&quot;     , &quot;\\|&quot;      }, &quot;norm&quot; , &quot;mo&quot;, &quot;norm&quot; , null, Ttype.UNARY, Flag.NOTEXCOPY), //
			new Tuple(new String[] { &quot;\\lfloor&quot;, &quot;\\rfloor&quot; }, &quot;floor&quot;, &quot;mo&quot;, &quot;floor&quot;, null, Ttype.UNARY, Flag.NOTEXCOPY), //
			new Tuple(new String[] { &quot;\\lceil&quot; , &quot;\\rceil&quot;  }, &quot;ceil&quot; , &quot;mo&quot;, &quot;ceil&quot; , null, Ttype.UNARY, Flag.NOTEXCOPY), //
			new Tuple(&quot;Sin&quot;   , &quot;mo&quot;, &quot;Sin&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Cos&quot;   , &quot;mo&quot;, &quot;Cos&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Tan&quot;   , &quot;mo&quot;, &quot;Tan&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Arcsin&quot;, &quot;mo&quot;, &quot;Arcsin&quot;, null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Arccos&quot;, &quot;mo&quot;, &quot;Arccos&quot;, null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Arctan&quot;, &quot;mo&quot;, &quot;Arctan&quot;, null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Sinh&quot;  , &quot;mo&quot;, &quot;Sinh&quot;  , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Cosh&quot;  , &quot;mo&quot;, &quot;Cosh&quot;  , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Tanh&quot;  , &quot;mo&quot;, &quot;Tanh&quot;  , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Cot&quot;   , &quot;mo&quot;, &quot;Cot&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Sec&quot;   , &quot;mo&quot;, &quot;Sec&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Csc&quot;   , &quot;mo&quot;, &quot;Csc&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Log&quot;   , &quot;mo&quot;, &quot;Log&quot;   , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(&quot;Ln&quot;    , &quot;mo&quot;, &quot;Ln&quot;    , null, Ttype.UNARY, Flag.FUNC), //
			new Tuple(new String[] { &quot;|&quot;, &quot;|&quot; }, &quot;Abs&quot;, &quot;mo&quot;, &quot;abs&quot;, null, Ttype.UNARY, Flag.NOTEXCOPY), //
			new Tuple(&quot;det&quot;, &quot;mo&quot;, &quot;det&quot;, null       , Ttype.UNARY    , Flag.FUNC                ), //
			new Tuple(&quot;exp&quot;, &quot;mo&quot;, &quot;exp&quot;, null       , Ttype.UNARY    , Flag.FUNC                ), //
			new Tuple(&quot;dim&quot;, &quot;mo&quot;, &quot;dim&quot;, null       , Ttype.CONST                               ), //
			new Tuple(&quot;mod&quot;, &quot;mo&quot;, &quot;mod&quot;, &quot;text{mod}&quot;, Ttype.CONST    , Flag.NOTEXCOPY           ), //
			new Tuple(&quot;gcd&quot;, &quot;mo&quot;, &quot;gcd&quot;, null       , Ttype.UNARY    , Flag.FUNC                ), //
			new Tuple(&quot;lcm&quot;, &quot;mo&quot;, &quot;lcm&quot;, &quot;text{lcm}&quot;, Ttype.UNARY    , Flag.FUNC, Flag.NOTEXCOPY), //
			new Tuple(&quot;lub&quot;, &quot;mo&quot;, &quot;lub&quot;, null       , Ttype.CONST                               ), //
			new Tuple(&quot;glb&quot;, &quot;mo&quot;, &quot;glb&quot;, null       , Ttype.CONST                               ), //
			new Tuple(&quot;min&quot;, &quot;mo&quot;, &quot;min&quot;, null       , Ttype.UNDEROVER                           ), //
			new Tuple(&quot;max&quot;, &quot;mo&quot;, &quot;max&quot;, null       , Ttype.UNDEROVER                           ), //

			// arrows
			new Tuple(&quot;uarr&quot;, &quot;mo&quot;, &quot;\u2191&quot;, &quot;uparrow&quot;              , Ttype.CONST), //
			new Tuple(&quot;darr&quot;, &quot;mo&quot;, &quot;\u2193&quot;, &quot;downarrow&quot;            , Ttype.CONST), //
			new Tuple(&quot;rarr&quot;, &quot;mo&quot;, &quot;\u2192&quot;, &quot;rightarrow&quot;           , Ttype.CONST), //
			new Tuple(&quot;-&gt;&quot;  , &quot;mo&quot;, &quot;\u2192&quot;, &quot;to&quot;                   , Ttype.CONST), //
			new Tuple(&quot;&gt;-&gt;&quot; , &quot;mo&quot;, &quot;\u21A3&quot;, &quot;rightarrowtail&quot;       , Ttype.CONST), //
			new Tuple(&quot;-&gt;&gt;&quot; , &quot;mo&quot;, &quot;\u21A0&quot;, &quot;twoheadrightarrow&quot;    , Ttype.CONST), //
			new Tuple(&quot;&gt;-&gt;&gt;&quot;, &quot;mo&quot;, &quot;\u2916&quot;, &quot;twoheadrightarrowtail&quot;, Ttype.CONST), //
			new Tuple(&quot;|-&gt;&quot; , &quot;mo&quot;, &quot;\u21A6&quot;, &quot;mapsto&quot;               , Ttype.CONST), //
			new Tuple(&quot;larr&quot;, &quot;mo&quot;, &quot;\u2190&quot;, &quot;leftarrow&quot;            , Ttype.CONST), //
			new Tuple(&quot;harr&quot;, &quot;mo&quot;, &quot;\u2194&quot;, &quot;leftrightarrow&quot;       , Ttype.CONST), //
			new Tuple(&quot;uArr&quot;, &quot;mo&quot;, &quot;\u21D1&quot;, &quot;Uparrow&quot;              , Ttype.CONST), //
			new Tuple(&quot;dArr&quot;, &quot;mo&quot;, &quot;\u21D3&quot;, &quot;Downarrow&quot;            , Ttype.CONST), //
			new Tuple(&quot;rArr&quot;, &quot;mo&quot;, &quot;\u21D2&quot;, &quot;Rightarrow&quot;           , Ttype.CONST), //
			new Tuple(&quot;lArr&quot;, &quot;mo&quot;, &quot;\u21D0&quot;, &quot;Leftarrow&quot;            , Ttype.CONST), //
			new Tuple(&quot;hArr&quot;, &quot;mo&quot;, &quot;\u21D4&quot;, &quot;Leftrightarrow&quot;       , Ttype.CONST), //


			// commands with argument
			aAMsqrt, aAMroot, aAMfrac, aAMdiv, aAMover, aAMsub, aAMsup,
			new Tuple(&quot;cancel&quot;   , &quot;menclose&quot;, &quot;cancel&quot;, null               , Ttype.UNARY                          ), //
			new Tuple(&quot;Sqrt&quot;     , &quot;msqrt&quot;   , &quot;sqrt&quot;  , null               , Ttype.UNARY                          ), //
			new Tuple(&quot;hat&quot;      , &quot;mover&quot;   , &quot;\u005E&quot;, null               , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;bar&quot;      , &quot;mover&quot;   , &quot;\u00AF&quot;, &quot;overline&quot;         , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;vec&quot;      , &quot;mover&quot;   , &quot;\u2192&quot;, null               , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;tilde&quot;    , &quot;mover&quot;   , &quot;~&quot;     , null               , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;dot&quot;      , &quot;mover&quot;   , &quot;.&quot;     , null               , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;ddot&quot;     , &quot;mover&quot;   , &quot;..&quot;    , null               , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;overarc&quot;  , &quot;mover&quot;   , &quot;\u23DC&quot;, &quot;stackrel{\\frown}&quot;, Ttype.UNARY, Flag.ACC, Flag.NOTEXCOPY), //
			new Tuple(&quot;overparen&quot;, &quot;mover&quot;   , &quot;\u23DC&quot;, &quot;stackrel{\\frown}&quot;, Ttype.UNARY, Flag.ACC, Flag.NOTEXCOPY), //
			new Tuple(&quot;ul&quot;       , &quot;munder&quot;  , &quot;\u0332&quot;, &quot;underline&quot;        , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;ubrace&quot;   , &quot;munder&quot;  , &quot;\u23DF&quot;, &quot;underbrace&quot;       , Ttype.UNARY, Flag.ACC                ), //
			new Tuple(&quot;obrace&quot;   , &quot;mover&quot;   , &quot;\u23DE&quot;, &quot;overbrace&quot;        , Ttype.UNARY, Flag.ACC                ), //
			aAMtext, aAMmbox, aAMquote, //
			new Tuple(&quot;color&quot;   , &quot;mstyle&quot;, null      , null      , Ttype.BINARY                ), //
			new Tuple(&quot;bb&quot;      , &quot;mstyle&quot;, &quot;bb&quot;      , &quot;mathbf&quot;  , Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathbf&quot;  , &quot;mstyle&quot;, &quot;mathbf&quot;  , null      , Ttype.UNARY                 ), //
			new Tuple(&quot;sf&quot;      , &quot;mstyle&quot;, &quot;sf&quot;      , &quot;mathsf&quot;  , Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathsf&quot;  , &quot;mstyle&quot;, &quot;mathsf&quot;  , null      , Ttype.UNARY                 ), //
			new Tuple(&quot;bbb&quot;     , &quot;mstyle&quot;, &quot;bbb&quot;     , &quot;mathbb&quot;  , Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathbb&quot;  , &quot;mstyle&quot;, &quot;mathbb&quot;  , null      , Ttype.UNARY                 ), //
			new Tuple(&quot;cc&quot;      , &quot;mstyle&quot;, &quot;cc&quot;      , &quot;mathcal&quot; , Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathcal&quot; , &quot;mstyle&quot;, &quot;mathcal&quot; , null      , Ttype.UNARY                 ), //
			new Tuple(&quot;tt&quot;      , &quot;mstyle&quot;, &quot;tt&quot;      , &quot;mathtt&quot;  , Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathtt&quot;  , &quot;mstyle&quot;, &quot;mathtt&quot;  , null      , Ttype.UNARY                 ), //
			new Tuple(&quot;fr&quot;      , &quot;mstyle&quot;, &quot;fr&quot;      , &quot;mathfrak&quot;, Ttype.UNARY , Flag.NOTEXCOPY), //
			new Tuple(&quot;mathfrak&quot;, &quot;mstyle&quot;, &quot;mathfrak&quot;, null      , Ttype.UNARY                 ), //

			// newline for formatting: in order to add a new line between multiple formulas
			new Tuple(&quot;newline&quot;, &quot;mo&quot;, &quot;newline&quot;, &quot;\\\\&quot;, Ttype.CONST, Flag.VAL, Flag.NOTEXCOPY), //
	} //
	));

	private static String[] aAMnames;

	private static void aAMinitSymbols() {
<span class="fc" id="L444">		int symlen = aAMsymbols.size();</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">		for (int i = 0; i &lt; symlen; i++) {</span>
<span class="fc bfc" id="L446" title="All 4 branches covered.">			if (aAMsymbols.get(i).tex != null &amp;&amp; !(aAMsymbols.get(i).hasFlag(Flag.NOTEXCOPY))) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">				Tuple tmp = aAMsymbols.get(i).hasFlag(Flag.ACC)</span>
<span class="fc" id="L448">						? new Tuple(aAMsymbols.get(i).tex, aAMsymbols.get(i).tag, aAMsymbols.get(i).output, null,</span>
<span class="fc" id="L449">								aAMsymbols.get(i).ttype, Flag.ACC)</span>
<span class="fc" id="L450">						: new Tuple(aAMsymbols.get(i).tex, aAMsymbols.get(i).tag, aAMsymbols.get(i).output, null,</span>
<span class="fc" id="L451">								aAMsymbols.get(i).ttype);</span>
<span class="fc" id="L452">				aAMsymbols.add(tmp);</span>
			}
		}
<span class="fc" id="L455">		refreshSymbols();</span>
<span class="fc" id="L456">	}</span>

	private static void refreshSymbols() {
<span class="fc" id="L459">		Collections.sort(aAMsymbols, (o1, o2) -&gt; o1.input.compareTo(o2.input));</span>
<span class="fc" id="L460">		aAMnames = new String[aAMsymbols.size()];</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">		for (int i = 0; i &lt; aAMsymbols.size(); i++)</span>
<span class="fc" id="L462">			aAMnames[i] = aAMsymbols.get(i).input;</span>
<span class="fc" id="L463">	}</span>

	private String aAMremoveCharsAndBlanks(String str, int n) {
		// remove n characters and any following blanks
		String st;
<span class="fc bfc" id="L468" title="All 10 branches covered.">		if (str.length() &gt; 1 &amp;&amp; str.length() &gt; n &amp;&amp; str.charAt(n) == '\\' &amp;&amp; str.charAt(n + 1) != '\\' &amp;&amp; str.charAt(n + 1) != ' ')</span>
<span class="fc" id="L469">			st = slice(str, n + 1);</span>
		else
<span class="fc" id="L471">			st = slice(str, n);</span>
		int i;
<span class="fc bfc" id="L473" title="All 4 branches covered.">		for (i = 0; i &lt; st.length() &amp;&amp; st.charAt(i) &lt;= 32; i = i + 1)</span>
			;
<span class="fc" id="L475">		return slice(st, i);</span>
	}

	private int aAMposition(String[] arr, String str, int n) {
		// return position &gt;=n where str appears or would be inserted
		// assumes arr is sorted
<span class="fc" id="L481">		int i = 0;</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">		if (n == 0) {</span>
			int h;
			int m;
<span class="fc" id="L485">			n = -1;</span>
<span class="fc" id="L486">			h = arr.length;</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">			while (n + 1 &lt; h) {</span>
<span class="fc" id="L488">				m = (n + h) &gt;&gt; 1;</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">				if (arr[m].compareTo(str) &lt; 0)</span>
<span class="fc" id="L490">					n = m;</span>
				else
<span class="fc" id="L492">					h = m;</span>
			}
<span class="fc" id="L494">			return h;</span>
		} else {
<span class="pc bpc" id="L496" title="1 of 4 branches missed.">			for (i = n; i &lt; arr.length &amp;&amp; arr[i].compareTo(str) &lt; 0; i++)</span>
				;
		}
<span class="fc" id="L499">		return i; // i=arr.length || arr[i]&gt;=str</span>
	}

	private Tuple aAMgetSymbol(String str) {
		// return maximal initial substring of str that appears in names
		// return null if there is none
<span class="fc" id="L505">		int k = 0; // new pos</span>
<span class="fc" id="L506">		int j = 0; // old pos</span>
<span class="fc" id="L507">		int mk = 0; // match pos</span>
		String st;
		String tagst;
<span class="fc" id="L510">		String match = &quot;&quot;;</span>
<span class="fc" id="L511">		boolean more = true;</span>
<span class="fc bfc" id="L512" title="All 4 branches covered.">		for (int i = 1; i &lt;= str.length() &amp;&amp; more; i++) {</span>
<span class="fc" id="L513">			st = str.substring(0, i); // initial substring of length i</span>
<span class="fc" id="L514">			j = k;</span>
<span class="fc" id="L515">			k = aAMposition(aAMnames, st, j);</span>
<span class="pc bpc" id="L516" title="1 of 4 branches missed.">			if (k &lt; aAMnames.length &amp;&amp; slice(str, 0, aAMnames[k].length()).equals(aAMnames[k])) {</span>
<span class="fc" id="L517">				match = aAMnames[k];</span>
<span class="fc" id="L518">				mk = k;</span>
<span class="fc" id="L519">				i = match.length();</span>
			}
<span class="pc bpc" id="L521" title="1 of 4 branches missed.">			more = k &lt; aAMnames.length &amp;&amp; slice(str, 0, aAMnames[k].length()).compareTo(aAMnames[k]) &gt;= 0;</span>
		}
<span class="fc" id="L523">		aAMpreviousSymbol = aAMcurrentSymbol;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">		if (!match.equals(&quot;&quot;)) {</span>
<span class="fc" id="L525">			aAMcurrentSymbol = aAMsymbols.get(mk).ttype;</span>
<span class="fc" id="L526">			return aAMsymbols.get(mk);</span>
		}
		// if str[0] is a digit or - return maxsubstring of digits.digits
<span class="fc" id="L529">		aAMcurrentSymbol = Ttype.CONST;</span>
<span class="fc" id="L530">		k = 1;</span>
<span class="fc" id="L531">		st = slice(str, 0, 1);</span>
<span class="fc" id="L532">		boolean integ = true;</span>

<span class="pc bpc" id="L534" title="1 of 6 branches missed.">		while (&quot;0&quot;.compareTo(st) &lt;= 0 &amp;&amp; st.compareTo(&quot;9&quot;) &lt;= 0 &amp;&amp; k &lt;= str.length()) {</span>
<span class="fc" id="L535">			st = slice(str, k, k + 1);</span>
<span class="fc" id="L536">			k++;</span>
		}

<span class="fc bfc" id="L539" title="All 2 branches covered.">		if (st.equals(&quot;.&quot;)) {</span>
<span class="fc" id="L540">			st = slice(str, k, k + 1);</span>
<span class="pc bpc" id="L541" title="2 of 4 branches missed.">			if (&quot;0&quot;.compareTo(st) &lt;= 0 &amp;&amp; st.compareTo(&quot;9&quot;) &lt;= 0) {</span>
<span class="fc" id="L542">				integ = false;</span>
<span class="fc" id="L543">				k++;</span>
<span class="pc bpc" id="L544" title="1 of 6 branches missed.">				while (&quot;0&quot;.compareTo(st) &lt;= 0 &amp;&amp; st.compareTo(&quot;9&quot;) &lt;= 0 &amp;&amp; k &lt;= str.length()) {</span>
<span class="fc" id="L545">					st = slice(str, k, k + 1);</span>
<span class="fc" id="L546">					k++;</span>
				}
			}
		}
<span class="fc bfc" id="L550" title="All 6 branches covered.">		if ((integ &amp;&amp; k &gt; 1) || k &gt; 2) {</span>
<span class="fc" id="L551">			st = slice(str, 0, k - 1);</span>
<span class="fc" id="L552">			tagst = &quot;mn&quot;;</span>
		} else {
			//k = 2;
<span class="fc" id="L555">			st = slice(str, 0, 1); // take 1 character</span>
<span class="fc bfc" id="L556" title="All 4 branches covered.">			tagst = ((&quot;A&quot;.compareTo(st) &gt; 0 || st.compareTo(&quot;Z&quot;) &gt; 0)</span>
<span class="pc bpc" id="L557" title="1 of 4 branches missed.">					&amp;&amp; (&quot;a&quot;.compareTo(st) &gt; 0 || st.compareTo(&quot;z&quot;) &gt; 0) ? &quot;mo&quot; : &quot;mi&quot;);</span>
		}
<span class="fc bfc" id="L559" title="All 8 branches covered.">		if (st.equals(&quot;-&quot;) &amp;&amp; str.length() &gt; 1 &amp;&amp; str.charAt(1) != ' ' &amp;&amp; aAMpreviousSymbol == Ttype.INFIX) {</span>
<span class="fc" id="L560">			aAMcurrentSymbol = Ttype.INFIX;</span>
<span class="fc" id="L561">			return new Tuple(st, tagst, st, null, Ttype.UNARY, Flag.FUNC, Flag.VAL);</span>
		}
<span class="fc" id="L563">		return new Tuple(st, tagst, st, null, Ttype.CONST, Flag.VAL); // added val bit</span>
	}

	private String aAMTremoveBrackets(String node) {
		String st;
<span class="pc bpc" id="L568" title="1 of 6 branches missed.">		if (node.length() &gt; 1 &amp;&amp; node.charAt(0) == '{' &amp;&amp; node.charAt(node.length() - 1) == '}') {</span>
<span class="fc" id="L569">			int leftchop = 0;</span>

<span class="fc" id="L571">			st = substr(node, 1, 5);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">			if (st.equals(&quot;\\left&quot;)) {</span>
<span class="fc" id="L573">				st = &quot;&quot; + node.charAt(6);</span>
<span class="pc bpc" id="L574" title="1 of 6 branches missed.">				if (st.equals(&quot;(&quot;) || st.equals(&quot;[&quot;) || st.equals(&quot;{&quot;)) {</span>
<span class="fc" id="L575">					leftchop = 7;</span>
				} else {
<span class="fc" id="L577">					st = substr(node, 6, 7);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">					if (st.equals(&quot;\\lbrace&quot;)) {</span>
<span class="fc" id="L579">						leftchop = 13;</span>
					}
				}
			} else {
<span class="fc" id="L583">				st = &quot;&quot; + node.charAt(1);</span>
<span class="pc bpc" id="L584" title="1 of 4 branches missed.">				if (st.equals(&quot;(&quot;) || st.equals(&quot;[&quot;)) {</span>
<span class="fc" id="L585">					leftchop = 2;</span>
				}
			}
<span class="fc bfc" id="L588" title="All 4 branches covered.">			if (leftchop &gt; 0 &amp;&amp; node.length() &gt; 8) {</span>
<span class="fc" id="L589">				st = node.substring(node.length() - 8);</span>
<span class="pc bpc" id="L590" title="1 of 6 branches missed.">				if (st.equals(&quot;\\right)}&quot;) || st.equals(&quot;\\right]}&quot;) || st.equals(&quot;\\right.}&quot;)) {</span>
<span class="fc" id="L591">					node = &quot;{&quot; + node.substring(leftchop);</span>
<span class="fc" id="L592">					node = node.substring(0, node.length() - 8) + &quot;}&quot;;</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">				} else if (st.equals(&quot;\\rbrace}&quot;)) {</span>
<span class="fc" id="L594">					node = &quot;{&quot; + node.substring(leftchop);</span>
<span class="fc" id="L595">					node = node.substring(0, node.length() - 14) + &quot;}&quot;;</span>
				}
			}
		}
<span class="fc" id="L599">		return node;</span>
	}

	/* Parsing ASCII math expressions with the following grammar:
	v ::= [A-Za-z] | greek letters | numbers | other constant symbols
	u ::= sqrt | text | bb | other unary symbols for font commands
	b ::= frac | root | stackrel         binary symbols
	l ::= ( | [ | { | (: | {:            left brackets
	r ::= ) | ] | } | :) | :}            right brackets
	S ::= v | lEr | uS | bSS             Simple expression
	I ::= S_S | S^S | S_S^S | S          Intermediate expression
	E ::= IE | I/I                       Expression
	*/
	
	private String aAMTgetTeXsymbol(Tuple symb) {
		String pre;
<span class="fc bfc" id="L615" title="All 2 branches covered.">		if (symb.hasFlag(Flag.VAL)) {</span>
<span class="fc" id="L616">			pre = &quot;&quot;;</span>
		} else {
<span class="fc" id="L618">			pre = &quot;\\&quot;;</span>
		}
<span class="fc bfc" id="L620" title="All 2 branches covered.">		if (symb.tex == null) {</span>
			// can't remember why this was here. Breaks /delta /Delta to removed
			// return (pre+(pre==''?symb.input:symb.input.toLowerCase()));
<span class="fc" id="L623">			return (pre + symb.input);</span>
		} else {
<span class="fc" id="L625">			return (pre + symb.tex);</span>
		}
	}

	private String[] aAMTparseSexpr(String str) {
		Tuple symbol;
		int i;
		String node;
		String st;
<span class="fc" id="L634">		String newFrag = &quot;&quot;;</span>
		String[] result;
<span class="fc" id="L636">		str = aAMremoveCharsAndBlanks(str, 0);</span>
<span class="fc" id="L637">		symbol = aAMgetSymbol(str); // either a token or a bracket or empty</span>
<span class="pc bpc" id="L638" title="1 of 6 branches missed.">		if (symbol == null || symbol.ttype == Ttype.RIGHTBRACKET &amp;&amp; aAMnestingDepth &gt; 0) {</span>
<span class="fc" id="L639">			return new String[] { null, str };</span>
		}
<span class="fc bfc" id="L641" title="All 2 branches covered.">		if (symbol.ttype == Ttype.DEFINITION) {</span>
<span class="fc" id="L642">			str = symbol.output + aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L643">			symbol = aAMgetSymbol(str);</span>
		}
<span class="fc bfc" id="L645" title="All 9 branches covered.">		switch (symbol.ttype) {</span>
		case UNDEROVER:
		case CONST:
<span class="fc" id="L648">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L649">			String texsymbol = aAMTgetTeXsymbol(symbol);</span>
<span class="fc bfc" id="L650" title="All 6 branches covered.">			if (texsymbol.isEmpty() || texsymbol.charAt(0) == '\\' || symbol.tag.equals(&quot;mo&quot;))</span>
<span class="fc" id="L651">				return new String[] { texsymbol, str };</span>
			else {
<span class="fc" id="L653">				return new String[] { &quot;{&quot; + texsymbol + &quot;}&quot;, str };</span>
			}

		case LEFTBRACKET: // read (expr+)
<span class="fc" id="L657">			aAMnestingDepth++;</span>
<span class="fc" id="L658">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>

<span class="fc" id="L660">			result = aAMTparseExpr(str, true);</span>
<span class="fc" id="L661">			aAMnestingDepth--;</span>
<span class="fc" id="L662">			int leftchop = 0;</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">			if (substr(result[0], 0, 6).equals(&quot;\\right&quot;)) {</span>
<span class="fc" id="L664">				st = &quot;&quot; + result[0].charAt(6);</span>
<span class="pc bpc" id="L665" title="2 of 6 branches missed.">				if (st.equals(&quot;)&quot;) || st.equals(&quot;]&quot;) || st.equals(&quot;}&quot;)) {</span>
<span class="fc" id="L666">					leftchop = 6;</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">				} else if (st.equals(&quot;.&quot;)) {</span>
<span class="fc" id="L668">					leftchop = 7;</span>
				} else {
<span class="nc" id="L670">					st = substr(result[0], 6, 7);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">					if (st.equals(&quot;\\rbrace&quot;)) {</span>
<span class="nc" id="L672">						leftchop = 13;</span>
					}
				}
			}
<span class="fc bfc" id="L676" title="All 2 branches covered.">			if (leftchop &gt; 0) {</span>
<span class="fc" id="L677">				result[0] = result[0].substring(leftchop);</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">				if (symbol.hasFlag(Flag.INVISIBLE))</span>
<span class="fc" id="L679">					node = &quot;{&quot; + result[0] + &quot;}&quot;;</span>
				else {
<span class="fc" id="L681">					node = &quot;{&quot; + aAMTgetTeXsymbol(symbol) + result[0] + &quot;}&quot;;</span>
				}
			} else {
<span class="fc bfc" id="L684" title="All 2 branches covered.">				if (symbol.hasFlag(Flag.INVISIBLE))</span>
<span class="fc" id="L685">					node = &quot;{\\left.&quot; + result[0] + &quot;}&quot;;</span>
				else {
<span class="fc" id="L687">					node = &quot;{\\left&quot; + aAMTgetTeXsymbol(symbol) + result[0] + &quot;}&quot;;</span>
				}
			}
<span class="fc" id="L690">			return new String[] { node, result[1] };</span>

		case TEXT:
<span class="fc bfc" id="L693" title="All 2 branches covered.">			if (symbol != aAMquote)</span>
<span class="fc" id="L694">				str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">			if (str.charAt(0) == '{')</span>
<span class="fc" id="L696">				i = str.indexOf(&quot;}&quot;);</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">			else if (str.charAt(0) == '(')</span>
<span class="fc" id="L698">				i = str.indexOf(&quot;)&quot;);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">			else if (str.charAt(0) == '[')</span>
<span class="fc" id="L700">				i = str.indexOf(&quot;]&quot;);</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">			else if (symbol == aAMquote)</span>
<span class="fc" id="L702">				i = str.indexOf(&quot;\&quot;&quot;, 1);</span>
			else
<span class="fc" id="L704">				i = 0;</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">			if (i == -1)</span>
<span class="fc" id="L706">				i = str.length();</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">			if (i == 0) {</span>
<span class="fc" id="L708">				newFrag = &quot;\\text{&quot; + str.charAt(0) + &quot;}&quot;;</span>
			} else {
<span class="fc" id="L710">				st = str.substring(1, i);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">				if (st.charAt(0) == ' ') {</span>
<span class="fc" id="L712">					newFrag = &quot;\\ &quot;;</span>
				}
<span class="fc" id="L714">				newFrag += &quot;\\text{&quot; + st + &quot;}&quot;;</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">				if (st.charAt(st.length() - 1) == ' ') {</span>
<span class="fc" id="L716">					newFrag += &quot;\\ &quot;;</span>
				}
			}
<span class="fc bfc" id="L719" title="All 2 branches covered.">			if (i == str.length())</span>
<span class="fc" id="L720">				i = i - 1;</span>
<span class="fc" id="L721">			str = aAMremoveCharsAndBlanks(str, i + 1);</span>
<span class="fc" id="L722">			return new String[] { newFrag, str };</span>

		case UNARY:
<span class="fc" id="L725">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L726">			result = aAMTparseSexpr(str);</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">			if (result[0] == null)</span>
<span class="fc" id="L728">				return new String[] { &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;}&quot;, str };</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">			if (symbol.hasFlag(Flag.FUNC)) { // functions hack</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">				st = &quot;&quot; + (str.isEmpty() ? &quot;&quot; : str.charAt(0));</span>
<span class="pc bpc" id="L731" title="3 of 10 branches missed.">				if (st.equals(&quot;^&quot;) || st.equals(&quot;_&quot;) || st.equals(&quot;/&quot;) || st.equals(&quot;|&quot;) || st.equals(&quot;,&quot;)</span>
<span class="fc bfc" id="L732" title="All 6 branches covered.">						|| (symbol.input.length() == 1 &amp;&amp; symbol.input.matches(&quot;\\w&quot;) &amp;&amp; !st.equals(&quot;(&quot;))) {</span>
<span class="fc" id="L733">					return new String[] { &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;}&quot;, str };</span>
				} else {
<span class="fc" id="L735">					node = &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;{&quot; + result[0] + &quot;}}&quot;;</span>
<span class="fc" id="L736">					return new String[] { node, result[1] };</span>
				}
			}
<span class="fc" id="L739">			result[0] = aAMTremoveBrackets(result[0]);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">			if (symbol.input.equals(&quot;sqrt&quot;)) { // sqrt</span>
<span class="fc" id="L741">				return new String[] { &quot;\\sqrt{&quot; + result[0] + &quot;}&quot;, result[1] };</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">			} else if (symbol.input.equals(&quot;cancel&quot;)) { // cancel</span>
<span class="fc" id="L743">				return new String[] { &quot;\\cancel{&quot; + result[0] + &quot;}&quot;, result[1] };</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">			} else if (symbol.rewriteleftright != null) { // abs, floor, ceil</span>
<span class="fc" id="L745">				return new String[] { &quot;{\\left&quot; + symbol.rewriteleftright[0] + result[0] + &quot;\\right&quot;</span>
<span class="fc" id="L746">						+ symbol.rewriteleftright[1] + '}', result[1] };</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">			} else if (symbol.hasFlag(Flag.ACC)) { // accent</span>
<span class="fc" id="L748">				return new String[] { aAMTgetTeXsymbol(symbol) + &quot;{&quot; + result[0] + &quot;}&quot;, result[1] };</span>
			} else { // font change command
<span class="fc" id="L750">				return new String[] { &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;{&quot; + result[0] + &quot;}}&quot;, result[1] };</span>
			}
		case BINARY:
<span class="fc" id="L753">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L754">			result = aAMTparseSexpr(str);</span>
<span class="pc bpc" id="L755" title="1 of 2 branches missed.">			if (result[0] == null)</span>
<span class="nc" id="L756">				return new String[] { '{' + aAMTgetTeXsymbol(symbol) + '}', str };</span>
<span class="fc" id="L757">			result[0] = aAMTremoveBrackets(result[0]);</span>
<span class="fc" id="L758">			String[] result2 = aAMTparseSexpr(result[1]);</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">			if (result2[0] == null)</span>
<span class="nc" id="L760">				return new String[] { '{' + aAMTgetTeXsymbol(symbol) + '}', str };</span>
<span class="fc" id="L761">			result2[0] = aAMTremoveBrackets(result2[0]);</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">			if (symbol.input.equals(&quot;color&quot;)) {</span>
<span class="fc" id="L763">				newFrag = &quot;{\\color{&quot; + result[0].replaceAll(&quot;[\\{\\}]&quot;, &quot;&quot;) + &quot;}&quot; + result2[0] + &quot;}&quot;;</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">			} else if (symbol.input.equals(&quot;root&quot;)) {</span>
<span class="fc" id="L765">				newFrag = &quot;{\\sqrt[&quot; + result[0] + &quot;]{&quot; + result2[0] + &quot;}}&quot;;</span>
			} else {
<span class="fc" id="L767">				newFrag = &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;{&quot; + result[0] + &quot;}{&quot; + result2[0] + &quot;}}&quot;;</span>
			}
<span class="fc" id="L769">			return new String[] { newFrag, result2[1] };</span>
		case INFIX:
<span class="fc" id="L771">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L772">			return new String[] { symbol.output, str };</span>
		case SPACE:
<span class="fc" id="L774">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L775">			return new String[] { &quot;{\\quad\\text{&quot; + symbol.input + &quot;}\\quad}&quot;, str };</span>
		case LEFTRIGHT:
<span class="fc" id="L777">			aAMnestingDepth++;</span>
<span class="fc" id="L778">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L779">			result = aAMTparseExpr(str, false);</span>
<span class="fc" id="L780">			aAMnestingDepth--;</span>
<span class="fc" id="L781">			st = &quot;&quot; + result[0].charAt(result[0].length() - 1);</span>
<span class="fc bfc" id="L782" title="All 4 branches covered.">			if (st.equals(&quot;|&quot;) &amp;&amp; str.charAt(0) != ',') { // its an absolute value subterm</span>
<span class="fc" id="L783">				node = &quot;{\\left|&quot; + result[0] + &quot;}&quot;;</span>
<span class="fc" id="L784">				return new String[] { node, result[1] };</span>
			} else { // the &quot;|&quot; is a \mid
<span class="fc" id="L786">				node = &quot;{\\mid}&quot;;</span>
<span class="fc" id="L787">				return new String[] { node, str };</span>
			}
		default:
			// alert(&quot;default&quot;);
<span class="fc" id="L791">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L792">			return new String[] { &quot;{&quot; + aAMTgetTeXsymbol(symbol) + &quot;}&quot;, str };</span>
		}
	}

	private String[] aAMTparseIexpr(String str) {
		Tuple symbol;
		Tuple sym1;
		Tuple sym2;
		String[] result;
		String node;
<span class="fc" id="L802">		str = aAMremoveCharsAndBlanks(str, 0);</span>
<span class="fc" id="L803">		sym1 = aAMgetSymbol(str);</span>
<span class="fc" id="L804">		result = aAMTparseSexpr(str);</span>
<span class="fc" id="L805">		node = result[0];</span>
<span class="fc" id="L806">		str = result[1];</span>
<span class="fc" id="L807">		symbol = aAMgetSymbol(str);</span>
<span class="fc bfc" id="L808" title="All 4 branches covered.">		if (symbol.ttype == Ttype.INFIX &amp;&amp; !symbol.input.equals(&quot;/&quot;)) {</span>
<span class="fc" id="L809">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L810">			result = aAMTparseSexpr(str);</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">			if (result[0] == null) // show box in place of missing argument</span>
<span class="nc" id="L812">				result[0] = &quot;{}&quot;;</span>
			else
<span class="fc" id="L814">				result[0] = aAMTremoveBrackets(result[0]);</span>
<span class="fc" id="L815">			str = result[1];</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">			if (symbol.input.equals(&quot;_&quot;)) {</span>
<span class="fc" id="L817">				sym2 = aAMgetSymbol(str);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">				if (sym2.input.equals(&quot;^&quot;)) {</span>
<span class="fc" id="L819">					str = aAMremoveCharsAndBlanks(str, sym2.input.length());</span>
<span class="fc" id="L820">					String[] res2 = aAMTparseSexpr(str);</span>
<span class="fc" id="L821">					res2[0] = aAMTremoveBrackets(res2[0]);</span>
<span class="fc" id="L822">					str = res2[1];</span>
<span class="fc" id="L823">					node = &quot;{&quot; + node;</span>
<span class="fc" id="L824">					node += &quot;_{&quot; + result[0] + &quot;}&quot;;</span>
<span class="fc" id="L825">					node += &quot;^{&quot; + res2[0] + &quot;}&quot;;</span>
<span class="fc" id="L826">					node += &quot;}&quot;;</span>
<span class="fc" id="L827">				} else {</span>
<span class="fc" id="L828">					node += &quot;_{&quot; + result[0] + &quot;}&quot;;</span>
				}
			} else { // must be ^
<span class="fc" id="L831">				node = node + &quot;^{&quot; + result[0] + &quot;}&quot;;</span>
			}
<span class="fc bfc" id="L833" title="All 2 branches covered.">			if (sym1.hasFlag(Flag.FUNC)) {</span>
<span class="fc" id="L834">				sym2 = aAMgetSymbol(str);</span>
<span class="pc bpc" id="L835" title="2 of 4 branches missed.">				if (sym2.ttype != Ttype.INFIX &amp;&amp; sym2.ttype != Ttype.RIGHTBRACKET &amp;&amp;</span>
<span class="fc bfc" id="L836" title="All 4 branches covered.">					(sym1.input.length() &gt; 1 || sym2.ttype == Ttype.LEFTBRACKET)) {</span>
<span class="fc" id="L837">					result = aAMTparseIexpr(str);</span>
<span class="fc" id="L838">					node = &quot;{&quot; + node + result[0] + &quot;}&quot;;</span>
<span class="fc" id="L839">					str = result[1];</span>
				}
			}
		}
<span class="fc" id="L843">		return new String[] { node, str };</span>
	}

	private String[] aAMTparseExpr(String str, boolean rightbracket) {
		String[] result;
		Tuple symbol;
		String node;
		// var symbol, node, result, i, nodeList = [],
<span class="fc" id="L851">		String newFrag = &quot;&quot;;</span>
<span class="fc" id="L852">		boolean addedright = false;</span>
		do {
<span class="fc" id="L854">			str = aAMremoveCharsAndBlanks(str, 0);</span>
<span class="fc" id="L855">			result = aAMTparseIexpr(str);</span>
<span class="fc" id="L856">			node = result[0];</span>
<span class="fc" id="L857">			str = result[1];</span>
<span class="fc" id="L858">			symbol = aAMgetSymbol(str);</span>

<span class="fc bfc" id="L860" title="All 4 branches covered.">			if (symbol.ttype == Ttype.INFIX &amp;&amp; symbol.input.equals(&quot;/&quot;)) {</span>
<span class="fc" id="L861">				str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc" id="L862">				result = aAMTparseIexpr(str);</span>

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">				if (result[0] == null) // show box in place of missing argument</span>
<span class="nc" id="L865">					result[0] = &quot;{}&quot;;</span>
				else
<span class="fc" id="L867">					result[0] = aAMTremoveBrackets(result[0]);</span>
<span class="fc" id="L868">				str = result[1];</span>
<span class="fc" id="L869">				node = aAMTremoveBrackets(node);</span>
<span class="fc" id="L870">				node = &quot;\\frac&quot; + &quot;{&quot; + node + &quot;}&quot;;</span>
<span class="fc" id="L871">				node += &quot;{&quot; + result[0] + &quot;}&quot;;</span>
<span class="fc" id="L872">				newFrag += node;</span>
<span class="fc" id="L873">				symbol = aAMgetSymbol(str);</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">			} else if (node != null)</span>
<span class="fc" id="L875">				newFrag += node;</span>

<span class="fc bfc" id="L877" title="All 8 branches covered.">		} while ((((symbol.ttype != Ttype.RIGHTBRACKET) &amp;&amp; (symbol.ttype != Ttype.LEFTRIGHT || rightbracket))</span>
<span class="fc bfc" id="L878" title="All 4 branches covered.">				|| aAMnestingDepth == 0) &amp;&amp; (symbol.output == null || !symbol.output.equals(&quot;&quot;)));</span>

<span class="fc bfc" id="L880" title="All 4 branches covered.">		if (symbol.ttype == Ttype.RIGHTBRACKET || symbol.ttype == Ttype.LEFTRIGHT) {</span>
<span class="fc" id="L881">			int len = newFrag.length();</span>
<span class="fc bfc" id="L882" title="All 6 branches covered.">			if (len &gt; 2 &amp;&amp; newFrag.charAt(0) == '{' &amp;&amp; newFrag.indexOf(',') &gt; 0) {</span>
<span class="fc" id="L883">				char right = newFrag.charAt(len - 2);</span>
<span class="fc bfc" id="L884" title="All 4 branches covered.">				if (right == ')' || right == ']') {</span>
<span class="fc" id="L885">					char left = newFrag.charAt(6);</span>
<span class="pc bpc" id="L886" title="4 of 10 branches missed.">					if ((left == '(' &amp;&amp; right == ')' &amp;&amp; !symbol.output.equals(&quot;}&quot;)) || (left == '[' &amp;&amp; right == ']')) {</span>
<span class="fc" id="L887">						String mxout = &quot;&quot;;</span>
<span class="fc" id="L888">						List&lt;Integer&gt; pos = new ArrayList&lt;&gt;(); // position of commas</span>
<span class="fc" id="L889">						pos.add(0);</span>
<span class="fc" id="L890">						boolean matrix = true;</span>
<span class="fc" id="L891">						int mxnestingd = 0;</span>
<span class="fc" id="L892">						List&lt;List&lt;Integer&gt;&gt; subpos = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L893">						subpos.add(new ArrayList&lt;&gt;(Arrays.asList(0)));</span>
<span class="fc" id="L894">						int lastsubposstart = 0;</span>
<span class="fc" id="L895">						int mxanynestingd = 0;</span>
<span class="fc" id="L896">						String columnaligns = &quot;&quot;;</span>

<span class="fc bfc" id="L898" title="All 2 branches covered.">						for (int i = 1; i &lt; len - 1; i++) {</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">							if (newFrag.charAt(i) == left)</span>
<span class="fc" id="L900">								mxnestingd++;</span>
<span class="fc bfc" id="L901" title="All 2 branches covered.">							if (newFrag.charAt(i) == right) {</span>
<span class="fc" id="L902">								mxnestingd--;</span>
<span class="pc bpc" id="L903" title="2 of 6 branches missed.">								if (mxnestingd == 0 &amp;&amp; i + 3 &lt; newFrag.length() &amp;&amp; newFrag.charAt(i + 2) == ','</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">										&amp;&amp; newFrag.charAt(i + 3) == '{') {</span>
<span class="fc" id="L905">									pos.add(i + 2);</span>
<span class="fc" id="L906">									lastsubposstart = i + 2;</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">									while (subpos.size() &lt;= lastsubposstart)</span>
<span class="fc" id="L908">										subpos.add(null);</span>
<span class="fc" id="L909">									subpos.set(lastsubposstart, new ArrayList&lt;&gt;(Arrays.asList(i + 2)));</span>
								}
							}
<span class="fc bfc" id="L912" title="All 6 branches covered.">							if (newFrag.charAt(i) == '[' || newFrag.charAt(i) == '(' || newFrag.charAt(i) == '{') {</span>
<span class="fc" id="L913">								mxanynestingd++;</span>
							}
<span class="fc bfc" id="L915" title="All 6 branches covered.">							if (newFrag.charAt(i) == ']' || newFrag.charAt(i) == ')' || newFrag.charAt(i) == '}') {</span>
<span class="fc" id="L916">								mxanynestingd--;</span>
							}
<span class="pc bpc" id="L918" title="1 of 4 branches missed.">							if (newFrag.charAt(i) == ',' &amp;&amp; mxanynestingd == 1) {</span>
<span class="fc" id="L919">								subpos.get(lastsubposstart).add(i);</span>
							}
<span class="fc bfc" id="L921" title="All 2 branches covered.">							if (mxanynestingd &lt; 0) { // happens at the end of the row</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">								if (lastsubposstart == i + 1) { // if at end of row, skip to next row</span>
<span class="fc" id="L923">									i++;</span>
								} else { // misformed something - abandon treating as a matrix
<span class="nc" id="L925">									matrix = false;</span>
								}
							}
						}

<span class="fc" id="L930">						pos.add(len);</span>
<span class="fc" id="L931">						int lastmxsubcnt = -1;</span>
<span class="pc bpc" id="L932" title="3 of 6 branches missed.">						if (mxnestingd == 0 &amp;&amp; !pos.isEmpty() &amp;&amp; matrix) {</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">							for (int i = 0; i &lt; pos.size() - 1; i++) {</span>
<span class="fc" id="L934">								List&lt;String&gt; subarr = null;</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">								if (i &gt; 0)</span>
<span class="fc" id="L936">									mxout += &quot;\\\\&quot;;</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">								if (i == 0) {</span>
									// var subarr = newFrag.substr(pos[i]+7,pos[i+1]-pos[i]-15).split(',');
<span class="fc bfc" id="L939" title="All 2 branches covered.">									if (subpos.get(pos.get(i)).size() == 1) {</span>
<span class="fc" id="L940">										subarr = new ArrayList&lt;&gt;(Arrays.asList(</span>
<span class="fc" id="L941">												substr(newFrag, pos.get(i) + 7, pos.get(i + 1) - pos.get(i) - 15)));</span>
									} else {
<span class="fc" id="L943">										subarr = new ArrayList&lt;&gt;(Arrays.asList(</span>
<span class="fc" id="L944">												newFrag.substring(pos.get(i) + 7, subpos.get(pos.get(i)).get(1))));</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">										for (int j = 2; j &lt; subpos.get(pos.get(i)).size(); j++) {</span>
<span class="fc" id="L946">											subarr.add(newFrag.substring(subpos.get(pos.get(i)).get(j - 1) + 1,</span>
<span class="fc" id="L947">													subpos.get(pos.get(i)).get(j)));</span>
										}
<span class="fc" id="L949">										subarr.add(newFrag.substring(</span>
<span class="fc" id="L950">												subpos.get(pos.get(i)).get(subpos.get(pos.get(i)).size() - 1) + 1,</span>
<span class="fc" id="L951">												pos.get(i + 1) - 8));</span>
									}
								} else {
									// var subarr = newFrag.substr(pos[i]+8,pos[i+1]-pos[i]-16).split(',');
<span class="fc bfc" id="L955" title="All 2 branches covered.">									if (subpos.get(pos.get(i)).size() == 1) {</span>
<span class="fc" id="L956">										subarr = new ArrayList&lt;&gt;(Arrays.asList(</span>
<span class="fc" id="L957">												substr(newFrag, pos.get(i) + 8, pos.get(i + 1) - pos.get(i) - 16)));</span>
									} else {
<span class="fc" id="L959">										subarr = new ArrayList&lt;&gt;(Arrays.asList(</span>
<span class="fc" id="L960">												newFrag.substring(pos.get(i) + 8, subpos.get(pos.get(i)).get(1))));</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">										for (int j = 2; j &lt; subpos.get(pos.get(i)).size(); j++) {</span>
<span class="fc" id="L962">											subarr.add(newFrag.substring(subpos.get(pos.get(i)).get(j - 1) + 1,</span>
<span class="fc" id="L963">												subpos.get(pos.get(i)).get(j)));</span>
										}
<span class="fc" id="L965">										subarr.add(newFrag.substring(</span>
<span class="fc" id="L966">												subpos.get(pos.get(i)).get(subpos.get(pos.get(i)).size() - 1) + 1,</span>
<span class="fc" id="L967">												pos.get(i + 1) - 8));</span>
									}
								} 
<span class="fc bfc" id="L970" title="All 2 branches covered.">								for (int j = subarr.size() - 1; j &gt;= 0; j--) {</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">									if (subarr.get(j).equals(&quot;{\\mid}&quot;)) {</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">										if (i == 0) {</span>
<span class="fc" id="L973">											columnaligns = &quot;|&quot; + columnaligns;</span>
										}
<span class="fc" id="L975">										subarr.remove(j);</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">									} else if (i == 0) {</span>
<span class="fc" id="L977">										columnaligns = &quot;c&quot; + columnaligns;</span>
									}
								}
<span class="fc bfc" id="L980" title="All 4 branches covered.">								if (lastmxsubcnt &gt; 0 &amp;&amp; subarr.size() != lastmxsubcnt) {</span>
<span class="fc" id="L981">									matrix = false;</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">								} else if (lastmxsubcnt == -1) {</span>
<span class="fc" id="L983">									lastmxsubcnt = subarr.size();</span>
								}
								// mxout += subarr.join('&amp;');
<span class="fc bfc" id="L986" title="All 2 branches covered.">								for (int z = 0; z &lt; subarr.size(); z++) {</span>
<span class="fc" id="L987">									mxout += subarr.get(z);</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">									if (z &lt; subarr.size() - 1)</span>
<span class="fc" id="L989">										mxout += &quot;&amp;&quot;;</span>
								}
							}
						}
<span class="fc" id="L993">						mxout = &quot;\\begin{array}{&quot; + columnaligns + &quot;} &quot; + mxout + &quot;\\end{array}&quot;;</span>

<span class="fc bfc" id="L995" title="All 2 branches covered.">						if (matrix) {</span>
<span class="fc" id="L996">							newFrag = mxout;</span>
						}
					}
				}
			}
<span class="fc" id="L1001">			str = aAMremoveCharsAndBlanks(str, symbol.input.length());</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">			if (!symbol.hasFlag(Flag.INVISIBLE)) {</span>
<span class="fc" id="L1003">				node = &quot;\\right&quot; + aAMTgetTeXsymbol(symbol);</span>
<span class="fc" id="L1004">				newFrag += node;</span>
<span class="fc" id="L1005">				addedright = true;</span>
			} else {
<span class="fc" id="L1007">				newFrag += &quot;\\right.&quot;;</span>
<span class="fc" id="L1008">				addedright = true;</span>
			}
		}
<span class="fc bfc" id="L1011" title="All 4 branches covered.">		if (aAMnestingDepth &gt; 0 &amp;&amp; !addedright) {</span>
<span class="fc" id="L1012">			newFrag += &quot;\\right.&quot;; // adjust for non-matching left brackets</span>
			// todo: adjust for non-matching right brackets
		}
<span class="fc" id="L1015">		return new String[] { newFrag, str };</span>
	}

	private String patchColor(String latex) {
<span class="fc" id="L1019">		return latex.replace(&quot;\\color{&quot;, &quot;\\textcolor{&quot;);</span>
	}

	public String getTeX(String asciiMathInput) {
<span class="fc" id="L1023">		aAMnestingDepth = 0;</span>
<span class="fc" id="L1024">		aAMpreviousSymbol = Ttype.CONST;</span>
<span class="fc" id="L1025">		aAMcurrentSymbol = Ttype.CONST;</span>
<span class="fc" id="L1026">		final String result = aAMTparseExpr(asciiMathInput, false)[0];</span>
<span class="fc" id="L1027">		return patchColor(result);</span>
	}

	static {
<span class="fc" id="L1031">		aAMinitSymbols();</span>
<span class="fc" id="L1032">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>