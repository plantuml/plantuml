<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SFile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.security</a> &gt; <span class="el_source">SFile.java</span></div><h1>SFile.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 * 
 *
 */
package net.sourceforge.plantuml.security;

import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.net.URI;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import javax.imageio.stream.ImageInputStream;
import javax.swing.ImageIcon;

import net.sourceforge.plantuml.log.Logme;
import net.sourceforge.plantuml.nio.InputFile;
import net.sourceforge.plantuml.nio.NFolder;
import net.sourceforge.plantuml.nio.NFolderRegular;

/**
 * Secure replacement for java.io.File.
 * &lt;p&gt;
 * This class should be used instead of java.io.File. There are few exceptions
 * (mainly in the Swing part and in the ANT task)
 * &lt;p&gt;
 * This class does some control access and in secure mode hide the real path of
 * file, so that it cannot be printed to end users.
 *
 */
public class SFile implements Comparable&lt;SFile&gt;, InputFile {

<span class="fc" id="L79">	public static final String separator = File.separator;</span>

<span class="fc" id="L81">	public static final String pathSeparator = File.pathSeparator;</span>

<span class="fc" id="L83">	public static final char separatorChar = File.separatorChar;</span>

	private final File internal;

	@Override
	public String toString() {
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">				|| SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)</span>
<span class="nc" id="L91">			return super.toString();</span>
		try {
<span class="nc" id="L93">			return internal.getCanonicalPath();</span>
<span class="nc" id="L94">		} catch (IOException e) {</span>
<span class="nc" id="L95">			return internal.getAbsolutePath();</span>
		}
	}

	public SFile(String nameOrPath) {
<span class="fc" id="L100">		this(new File(nameOrPath));</span>
<span class="fc" id="L101">	}</span>

	public SFile(String dirname, String name) {
<span class="nc" id="L104">		this(new File(dirname, name));</span>
<span class="nc" id="L105">	}</span>

	public SFile(SFile basedir, String name) {
<span class="fc" id="L108">		this(new File(basedir.internal, name));</span>
<span class="fc" id="L109">	}</span>

	public SFile(URI uri) {
<span class="fc" id="L112">		this(new File(uri));</span>
<span class="fc" id="L113">	}</span>

<span class="fc" id="L115">	private SFile(File internal) {</span>
<span class="fc" id="L116">		this.internal = internal;</span>
<span class="fc" id="L117">	}</span>

	public static SFile fromFile(File internal) {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		if (internal == null)</span>
<span class="nc" id="L121">			return null;</span>

<span class="fc" id="L123">		return new SFile(internal);</span>
	}

	public SFile file(String name) {
<span class="fc" id="L127">		return new SFile(this, name);</span>
	}

	public boolean exists() {
<span class="pc bpc" id="L131" title="1 of 4 branches missed.">		if (internal != null &amp;&amp; isFileOk())</span>
<span class="fc" id="L132">			return internal.exists();</span>
<span class="fc" id="L133">		return false;</span>
	}

	public SFile getCanonicalFile() throws IOException {
<span class="fc" id="L137">		return new SFile(internal.getCanonicalFile());</span>
	}

	public boolean isAbsolute() {
<span class="pc bpc" id="L141" title="2 of 4 branches missed.">		return internal != null &amp;&amp; internal.isAbsolute();</span>
	}

	public boolean isDirectory() {
<span class="pc bpc" id="L145" title="1 of 6 branches missed.">		return internal != null &amp;&amp; internal.exists() &amp;&amp; internal.isDirectory();</span>
	}

	public String getName() {
<span class="fc" id="L149">		return internal.getName();</span>
	}

	public boolean isFile() {
<span class="nc bnc" id="L153" title="All 4 branches missed.">		return internal != null &amp;&amp; internal.isFile();</span>
	}

	public long lastModified() {
<span class="nc" id="L157">		return internal.lastModified();</span>
	}

	public int compareTo(SFile other) {
<span class="nc" id="L161">		return this.internal.compareTo(other.internal);</span>
	}

//	public String getPath() {
//		return internal.getPath();
//	}

	public long length() {
<span class="fc" id="L169">		return internal.length();</span>
	}

	public boolean canWrite() {
<span class="fc" id="L173">		return internal.canWrite();</span>
	}

	public void setWritable(boolean b) {
<span class="fc" id="L177">		internal.setWritable(b);</span>
<span class="fc" id="L178">	}</span>

	public void delete() {
<span class="fc" id="L181">		internal.delete();</span>
<span class="fc" id="L182">	}</span>

//	public Collection&lt;SFile&gt; listFiles() {
//		final File[] tmp = internal.listFiles();
//		if (tmp == null)
//			return Collections.emptyList();
//
//		final List&lt;SFile&gt; result = new ArrayList&lt;&gt;(tmp.length);
//		for (File f : tmp)
//			result.add(new SFile(f));
//
//		return Collections.unmodifiableCollection(result);
//	}

	public String[] list() {
<span class="fc" id="L197">		return internal.list();</span>
	}

	public SFile getAbsoluteFile() {
<span class="fc" id="L201">		return new SFile(internal.getAbsoluteFile());</span>
	}

	public SFile getParentFile() {
<span class="fc" id="L205">		return new SFile(internal.getParentFile());</span>
	}

	@Override
	public int hashCode() {
<span class="nc" id="L210">		return internal.hashCode();</span>
	}

	@Override
	public boolean equals(Object obj) {
<span class="nc" id="L215">		return internal.equals(((SFile) obj).internal);</span>
	}

	public String getAbsolutePath() {
<span class="fc" id="L219">		return internal.getAbsolutePath();</span>
	}

	public String getPrintablePath() {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">		if (SecurityUtils.getSecurityProfile() == SecurityProfile.UNSECURE) {</span>
			try {
<span class="nc" id="L225">				return internal.getCanonicalPath();</span>
<span class="nc" id="L226">			} catch (IOException e) {</span>
<span class="nc" id="L227">				Logme.error(e);</span>
			}
		}
<span class="fc" id="L230">		return &quot;&quot;;</span>
	}

	public boolean canRead() {
<span class="fc bfc" id="L234" title="All 2 branches covered.">		if (exists())</span>
<span class="fc" id="L235">			return internal.canRead();</span>
<span class="fc" id="L236">		return false;</span>
	}

	public void deleteOnExit() {
<span class="nc" id="L240">		internal.deleteOnExit();</span>
<span class="nc" id="L241">	}</span>

	public void mkdirs() {
<span class="fc" id="L244">		internal.mkdirs();</span>
<span class="fc" id="L245">	}</span>

	public static SFile createTempFile(String prefix, String suffix) throws IOException {
<span class="nc" id="L248">		return new SFile(File.createTempFile(prefix, suffix));</span>
	}

	public URI toURI() {
<span class="fc" id="L252">		return internal.toURI();</span>
	}

	public boolean renameTo(SFile dest) {
<span class="fc" id="L256">		return internal.renameTo(dest.internal);</span>
	}

	/**
	 * Check SecurityProfile to see if this file can be open.
	 */
	public boolean isFileOk() {
		// ::comment when __CORE__
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">		if (SecurityUtils.getSecurityProfile() == SecurityProfile.SANDBOX)</span>
			// In SANDBOX, we cannot read any files
<span class="nc" id="L266">			return false;</span>

		// In any case SFile should not access the security folders
		// (the files must be handled internally)
		try {
<span class="fc bfc" id="L271" title="All 2 branches covered.">			if (isDenied())</span>
<span class="fc" id="L272">				return false;</span>
<span class="nc" id="L273">		} catch (IOException e) {</span>
<span class="nc" id="L274">			return false;</span>
<span class="fc" id="L275">		}</span>
		// Files in &quot;plantuml.include.path&quot; and &quot;plantuml.allowlist.path&quot; are ok.
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">		if (isInAllowList(SecurityUtils.getPath(SecurityUtils.PATHS_INCLUDES)))</span>
<span class="nc" id="L278">			return true;</span>

<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		if (isInAllowList(SecurityUtils.getPath(SecurityUtils.ALLOWLIST_LOCAL_PATHS)))</span>
<span class="nc" id="L281">			return true;</span>

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">		if (SecurityUtils.getSecurityProfile() == SecurityProfile.INTERNET)</span>
<span class="nc" id="L284">			return false;</span>

<span class="pc bpc" id="L286" title="1 of 2 branches missed.">		if (SecurityUtils.getSecurityProfile() == SecurityProfile.ALLOWLIST)</span>
<span class="nc" id="L287">			return false;</span>

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if (SecurityUtils.getSecurityProfile() != SecurityProfile.UNSECURE) {</span>
			// For UNSECURE, we did not do those checks
<span class="fc" id="L291">			final String path = getCleanPathSecure();</span>
<span class="pc bpc" id="L292" title="3 of 6 branches missed.">			if (path.startsWith(&quot;/etc/&quot;) || path.startsWith(&quot;/dev/&quot;) || path.startsWith(&quot;/boot/&quot;)</span>
<span class="pc bpc" id="L293" title="2 of 4 branches missed.">					|| path.startsWith(&quot;/proc/&quot;) || path.startsWith(&quot;/sys/&quot;))</span>
<span class="nc" id="L294">				return false;</span>

<span class="pc bpc" id="L296" title="1 of 2 branches missed.">			if (path.startsWith(&quot;//&quot;))</span>
<span class="nc" id="L297">				return false;</span>

		}
		// ::done
<span class="fc" id="L301">		return true;</span>
	}

	private boolean isInAllowList(List&lt;SFile&gt; allowlist) {
<span class="fc" id="L305">		final String path = getCleanPathSecure();</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">		for (SFile allow : allowlist)</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			if (path.startsWith(allow.getCleanPathSecure()))</span>
				// File directory is in the allowlist
<span class="nc" id="L309">				return true;</span>

<span class="fc" id="L311">		return false;</span>
	}

	/**
	 * Checks, if the SFile is inside the folder (-structure) of the security area.
	 *
	 * @return true, if the file is not allowed to read/write
	 * @throws IOException If an I/O error occurs, which is possible because the
	 *                     check the pathname may require filesystem queries
	 */
	// ::comment when __CORE__
	private boolean isDenied() throws IOException {
<span class="fc" id="L323">		final SFile securityPath = SecurityUtils.getSecurityPath();</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">		if (securityPath == null)</span>
<span class="fc" id="L325">			return false;</span>
<span class="fc" id="L326">		return getSanitizedPath().startsWith(securityPath.getSanitizedPath());</span>
	}
	// ::done

	/**
	 * Returns a sanitized, canonical and normalized Path to a file.
	 *
	 * @return the Path
	 * @throws IOException If an I/O error occurs, which is possible because the
	 *                     construction of the canonical pathname may require
	 *                     filesystem queries
	 * @see #getCleanPathSecure()
	 * @see File#getCanonicalPath()
	 * @see Path#normalize()
	 */
	private Path getSanitizedPath() throws IOException {
<span class="fc" id="L342">		return Paths.get(new File(getCleanPathSecure()).getCanonicalPath()).normalize();</span>
	}

	private String getCleanPathSecure() {
<span class="fc" id="L346">		String result = internal.getAbsolutePath();</span>
<span class="fc" id="L347">		result = result.replace(&quot;\0&quot;, &quot;&quot;);</span>
<span class="fc" id="L348">		result = result.replace(&quot;\\\\&quot;, &quot;/&quot;);</span>
<span class="fc" id="L349">		return result;</span>
	}

	// Reading
	// http://forum.plantuml.net/9048/img-tag-for-sequence-diagram-participants-does-always-render
	public BufferedImage readRasterImageFromFile() {
		// https://www.experts-exchange.com/questions/26171948/Why-are-ImageIO-read-images-losing-their-transparency.html
		// https://stackoverflow.com/questions/18743790/can-java-load-images-with-transparency
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (isFileOk())</span>
			try {
				// ::comment when __CORE__
<span class="nc bnc" id="L360" title="All 2 branches missed.">				if (internal.getName().endsWith(&quot;.webp&quot;))</span>
<span class="nc" id="L361">					return readWebp();</span>
				else
					// ::done
<span class="nc" id="L364">					return SecurityUtils.readRasterImage(new ImageIcon(this.getAbsolutePath()));</span>
<span class="nc" id="L365">			} catch (Exception e) {</span>
<span class="nc" id="L366">				Logme.error(e);</span>
			}
<span class="nc" id="L368">		return null;</span>
	}

	// ::comment when __CORE__
	private BufferedImage readWebp() throws IOException {
<span class="nc" id="L373">		try (InputStream is = openFile()) {</span>
<span class="nc" id="L374">			final int riff = read32(is);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">			if (riff != 0x46464952)</span>
<span class="nc" id="L376">				return null;</span>
<span class="nc" id="L377">			final int len1 = read32(is);</span>
<span class="nc" id="L378">			final int webp = read32(is);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			if (webp != 0x50424557)</span>
<span class="nc" id="L380">				return null;</span>
<span class="nc" id="L381">			final int vp8_ = read32(is);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">			if (vp8_ != 0x20385056)</span>
<span class="nc" id="L383">				return null;</span>
<span class="nc" id="L384">			final int len2 = read32(is);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			if (len1 != len2 + 12)</span>
<span class="nc" id="L386">				return null;</span>

<span class="nc" id="L388">			return getBufferedImageFromWebpButHeader(is);</span>
<span class="nc bnc" id="L389" title="All 8 branches missed.">		}</span>
	}

	private int read32(InputStream is) throws IOException {
<span class="nc" id="L393">		return (is.read() &lt;&lt; 0) + (is.read() &lt;&lt; 8) + (is.read() &lt;&lt; 16) + (is.read() &lt;&lt; 24);</span>
	}

	public static BufferedImage getBufferedImageFromWebpButHeader(InputStream is) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">		if (is == null)</span>
<span class="nc" id="L398">			return null;</span>
		try {
<span class="nc" id="L400">			final Class&lt;?&gt; clVP8Decoder = Class.forName(&quot;net.sourceforge.plantuml.webp.VP8Decoder&quot;);</span>
<span class="nc" id="L401">			final Object vp8Decoder = clVP8Decoder.getDeclaredConstructor().newInstance();</span>
			// final VP8Decoder vp8Decoder = new VP8Decoder();
<span class="nc" id="L403">			final Method decodeFrame = clVP8Decoder.getMethod(&quot;decodeFrame&quot;, ImageInputStream.class);</span>
<span class="nc" id="L404">			final ImageInputStream iis = SImageIO.createImageInputStream(is);</span>
<span class="nc" id="L405">			decodeFrame.invoke(vp8Decoder, iis);</span>
			// vp8Decoder.decodeFrame(iis);
<span class="nc" id="L407">			iis.close();</span>
<span class="nc" id="L408">			final Object frame = clVP8Decoder.getMethod(&quot;getFrame&quot;).invoke(vp8Decoder);</span>
<span class="nc" id="L409">			return (BufferedImage) frame.getClass().getMethod(&quot;getBufferedImage&quot;).invoke(frame);</span>
			// final VP8Frame frame = vp8Decoder.getFrame();
			// return frame.getBufferedImage();
<span class="nc" id="L412">		} catch (Exception e) {</span>
<span class="nc" id="L413">			Logme.error(e);</span>
<span class="nc" id="L414">			return null;</span>
		}
	}
	// ::done

	public BufferedReader openBufferedReader() {
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">		if (isFileOk()) {</span>
			try {
<span class="fc" id="L422">				return new BufferedReader(new FileReader(internal));</span>
<span class="nc" id="L423">			} catch (FileNotFoundException e) {</span>
<span class="nc" id="L424">				Logme.error(e);</span>
			}
		}
<span class="nc" id="L427">		return null;</span>
	}

	public File conv() {
<span class="fc" id="L431">		return internal;</span>
	}

	public InputStream openFile() {
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">		if (isFileOk())</span>
			try {
<span class="fc" id="L437">				return new BufferedInputStream(new FileInputStream(internal));</span>
<span class="nc" id="L438">			} catch (FileNotFoundException e) {</span>
<span class="nc" id="L439">				Logme.error(e);</span>
			}
<span class="nc" id="L441">		return null;</span>
	}

	// ::comment when __CORE__
	// Writing
	public BufferedOutputStream createBufferedOutputStream() throws FileNotFoundException {
<span class="fc" id="L447">		return new BufferedOutputStream(new FileOutputStream(internal));</span>
	}

	public PrintWriter createPrintWriter() throws FileNotFoundException {
<span class="fc" id="L451">		return new PrintWriter(internal);</span>
	}

	public PrintWriter createPrintWriter(String charset) throws FileNotFoundException, UnsupportedEncodingException {
<span class="fc" id="L455">		return new PrintWriter(internal, charset);</span>
	}

	public FileOutputStream createFileOutputStream() throws FileNotFoundException {
<span class="nc" id="L459">		return new FileOutputStream(internal);</span>
	}

	public PrintStream createPrintStream() throws FileNotFoundException {
<span class="nc" id="L463">		return new PrintStream(internal);</span>
	}

	public PrintStream createPrintStream(Charset charset) throws FileNotFoundException, UnsupportedEncodingException {
<span class="nc" id="L467">		return new PrintStream(internal, charset.name());</span>
	}
	// ::done

	@Override
	public InputStream newInputStream() {
<span class="fc" id="L473">		return openFile();</span>
	}

	@Override
	public NFolder getParentFolder() throws IOException {
<span class="fc" id="L478">		return new NFolderRegular(getSanitizedPath().getParent());</span>
	}

	public Path toPath() throws IOException {
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">		if (isFileOk())</span>
<span class="fc" id="L483">			return getSanitizedPath();</span>
<span class="nc" id="L484">		return null;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>