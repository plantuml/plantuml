<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Quantify555.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.png.quant</a> &gt; <span class="el_source">Quantify555.java</span></div><h1>Quantify555.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 * With assistance from ChatGPT (OpenAI)
 *
 */
package net.sourceforge.plantuml.png.quant;

import java.awt.image.BufferedImage;
import java.awt.image.IndexColorModel;
import java.awt.image.WritableRaster;
import java.util.Arrays;

import net.sourceforge.plantuml.utils.Log;

/**
 * A simple color quantizer based on RGB555 cubes.
 *
 * &lt;p&gt;
 * &lt;b&gt;Process:&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;ol&gt;
 * &lt;li&gt;Each pixel is mapped to a 15-bit cube index (RGB555).&lt;/li&gt;
 * &lt;li&gt;Inside the cube, a 9-bit sub-color index (0–511) is computed.&lt;/li&gt;
 * &lt;li&gt;Frequencies of sub-colors are accumulated in each cube.&lt;/li&gt;
 * &lt;li&gt;If more than 255 distinct cubes are populated, quantization aborts (since
 * the palette would exceed 256 colors).&lt;/li&gt;
 * &lt;li&gt;For each cube, the most frequent sub-color is selected as the
 * representative palette entry.&lt;/li&gt;
 * &lt;li&gt;An {@link IndexColorModel} is built and an 8-bit indexed image is
 * generated.&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * &lt;p&gt;
 * &lt;b&gt;Comparison to other algorithms:&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Median Cut:&lt;/b&gt; Splits color space adaptively based on variance.
 * Produces better palettes on natural images (gradients, photos), but more
 * expensive computationally.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Wu's Algorithm:&lt;/b&gt; Uses variance minimization and dynamic
 * programming. Produces very high-quality palettes (similar to pngquant), but
 * requires more memory and preprocessing.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;RGB555 Cube Quantizer (this class):&lt;/b&gt; Extremely fast, deterministic,
 * and simple. Well-suited for diagrams, icons, or graphics with limited colors.
 * However, palette quality is generally inferior to Wu or Median Cut,
 * especially for gradients and photos.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;Advantages:&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Very fast: one pass to count, one pass to remap pixels.&lt;/li&gt;
 * &lt;li&gt;Simple and predictable (no recursion, no complex math).&lt;/li&gt;
 * &lt;li&gt;Guaranteed &lt;= 256 colors (or aborts safely).&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * rules for transparency:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;any pixel with alpha less than 127 is considered fully transparent and
 * mapped to ARGB 0x00000000.&lt;/li&gt;
 * &lt;li&gt;a special cube id is reserved to represent this transparent color.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * &lt;b&gt;Limitations:&lt;/b&gt;
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Rigid partitioning (fixed RGB555 grid) does not adapt to the distribution
 * of colors in the image.&lt;/li&gt;
 * &lt;li&gt;Poorer palette quality for continuous-tone images.&lt;/li&gt;
 * &lt;li&gt;No dithering: banding artifacts are visible on gradients unless combined
 * with an error-diffusion algorithm (e.g. Floyd–Steinberg).&lt;/li&gt;
 * &lt;/ul&gt;
 */
<span class="nc" id="L108">public final class Quantify555 {</span>

	// 32*32*32 RGB555 cubes + 1 extra slot for fully transparent color
	private static final int CUBE_COUNT_RGB555 = 32 * 32 * 32; // 0..32767
	private static final int TRANSPARENT_CUBE = CUBE_COUNT_RGB555; // 32768
	private static final int TOTAL_CUBE_SLOTS = CUBE_COUNT_RGB555 + 1;

	private static final int MIN_CUBES_THRESHOLD = 32;

	/**
	 * Attempts to quantize an image to &lt;= 256 colors using the Cube555 structure.
	 * 
	 * @param src any {@link BufferedImage}
	 * @return a new {@link BufferedImage} with an indexed color model, or
	 *         {@code null} if quantization is not possible (too many colors)
	 */
	public static BufferedImage packMeIfPossible(BufferedImage src) {

<span class="fc" id="L126">		final int w = src.getWidth();</span>
<span class="fc" id="L127">		final int h = src.getHeight();</span>

		try {
<span class="fc" id="L130">			final int[] pixels = src.getRGB(0, 0, w, h, null, 0, w);</span>

<span class="fc" id="L132">			Log.info(() -&gt; &quot;Using Quantify555.&quot;);</span>

<span class="fc" id="L134">			int nbCubes = 0;</span>

			// Step 1: Fill Cube555 structures with frequency counts
<span class="fc" id="L137">			final Cube555[] cubes = new Cube555[TOTAL_CUBE_SLOTS];</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			for (int argb : pixels) {</span>
<span class="fc" id="L139">				final int cubeIndex = getCubeIndex(argb);</span>

<span class="fc" id="L141">				Cube555 cube = cubes[cubeIndex];</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">				if (cube == null) {</span>
					// Abort if too many distinct cubes are found
<span class="fc bfc" id="L144" title="All 2 branches covered.">					if (nbCubes++ &gt; 255) {</span>
<span class="pc" id="L145">						Log.info(() -&gt; &quot;...abort, too many colors&quot;);</span>
<span class="fc" id="L146">						return null;</span>
					}
<span class="fc" id="L148">					cube = new Cube555(cubeIndex);</span>
<span class="fc" id="L149">					cubes[cubeIndex] = cube;</span>
				}

				// for transparent pixels, we don't care about sub-color distribution;
				// just increment bucket 0 (or any fixed slot).
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">				final int sub = cubeIndex == TRANSPARENT_CUBE ? 0 : subColorIndex512(argb);</span>
<span class="fc" id="L155">				cube.increment(sub);</span>

			}

			// Abort if there are not enough cubes, risk of over-quantization
<span class="fc bfc" id="L160" title="All 2 branches covered.">			if (nbCubes &lt; MIN_CUBES_THRESHOLD) {</span>
<span class="pc" id="L161">				Log.info(() -&gt; &quot;...abort, not enough distinct colors&quot;);</span>
<span class="fc" id="L162">				return null;</span>
			}

			// Step 2: Build the final indexed image
<span class="fc" id="L166">			return buildIndexedImageFromCubes(src, cubes);</span>

<span class="nc" id="L168">		} catch (Throwable t) {</span>
			// Swallowing all throwables is intentional here: any unexpected failure
			// during pixel extraction or packing (including OutOfMemoryError or JVM-level
			// errors) prevents safe recovery. Returning null signals that the packed
			// representation could not be produced.
<span class="nc" id="L173">			return null;</span>
		}
	}

	public static boolean isTransparent(int argb) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		return ((argb &gt;&gt;&gt; 24) &amp; 0xFF) &lt; 127;</span>
	}

	/**
	 * Builds an indexed image from the set of populated cubes.
	 *
	 * @param src   original ARGB image
	 * @param cubes array of Cube555 (null for empty cubes)
	 * @return an indexed (8-bit) {@link BufferedImage}
	 */
	private static BufferedImage buildIndexedImageFromCubes(BufferedImage src, Cube555[] cubes) {
<span class="fc" id="L189">		final int w = src.getWidth();</span>
<span class="fc" id="L190">		final int h = src.getHeight();</span>

		// Step 1: Build the palette from all non-empty cubes
<span class="fc" id="L193">		final int[] cubeToPal = new int[TOTAL_CUBE_SLOTS];</span>
<span class="fc" id="L194">		Arrays.fill(cubeToPal, -1);</span>

<span class="fc" id="L196">		final int[] palARGB = new int[256];</span>
<span class="fc" id="L197">		int palSize = 0;</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">		for (Cube555 c : cubes) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">			if (c == null)</span>
<span class="fc" id="L201">				continue;</span>
<span class="fc" id="L202">			final int sub = c.best(); // most frequent sub-color (0..511)</span>
<span class="fc" id="L203">			final int argb = representativeARGB(c.rgb555, sub);</span>
<span class="fc" id="L204">			cubeToPal[c.rgb555] = palSize;</span>
<span class="fc" id="L205">			palARGB[palSize++] = argb;</span>
		}

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">		if (palSize == 0)</span>
<span class="nc" id="L209">			throw new IllegalStateException();</span>

<span class="fc" id="L211">		final IndexColorModel icm = buildICM(palARGB, palSize);</span>

		// Step 2: Create output indexed image
<span class="fc" id="L214">		final BufferedImage dst = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_INDEXED, icm);</span>
<span class="fc" id="L215">		final WritableRaster raster = dst.getRaster();</span>

		// Step 3: Replace each pixel in the source with its palette index
<span class="fc" id="L218">		final int[] line = new int[w];</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">		for (int y = 0; y &lt; h; y++) {</span>
<span class="fc" id="L220">			src.getRGB(0, y, w, 1, line, 0, w);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">			for (int x = 0; x &lt; w; x++) {</span>
<span class="fc" id="L222">				final int argb = line[x];</span>
<span class="fc" id="L223">				final int cubeIndex = getCubeIndex(argb);</span>
<span class="fc" id="L224">				final int p = cubeToPal[cubeIndex];</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">				if (p &lt; 0)</span>
<span class="nc" id="L226">					throw new IllegalStateException();</span>

<span class="fc" id="L228">				raster.setSample(x, y, 0, p);</span>
			}
		}
<span class="fc" id="L231">		return dst;</span>
	}

	/**
	 * Builds an {@link IndexColorModel} from a palette of ARGB colors.
	 * 
	 * @param palARGB array of ARGB colors
	 * @param palSize number of colors actually used
	 * @return an {@link IndexColorModel} suitable for TYPE_BYTE_INDEXED
	 */
	public static IndexColorModel buildICM(final int[] palARGB, final int palSize) {
<span class="fc" id="L242">		final byte[] r = new byte[palSize];</span>
<span class="fc" id="L243">		final byte[] g = new byte[palSize];</span>
<span class="fc" id="L244">		final byte[] b = new byte[palSize];</span>
<span class="fc" id="L245">		final byte[] a = new byte[palSize];</span>

<span class="fc bfc" id="L247" title="All 2 branches covered.">		for (int i = 0; i &lt; palSize; i++) {</span>
<span class="fc" id="L248">			final int argb = palARGB[i];</span>
<span class="fc" id="L249">			a[i] = (byte) ((argb &gt;&gt;&gt; 24) &amp; 0xFF);</span>
<span class="fc" id="L250">			r[i] = (byte) ((argb &gt;&gt;&gt; 16) &amp; 0xFF);</span>
<span class="fc" id="L251">			g[i] = (byte) ((argb &gt;&gt;&gt; 8) &amp; 0xFF);</span>
<span class="fc" id="L252">			b[i] = (byte) (argb &amp; 0xFF);</span>
		}

<span class="fc" id="L255">		return new IndexColorModel(8, palSize, r, g, b, a);</span>
	}

	/**
	 * Reconstructs an ARGB color from a cube index (RGB555) and a sub-color index
	 * (9 bits).
	 * &lt;p&gt;
	 * Conversion: r8 = (r5 &lt;&lt; 3) | rLow3, etc. Alpha is set to 255 (opaque).
	 * &lt;/p&gt;
	 *
	 * @param cubeIndex cube index (15-bit RGB555)
	 * @param sub512    sub-color index (0..511)
	 * @return reconstructed ARGB color
	 */
	private static int representativeARGB(int cubeIndex, int sub512) {

<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		if (cubeIndex == TRANSPARENT_CUBE)</span>
<span class="nc" id="L272">			return 0x00000000; // fully transparent black</span>

<span class="fc" id="L274">		final int r5 = (cubeIndex &gt;&gt;&gt; 10) &amp; 0x1F;</span>
<span class="fc" id="L275">		final int g5 = (cubeIndex &gt;&gt;&gt; 5) &amp; 0x1F;</span>
<span class="fc" id="L276">		final int b5 = cubeIndex &amp; 0x1F;</span>

<span class="fc" id="L278">		final int rLow3 = (sub512 &gt;&gt;&gt; 6) &amp; 0x07;</span>
<span class="fc" id="L279">		final int gLow3 = (sub512 &gt;&gt;&gt; 3) &amp; 0x07;</span>
<span class="fc" id="L280">		final int bLow3 = sub512 &amp; 0x07;</span>

<span class="fc" id="L282">		final int r8 = (r5 &lt;&lt; 3) | rLow3;</span>
<span class="fc" id="L283">		final int g8 = (g5 &lt;&lt; 3) | gLow3;</span>
<span class="fc" id="L284">		final int b8 = (b5 &lt;&lt; 3) | bLow3;</span>

<span class="fc" id="L286">		return (0xFF &lt;&lt; 24) | (r8 &lt;&lt; 16) | (g8 &lt;&lt; 8) | b8;</span>
	}

	private static int getCubeIndex(int argb) {

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">		if (isTransparent(argb))</span>
<span class="nc" id="L292">			return TRANSPARENT_CUBE;</span>

		/*
		 * Compacts a 24-bit ARGB color into a 15-bit RGB555 index.
		 * 
		 * Formula: r5:g5:b5 -&gt; (r5 &lt;&lt; 10) | (g5 &lt;&lt; 5) | b5 &lt;/p&gt;
		 */

<span class="fc" id="L300">		final int r5 = (argb &gt;&gt;&gt; 19) &amp; 0x1F; // bits 23..19</span>
<span class="fc" id="L301">		final int g5 = (argb &gt;&gt;&gt; 11) &amp; 0x1F; // bits 15..11</span>
<span class="fc" id="L302">		final int b5 = (argb &gt;&gt;&gt; 3) &amp; 0x1F; // bits 7..3</span>
<span class="fc" id="L303">		return (r5 &lt;&lt; 10) | (g5 &lt;&lt; 5) | b5;</span>
	}

	/**
	 * Computes the 9-bit sub-color index (0..511) of a pixel inside its RGB555
	 * cube.
	 * &lt;p&gt;
	 * Takes the 3 least significant bits of each 8-bit channel:
	 * 
	 * sub = (rLow3 &lt;&lt; 6) | (gLow3 &lt;&lt; 3) | bLow3
	 * &lt;/p&gt;
	 *
	 * @param argb 32-bit ARGB color
	 * @return sub-color index (0..511)
	 */
	private static int subColorIndex512(int argb) {
<span class="fc" id="L319">		final int r8 = (argb &gt;&gt;&gt; 16) &amp; 0xFF;</span>
<span class="fc" id="L320">		final int g8 = (argb &gt;&gt;&gt; 8) &amp; 0xFF;</span>
<span class="fc" id="L321">		final int b8 = argb &amp; 0xFF;</span>

<span class="fc" id="L323">		final int rLow3 = r8 &amp; 0x07; // 3 least significant bits</span>
<span class="fc" id="L324">		final int gLow3 = g8 &amp; 0x07;</span>
<span class="fc" id="L325">		final int bLow3 = b8 &amp; 0x07;</span>

<span class="fc" id="L327">		return (rLow3 &lt;&lt; 6) | (gLow3 &lt;&lt; 3) | bLow3; // 0..511</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>