<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlantUMLBrowser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.teavm.browser</a> &gt; <span class="el_source">PlantUMLBrowser.java</span></div><h1>PlantUMLBrowser.java</h1><pre class="source lang-java linenums">package net.sourceforge.plantuml.teavm.browser;

// ::uncomment when __TEAVM__
//import org.teavm.jso.JSBody;
//import org.teavm.jso.JSFunctor;
//import org.teavm.jso.JSObject;
//import org.teavm.jso.dom.html.HTMLDocument;
//import org.teavm.jso.dom.html.HTMLElement;
//import org.teavm.jso.dom.xml.Element;
//
//import net.sourceforge.plantuml.FileFormat;
//import net.sourceforge.plantuml.FileFormatOption;
//import net.sourceforge.plantuml.core.Diagram;
//import net.sourceforge.plantuml.klimt.color.ColorMapper;
//import net.sourceforge.plantuml.klimt.color.HColor;
//import net.sourceforge.plantuml.klimt.color.HColors;
//import net.sourceforge.plantuml.klimt.font.StringBounder;
//import net.sourceforge.plantuml.teavm.PSystemBuilder2;
//import net.sourceforge.plantuml.teavm.StringBounderTeaVM;
//import net.sourceforge.plantuml.teavm.SvgGraphicsTeaVM;
//import net.sourceforge.plantuml.teavm.UGraphicTeaVM;
//:: done

/**
 * PlantUML rendering engine for browser environments, compiled to JavaScript via TeaVM.
 * 
 * &lt;h2&gt;Overview&lt;/h2&gt;
 * 
 * This class provides a bridge between JavaScript code running in a browser and the
 * PlantUML Java rendering engine. It exposes a global JavaScript function
 * {@code plantumlRender(lines, elementId)} that web pages can call to render diagrams.
 * 
 * &lt;h2&gt;Architecture: JavaScript-driven paradigm&lt;/h2&gt;
 * 
 * The design follows a &quot;JS-driven&quot; architecture where:
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;b&gt;JavaScript handles:&lt;/b&gt; UI events, user input, debouncing, line splitting, 
 *       DOM element selection, and overall application flow&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;Java handles:&lt;/b&gt; PlantUML parsing and SVG rendering only&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * This separation keeps the Java code minimal and allows maximum flexibility for
 * web developers to integrate PlantUML however they want.
 * 
 * &lt;h2&gt;Why we need a worker thread&lt;/h2&gt;
 * 
 * TeaVM compiles Java to JavaScript, but JavaScript is single-threaded and event-driven.
 * To support Java's synchronous blocking APIs (like {@code Thread.sleep()} or 
 * {@code Object.wait()}), TeaVM uses a coroutine-based approach that transforms
 * blocking calls into asynchronous JavaScript Promises.
 * 
 * &lt;h3&gt;The Viz.js constraint&lt;/h3&gt;
 * 
 * PlantUML uses Viz.js (a JavaScript port of GraphViz) to render class diagrams,
 * component diagrams, and other diagrams that require graph layout. Viz.js has an
 * asynchronous API:
 * 
 * &lt;pre&gt;
 * Viz.instance().then(viz =&gt; viz.renderString(dot, options))
 * &lt;/pre&gt;
 * 
 * Our {@code GraphVizjsTeaVMEngine} class uses TeaVM's {@code @Async} annotation to
 * make this async call appear synchronous to Java code. However, this only works
 * when called from a &quot;TeaVM coroutine context&quot; - essentially, from within a TeaVM
 * thread.
 * 
 * &lt;h3&gt;What happens without the worker thread&lt;/h3&gt;
 * 
 * If JavaScript calls our render function directly (e.g., from a {@code setTimeout}
 * callback or an event listener), the call happens in a &quot;native JS context&quot;, not a
 * TeaVM coroutine context. When the code reaches the Viz.js async call, TeaVM throws:
 * 
 * &lt;pre&gt;
 * Error: Suspension point reached from non-threading context
 * (perhaps, from native JS method).
 * See https://teavm.org/docs/runtime/coroutines.html
 * &lt;/pre&gt;
 * 
 * &lt;h3&gt;The solution: a dedicated worker thread&lt;/h3&gt;
 * 
 * We solve this by:
 * &lt;ol&gt;
 *   &lt;li&gt;Starting a background thread at initialization (in {@code main()})&lt;/li&gt;
 *   &lt;li&gt;Having the JS-callable function just queue a render request and wake the thread&lt;/li&gt;
 *   &lt;li&gt;The worker thread performs the actual rendering in the correct coroutine context&lt;/li&gt;
 * &lt;/ol&gt;
 * 
 * This pattern ensures all PlantUML rendering (including Viz.js calls) happens in a
 * context where TeaVM's async-to-sync transformation works correctly.
 * 
 * &lt;h2&gt;Usage from JavaScript&lt;/h2&gt;
 * 
 * &lt;pre&gt;
 * // Initialize (call once when page loads)
 * main();
 * 
 * // Render a diagram
 * const source = &quot;@startuml\nAlice -&gt; Bob : hello\n@enduml&quot;;
 * const lines = source.split(/\r\n|\r|\n/);
 * plantumlRender(lines, &quot;output-div-id&quot;);
 * &lt;/pre&gt;
 * 
 * &lt;h2&gt;Thread safety&lt;/h2&gt;
 * 
 * The class uses a simple producer-consumer pattern:
 * &lt;ul&gt;
 *   &lt;li&gt;Producer: {@code requestRender()} called from JS, sets pending request and notifies&lt;/li&gt;
 *   &lt;li&gt;Consumer: {@code workerLoop()} waits for requests, processes them one at a time&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * If multiple render requests arrive while one is being processed, only the latest
 * request is kept (the previous pending request is overwritten). This is intentional:
 * when a user is typing, we only care about rendering the latest version.
 * 
 * @see net.sourceforge.plantuml.teavm.GraphVizjsTeaVMEngine
 */
<span class="nc" id="L117">public class PlantUMLBrowser {</span>

	// ::uncomment when __TEAVM__

//    // =========================================================================
//    // Rendering configuration
//    // =========================================================================
//
//    private static final StringBounder STRING_BOUNDER = new StringBounderTeaVM();
//    private static final ColorMapper COLOR_MAPPER = ColorMapper.TEAVM;
//    private static final HColor BACK = HColors.WHITE;
//    private static final PSystemBuilder2 BUILDER = new PSystemBuilder2();
//
//    // =========================================================================
//    // Worker thread synchronization
//    // 
//    // We use a simple wait/notify pattern. The worker thread waits on LOCK until
//    // pendingLines becomes non-null, then processes the request and sets it back
//    // to null.
//    // =========================================================================
//
//    /** Lock object for synchronizing between JS requests and worker thread. */
//    private static final Object LOCK = new Object();
//
//    /** 
//     * The PlantUML source lines to render, or null if no request is pending.
//     * Set by requestRender(), cleared by workerLoop() after processing.
//     */
//    private static volatile String[] pendingLines;
//
//    /** The DOM element ID where the SVG should be inserted. */
//    private static volatile String pendingElementId;
//
//    // =========================================================================
//    // Initialization
//    // =========================================================================
//
//    /**
//     * Entry point called from JavaScript to initialize the PlantUML renderer.
//     * 
//     * This method:
//     * &lt;ol&gt;
//     *   &lt;li&gt;Starts the background worker thread that will handle all rendering&lt;/li&gt;
//     *   &lt;li&gt;Registers the global {@code window.plantumlRender} function&lt;/li&gt;
//     * &lt;/ol&gt;
//     * 
//     * Must be called once before any rendering can occur.
//     */
//    public static void main(String[] args) {
//        // Start worker thread FIRST - it needs to be ready to receive requests.
//        // The thread runs forever, waiting for render requests.
//        new Thread(PlantUMLBrowser::workerLoop, &quot;plantuml-render&quot;).start();
//
//        // Register the JS-callable function. After this, JavaScript can call
//        // plantumlRender(lines, elementId) to request a diagram rendering.
//        registerRender(PlantUMLBrowser::requestRender);
//
//        consoleLog(&quot;PlantUML TeaVM loaded.&quot;);
//    }
//
//    // =========================================================================
//    // JavaScript API registration
//    // =========================================================================
//
//    /**
//     * Registers a callback function as {@code window.plantumlRender} in JavaScript.
//     * 
//     * After this call, JavaScript code can invoke:
//     * &lt;pre&gt;
//     * plantumlRender([&quot;@startuml&quot;, &quot;Alice -&gt; Bob&quot;, &quot;@enduml&quot;], &quot;out&quot;);
//     * &lt;/pre&gt;
//     */
//    @JSBody(params = &quot;cb&quot;, script = &quot;window.plantumlRender = cb;&quot;)
//    private static native void registerRender(RenderCallback cb);
//
//    /**
//     * Functional interface for the render callback, compatible with TeaVM's JS interop.
//     * 
//     * The @JSFunctor annotation tells TeaVM to generate a JavaScript function that
//     * can be stored and called from JS code.
//     */
//    @JSFunctor
//    public interface RenderCallback extends JSObject {
//        void call(String[] lines, String elementId);
//    }
//
//    // =========================================================================
//    // Request handling (called from JavaScript)
//    // =========================================================================
//
//    /**
//     * Called from JavaScript to request a diagram rendering.
//     * 
//     * This method does NOT perform the rendering itself - it only queues the request
//     * and wakes up the worker thread. This is necessary because:
//     * 
//     * &lt;ol&gt;
//     *   &lt;li&gt;This method is called from a native JS context (event handler, setTimeout, etc.)&lt;/li&gt;
//     *   &lt;li&gt;Viz.js async calls require a TeaVM coroutine context&lt;/li&gt;
//     *   &lt;li&gt;The worker thread provides that coroutine context&lt;/li&gt;
//     * &lt;/ol&gt;
//     * 
//     * If a previous request is still pending (worker hasn't picked it up yet), it will
//     * be overwritten. This is the desired behavior for live-typing scenarios.
//     * 
//     * @param lines     the PlantUML source code, split into lines by the JavaScript caller
//     * @param elementId the ID of the HTML element where the SVG should be rendered
//     */
//    private static void requestRender(String[] lines, String elementId) {
//        synchronized (LOCK) {
//            // Store the request (overwrites any previous pending request)
//            pendingLines = lines;
//            pendingElementId = elementId;
//
//            // Wake up the worker thread to process this request
//            LOCK.notify();
//        }
//    }
//
//    // =========================================================================
//    // Worker thread
//    // =========================================================================
//
//    /**
//     * Main loop for the worker thread. Runs forever, processing render requests.
//     * 
//     * This method executes in a TeaVM coroutine context, which means:
//     * &lt;ul&gt;
//     *   &lt;li&gt;{@code LOCK.wait()} is properly transformed to async JS&lt;/li&gt;
//     *   &lt;li&gt;Viz.js async calls (via @Async annotation) work correctly&lt;/li&gt;
//     * &lt;/ul&gt;
//     * 
//     * The loop:
//     * &lt;ol&gt;
//     *   &lt;li&gt;Waits until a render request is available (pendingLines != null)&lt;/li&gt;
//     *   &lt;li&gt;Captures and clears the request atomically&lt;/li&gt;
//     *   &lt;li&gt;Performs the rendering (may involve async Viz.js calls)&lt;/li&gt;
//     *   &lt;li&gt;Repeats forever&lt;/li&gt;
//     * &lt;/ol&gt;
//     */
//    private static void workerLoop() {
//        while (true) {
//            String[] lines;
//            String elementId;
//
//            // Wait for a render request
//            synchronized (LOCK) {
//                // Spin-wait pattern: keep waiting until we have work to do.
//                // This handles spurious wakeups correctly.
//                while (pendingLines == null) {
//                    try {
//                        LOCK.wait();
//                    } catch (InterruptedException e) {
//                        // Interruption is not expected, but if it happens, just retry
//                    }
//                }
//
//                // Capture the request and clear the pending state.
//                // This must be atomic (inside synchronized) to avoid race conditions.
//                lines = pendingLines;
//                elementId = pendingElementId;
//                pendingLines = null;
//            }
//
//            // Perform rendering OUTSIDE the synchronized block.
//            // This allows new requests to be queued while we're rendering.
//            doRender(lines, elementId);
//        }
//    }
//
//    // =========================================================================
//    // Rendering
//    // =========================================================================
//
//    /**
//     * Performs the actual PlantUML rendering and inserts the SVG into the DOM.
//     * 
//     * This method:
//     * &lt;ol&gt;
//     *   &lt;li&gt;Clears the target element&lt;/li&gt;
//     *   &lt;li&gt;Creates a PlantUML diagram from the source lines&lt;/li&gt;
//     *   &lt;li&gt;Renders it to SVG using the TeaVM-compatible graphics system&lt;/li&gt;
//     *   &lt;li&gt;Appends the SVG element to the target&lt;/li&gt;
//     * &lt;/ol&gt;
//     * 
//     * For diagrams requiring GraphViz (class diagrams, etc.), this will internally
//     * call Viz.js asynchronously. This works because we're running in the worker
//     * thread's coroutine context.
//     * 
//     * @param lines     the PlantUML source lines
//     * @param elementId the target DOM element ID
//     */
//    private static void doRender(String[] lines, String elementId) {
//        // Find the target element in the DOM
//        HTMLElement out = HTMLDocument.current().getElementById(elementId);
//        if (out == null)
//            return;
//
//        try {
//            // Create SVG graphics context with TeaVM-compatible implementation
//            SvgGraphicsTeaVM svg = new SvgGraphicsTeaVM(900, 900);
//            UGraphicTeaVM ug = UGraphicTeaVM.build(BACK, COLOR_MAPPER, STRING_BOUNDER, svg);
//
//            // Parse and render the diagram.
//            // For class diagrams, this will call GraphVizjsTeaVMEngine internally,
//            // which uses Viz.js for layout. The @Async magic happens here.
//            Diagram diagram = BUILDER.createDiagram(lines);
//            diagram.exportDiagramGraphic(ug, new FileFormatOption(FileFormat.SVG));
//
//            // Clear any previous content (old SVG, error messages, etc.)
//            removeAllChildren(out);
//
//            // Insert the rendered SVG into the DOM
//            appendSvgElement(out, svg.getSvgRoot());
//        } catch (Exception e) {
//            // Display error message in the target element
//            out.setTextContent(String.valueOf(e));
//        }
//    }
//
//    // =========================================================================
//    // JavaScript interop utilities
//    // =========================================================================
//
//    /** Logs a message to the browser's JavaScript console. */
//    @JSBody(params = &quot;msg&quot;, script = &quot;console.log(msg);&quot;)
//    private static native void consoleLog(String msg);
//
//    /** Appends an SVG element as a child of a DOM element. */
//    @JSBody(params = { &quot;p&quot;, &quot;svg&quot; }, script = &quot;p.appendChild(svg);&quot;)
//    private static native void appendSvgElement(HTMLElement p, Element svg);
//
//    /** Removes all child nodes from a DOM element. */
//    @JSBody(params = &quot;el&quot;, script = &quot;while(el.firstChild)el.removeChild(el.firstChild);&quot;)
//    private static native void removeAllChildren(HTMLElement el);
    
    //:: done
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>