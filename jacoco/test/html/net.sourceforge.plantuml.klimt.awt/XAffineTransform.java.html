<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XAffineTransform.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.klimt.awt</a> &gt; <span class="el_source">XAffineTransform.java</span></div><h1>XAffineTransform.java</h1><pre class="source lang-java linenums">package net.sourceforge.plantuml.klimt.awt;

import net.sourceforge.plantuml.klimt.geom.XPoint2D;

/**
 * Affine transformation matrix implementation compatible with both standard JVM
 * and TeaVM environments.
 * 
 * &lt;p&gt;
 * The transformation matrix is represented as:
 * &lt;/p&gt;
 * 
 * &lt;pre&gt;
 * [ m00  m01  m02 ]   [ x ]   [ m00*x + m01*y + m02 ]
 * [ m10  m11  m12 ] * [ y ] = [ m10*x + m11*y + m12 ]
 * [  0    0    1  ]   [ 1 ]   [          1          ]
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;
 * Where:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;m00, m11 = scale factors (scaleX, scaleY)&lt;/li&gt;
 * &lt;li&gt;m01, m10 = shear/rotation factors&lt;/li&gt;
 * &lt;li&gt;m02, m12 = translation factors (translateX, translateY)&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class XAffineTransform {

	private double m00;
	private double m10;
	private double m01;
	private double m11;
	private double m02;
	private double m12;

	// ------------------------------------------------------------------------
	// Constructors
	// ------------------------------------------------------------------------

	/**
	 * Creates a transform from the 6 specified values.
	 *
	 * @param m00 the X coordinate scaling element
	 * @param m10 the Y coordinate shearing element
	 * @param m01 the X coordinate shearing element
	 * @param m11 the Y coordinate scaling element
	 * @param m02 the X coordinate translation element
	 * @param m12 the Y coordinate translation element
	 */
<span class="fc" id="L51">	public XAffineTransform(double m00, double m10, double m01, double m11, double m02, double m12) {</span>
<span class="fc" id="L52">		this.m00 = m00;</span>
<span class="fc" id="L53">		this.m10 = m10;</span>
<span class="fc" id="L54">		this.m01 = m01;</span>
<span class="fc" id="L55">		this.m11 = m11;</span>
<span class="fc" id="L56">		this.m02 = m02;</span>
<span class="fc" id="L57">		this.m12 = m12;</span>
<span class="fc" id="L58">	}</span>

	/**
	 * Copy constructor.
	 *
	 * @param other the transform to copy
	 */
<span class="nc" id="L65">	public XAffineTransform(XAffineTransform other) {</span>
<span class="nc" id="L66">		this.m00 = other.m00;</span>
<span class="nc" id="L67">		this.m10 = other.m10;</span>
<span class="nc" id="L68">		this.m01 = other.m01;</span>
<span class="nc" id="L69">		this.m11 = other.m11;</span>
<span class="nc" id="L70">		this.m02 = other.m02;</span>
<span class="nc" id="L71">		this.m12 = other.m12;</span>
<span class="nc" id="L72">	}</span>

	/**
	 * Creates a transform from a 6-element array.
	 *
	 * @param flatMatrix array containing [m00, m10, m01, m11, m02, m12]
	 */
<span class="nc" id="L79">	public XAffineTransform(double[] flatMatrix) {</span>
<span class="nc" id="L80">		this.m00 = flatMatrix[0];</span>
<span class="nc" id="L81">		this.m10 = flatMatrix[1];</span>
<span class="nc" id="L82">		this.m01 = flatMatrix[2];</span>
<span class="nc" id="L83">		this.m11 = flatMatrix[3];</span>
<span class="nc" id="L84">		this.m02 = flatMatrix[4];</span>
<span class="nc" id="L85">		this.m12 = flatMatrix[5];</span>
<span class="nc" id="L86">	}</span>

	/**
	 * Creates an identity transform.
	 */
<span class="nc" id="L91">	public XAffineTransform() {</span>
<span class="nc" id="L92">		this.m00 = 1.0;</span>
<span class="nc" id="L93">		this.m10 = 0.0;</span>
<span class="nc" id="L94">		this.m01 = 0.0;</span>
<span class="nc" id="L95">		this.m11 = 1.0;</span>
<span class="nc" id="L96">		this.m02 = 0.0;</span>
<span class="nc" id="L97">		this.m12 = 0.0;</span>
<span class="nc" id="L98">	}</span>

	// ------------------------------------------------------------------------
	// Factory methods
	// ------------------------------------------------------------------------

	/**
	 * Creates a rotation transform.
	 *
	 * @param thetaRadians the angle of rotation in radians
	 * @return a new rotation transform
	 */
	public static XAffineTransform getRotateInstance(double thetaRadians) {
<span class="fc" id="L111">		final double cos = Math.cos(thetaRadians);</span>
<span class="fc" id="L112">		final double sin = Math.sin(thetaRadians);</span>
<span class="fc" id="L113">		return new XAffineTransform(cos, sin, -sin, cos, 0.0, 0.0);</span>
	}

	/**
	 * Creates a translation transform.
	 *
	 * @param tx the X translation
	 * @param ty the Y translation
	 * @return a new translation transform
	 */
	public static XAffineTransform getTranslateInstance(double tx, double ty) {
<span class="nc" id="L124">		return new XAffineTransform(1.0, 0.0, 0.0, 1.0, tx, ty);</span>
	}

	/**
	 * Creates a scaling transform.
	 *
	 * @param sx the X scale factor
	 * @param sy the Y scale factor
	 * @return a new scaling transform
	 */
	public static XAffineTransform getScaleInstance(double sx, double sy) {
<span class="nc" id="L135">		return new XAffineTransform(sx, 0.0, 0.0, sy, 0.0, 0.0);</span>
	}

	// ------------------------------------------------------------------------
	// Accessors
	// ------------------------------------------------------------------------

	/**
	 * Returns the X coordinate scaling element (m00).
	 *
	 * @return the X scaling factor
	 */
	public double getScaleX() {
<span class="nc" id="L148">		return m00;</span>
	}

	/**
	 * Returns the Y coordinate scaling element (m11).
	 *
	 * @return the Y scaling factor
	 */
	public double getScaleY() {
<span class="nc" id="L157">		return m11;</span>
	}

	/**
	 * Returns the X coordinate translation element (m02).
	 *
	 * @return the X translation
	 */
	public double getTranslateX() {
<span class="nc" id="L166">		return m02;</span>
	}

	/**
	 * Returns the Y coordinate translation element (m12).
	 *
	 * @return the Y translation
	 */
	public double getTranslateY() {
<span class="nc" id="L175">		return m12;</span>
	}

	// ------------------------------------------------------------------------
	// Mutators / operations
	// ------------------------------------------------------------------------

	/**
	 * Concatenates a scaling transformation to this transform.
	 *
	 * @param sx the X scale factor
	 * @param sy the Y scale factor
	 */
	public void scale(double sx, double sy) {
<span class="nc" id="L189">		m00 *= sx;</span>
<span class="nc" id="L190">		m01 *= sx;</span>
<span class="nc" id="L191">		m02 *= sx;</span>
<span class="nc" id="L192">		m10 *= sy;</span>
<span class="nc" id="L193">		m11 *= sy;</span>
<span class="nc" id="L194">		m12 *= sy;</span>
<span class="nc" id="L195">	}</span>

	/**
	 * Transforms the specified point.
	 *
	 * @param src the source point
	 * @return the transformed point
	 */
	public XPoint2D transform(XPoint2D src) {
<span class="fc" id="L204">		final double x = m00 * src.x + m01 * src.y + m02;</span>
<span class="fc" id="L205">		final double y = m10 * src.x + m11 * src.y + m12;</span>
<span class="fc" id="L206">		return new XPoint2D(x, y);</span>
	}

	/**
	 * Concatenates another transform to this transform.
	 * &lt;p&gt;
	 * This is equivalent to: [this] = [this] * [other]
	 * &lt;/p&gt;
	 *
	 * @param other the transform to concatenate
	 */
	public void concatenate(XAffineTransform other) {
<span class="nc" id="L218">		final double n00 = m00 * other.m00 + m01 * other.m10;</span>
<span class="nc" id="L219">		final double n01 = m00 * other.m01 + m01 * other.m11;</span>
<span class="nc" id="L220">		final double n02 = m00 * other.m02 + m01 * other.m12 + m02;</span>
<span class="nc" id="L221">		final double n10 = m10 * other.m00 + m11 * other.m10;</span>
<span class="nc" id="L222">		final double n11 = m10 * other.m01 + m11 * other.m11;</span>
<span class="nc" id="L223">		final double n12 = m10 * other.m02 + m11 * other.m12 + m12;</span>

<span class="nc" id="L225">		m00 = n00;</span>
<span class="nc" id="L226">		m01 = n01;</span>
<span class="nc" id="L227">		m02 = n02;</span>
<span class="nc" id="L228">		m10 = n10;</span>
<span class="nc" id="L229">		m11 = n11;</span>
<span class="nc" id="L230">		m12 = n12;</span>
<span class="nc" id="L231">	}</span>

	/**
	 * Concatenates a translation transformation to this transform.
	 *
	 * @param tx the X translation
	 * @param ty the Y translation
	 */
	public void translate(double tx, double ty) {
<span class="nc" id="L240">		m02 += m00 * tx + m01 * ty;</span>
<span class="nc" id="L241">		m12 += m10 * tx + m11 * ty;</span>
<span class="nc" id="L242">	}</span>

	/**
	 * Concatenates a rotation transformation around the specified anchor point.
	 *
	 * @param thetaRadians the angle of rotation in radians
	 * @param anchorX      the X coordinate of the rotation anchor
	 * @param anchorY      the Y coordinate of the rotation anchor
	 */
	public void rotate(double thetaRadians, double anchorX, double anchorY) {
<span class="nc" id="L252">		translate(anchorX, anchorY);</span>
<span class="nc" id="L253">		final double cos = Math.cos(thetaRadians);</span>
<span class="nc" id="L254">		final double sin = Math.sin(thetaRadians);</span>
<span class="nc" id="L255">		final double n00 = m00 * cos + m01 * sin;</span>
<span class="nc" id="L256">		final double n01 = m00 * -sin + m01 * cos;</span>
<span class="nc" id="L257">		final double n10 = m10 * cos + m11 * sin;</span>
<span class="nc" id="L258">		final double n11 = m10 * -sin + m11 * cos;</span>
<span class="nc" id="L259">		m00 = n00;</span>
<span class="nc" id="L260">		m01 = n01;</span>
<span class="nc" id="L261">		m10 = n10;</span>
<span class="nc" id="L262">		m11 = n11;</span>
<span class="nc" id="L263">		translate(-anchorX, -anchorY);</span>
<span class="nc" id="L264">	}</span>

	// ------------------------------------------------------------------------
	// Conversion
	// ------------------------------------------------------------------------

	// ::comment when __TEAVM__
	/**
	 * Creates a new {@link java.awt.geom.AffineTransform} with the same matrix
	 * values.
	 *
	 * @return a new AffineTransform instance
	 */
	public java.awt.geom.AffineTransform toAffineTransform() {
<span class="nc" id="L278">		return new java.awt.geom.AffineTransform(m00, m10, m01, m11, m02, m12);</span>
	}
	// ::done

	@Override
	public String toString() {
<span class="nc" id="L284">		return &quot;XAffineTransform[[&quot; + m00 + &quot;, &quot; + m01 + &quot;, &quot; + m02 + &quot;], [&quot; + m10 + &quot;, &quot; + m11 + &quot;, &quot; + m12 + &quot;]]&quot;;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>