<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.tim</a> &gt; <span class="el_source">TContext.java</span></div><h1>TContext.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 *
 * If you like this project or if you find it useful, you can support us at:
 *
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 *
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 *
 */
package net.sourceforge.plantuml.tim;

import static java.util.Objects.requireNonNull;

import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import net.sourceforge.plantuml.DefinitionsContainer;
import net.sourceforge.plantuml.FileSystem;
import net.sourceforge.plantuml.command.CommandExecutionResult;
import net.sourceforge.plantuml.jaws.Jaws;
import net.sourceforge.plantuml.jaws.JawsStrange;
import net.sourceforge.plantuml.json.Json;
import net.sourceforge.plantuml.json.JsonObject;
import net.sourceforge.plantuml.json.JsonValue;
import net.sourceforge.plantuml.log.Logme;
import net.sourceforge.plantuml.nio.InputFile;
import net.sourceforge.plantuml.nio.PathSystem;
import net.sourceforge.plantuml.preproc.Defines;
import net.sourceforge.plantuml.preproc.DiagramDetector;
import net.sourceforge.plantuml.preproc.PreprocessingArtifact;
import net.sourceforge.plantuml.preproc.ReadLine;
import net.sourceforge.plantuml.preproc.ReadLineList;
import net.sourceforge.plantuml.preproc.ReadLineReader;
import net.sourceforge.plantuml.preproc.ReadLineWithYamlHeader;
import net.sourceforge.plantuml.preproc.DiagramExtractor;
import net.sourceforge.plantuml.preproc.Sub;
import net.sourceforge.plantuml.preproc.UncommentReadLine;
import net.sourceforge.plantuml.preproc2.PreprocessorIncludeStrategy;
import net.sourceforge.plantuml.preproc2.PreprocessorUtils;
import net.sourceforge.plantuml.security.SFile;
import net.sourceforge.plantuml.security.SURL;
import net.sourceforge.plantuml.skin.Pragma;
import net.sourceforge.plantuml.text.StringLocated;
import net.sourceforge.plantuml.text.TLineType;
import net.sourceforge.plantuml.theme.Theme;
import net.sourceforge.plantuml.tim.builtin.AlwaysFalse;
import net.sourceforge.plantuml.tim.builtin.AlwaysTrue;
import net.sourceforge.plantuml.tim.builtin.Backslash;
import net.sourceforge.plantuml.tim.builtin.BoolVal;
import net.sourceforge.plantuml.tim.builtin.Breakline;
import net.sourceforge.plantuml.tim.builtin.CallUserFunction;
import net.sourceforge.plantuml.tim.builtin.Chr;
import net.sourceforge.plantuml.tim.builtin.Darken;
import net.sourceforge.plantuml.tim.builtin.DateFunction;
import net.sourceforge.plantuml.tim.builtin.Dec2hex;
import net.sourceforge.plantuml.tim.builtin.Dirpath;
import net.sourceforge.plantuml.tim.builtin.Dollar;
import net.sourceforge.plantuml.tim.builtin.Eval;
import net.sourceforge.plantuml.tim.builtin.Feature;
import net.sourceforge.plantuml.tim.builtin.FileExists;
import net.sourceforge.plantuml.tim.builtin.Filedate;
import net.sourceforge.plantuml.tim.builtin.Filename;
import net.sourceforge.plantuml.tim.builtin.FilenameNoExtension;
import net.sourceforge.plantuml.tim.builtin.FunctionExists;
import net.sourceforge.plantuml.tim.builtin.GetAllStdlib;
import net.sourceforge.plantuml.tim.builtin.GetAllTheme;
import net.sourceforge.plantuml.tim.builtin.GetCurrentTheme;
import net.sourceforge.plantuml.tim.builtin.GetJsonKey;
import net.sourceforge.plantuml.tim.builtin.GetJsonType;
import net.sourceforge.plantuml.tim.builtin.GetStdlib;
import net.sourceforge.plantuml.tim.builtin.GetVariableValue;
import net.sourceforge.plantuml.tim.builtin.GetVersion;
import net.sourceforge.plantuml.tim.builtin.Getenv;
import net.sourceforge.plantuml.tim.builtin.Hex2dec;
import net.sourceforge.plantuml.tim.builtin.HslColor;
import net.sourceforge.plantuml.tim.builtin.IntVal;
import net.sourceforge.plantuml.tim.builtin.InvokeProcedure;
import net.sourceforge.plantuml.tim.builtin.IsDark;
import net.sourceforge.plantuml.tim.builtin.IsLight;
import net.sourceforge.plantuml.tim.builtin.JsonAdd;
import net.sourceforge.plantuml.tim.builtin.JsonKeyExists;
import net.sourceforge.plantuml.tim.builtin.JsonMerge;
import net.sourceforge.plantuml.tim.builtin.JsonRemove;
import net.sourceforge.plantuml.tim.builtin.JsonSet;
import net.sourceforge.plantuml.tim.builtin.LeftAlign;
import net.sourceforge.plantuml.tim.builtin.Lighten;
import net.sourceforge.plantuml.tim.builtin.LoadJson;
import net.sourceforge.plantuml.tim.builtin.LogicalAnd;
import net.sourceforge.plantuml.tim.builtin.LogicalNand;
import net.sourceforge.plantuml.tim.builtin.LogicalNor;
import net.sourceforge.plantuml.tim.builtin.LogicalNot;
import net.sourceforge.plantuml.tim.builtin.LogicalNxor;
import net.sourceforge.plantuml.tim.builtin.LogicalOr;
import net.sourceforge.plantuml.tim.builtin.LogicalXor;
import net.sourceforge.plantuml.tim.builtin.Lower;
import net.sourceforge.plantuml.tim.builtin.Modulo;
import net.sourceforge.plantuml.tim.builtin.Newline;
import net.sourceforge.plantuml.tim.builtin.NewlineShort;
import net.sourceforge.plantuml.tim.builtin.Now;
import net.sourceforge.plantuml.tim.builtin.Ord;
import net.sourceforge.plantuml.tim.builtin.Percent;
import net.sourceforge.plantuml.tim.builtin.RandomFunction;
import net.sourceforge.plantuml.tim.builtin.RetrieveProcedure;
import net.sourceforge.plantuml.tim.builtin.ReverseColor;
import net.sourceforge.plantuml.tim.builtin.ReverseHsluvColor;
import net.sourceforge.plantuml.tim.builtin.RightAlign;
import net.sourceforge.plantuml.tim.builtin.SetVariableValue;
import net.sourceforge.plantuml.tim.builtin.Size;
import net.sourceforge.plantuml.tim.builtin.SplitStr;
import net.sourceforge.plantuml.tim.builtin.SplitStrRegex;
import net.sourceforge.plantuml.tim.builtin.Str2Json;
import net.sourceforge.plantuml.tim.builtin.StringFunction;
import net.sourceforge.plantuml.tim.builtin.Strlen;
import net.sourceforge.plantuml.tim.builtin.Strpos;
import net.sourceforge.plantuml.tim.builtin.Substr;
import net.sourceforge.plantuml.tim.builtin.Tabulation;
import net.sourceforge.plantuml.tim.builtin.Upper;
import net.sourceforge.plantuml.tim.builtin.VariableExists;
import net.sourceforge.plantuml.tim.builtin.Xargs;
import net.sourceforge.plantuml.tim.expression.Knowledge;
import net.sourceforge.plantuml.tim.expression.TValue;
import net.sourceforge.plantuml.tim.iterator.CodeIterator;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorAffectation;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorForeach;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorIf;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorImpl;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorInnerComment;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorLegacyDefine;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorLongComment;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorProcedure;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorReturnFunction;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorShortComment;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorSub;
import net.sourceforge.plantuml.tim.iterator.CodeIteratorWhile;
import net.sourceforge.plantuml.utils.LineLocation;

<span class="fc" id="L172">public class TContext {</span>

<span class="fc" id="L174">	private final List&lt;StringLocated&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L175">	private final List&lt;StringLocated&gt; debug = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L177">	public final FunctionsSet functionsSet = new FunctionsSet();</span>

	private final Charset charset;

<span class="fc" id="L181">	private final Map&lt;String, Sub&gt; subs = new HashMap&lt;String, Sub&gt;();</span>
	private final DefinitionsContainer definitionsContainer;

	// private final Set&lt;FileWithSuffix&gt; usedFiles = new HashSet&lt;&gt;();
<span class="fc" id="L185">	private final Set&lt;File&gt; filesUsedCurrent = new HashSet&lt;&gt;();</span>

<span class="fc" id="L187">	private final PreprocessingArtifact preprocessingArtifact = new PreprocessingArtifact();</span>
	private PathSystem pathSystem;

	public Set&lt;File&gt; getFilesUsedCurrent() {
<span class="fc" id="L191">		return Collections.unmodifiableSet(filesUsedCurrent);</span>
	}

	private void addStandardFunctions(Defines defines) {
<span class="fc" id="L195">		functionsSet.addFunction(new AlwaysFalse());</span>
<span class="fc" id="L196">		functionsSet.addFunction(new AlwaysTrue());</span>
<span class="fc" id="L197">		functionsSet.addFunction(new Backslash());</span>
<span class="fc" id="L198">		functionsSet.addFunction(new BoolVal());</span>
<span class="fc" id="L199">		functionsSet.addFunction(new Breakline());</span>
<span class="fc" id="L200">		functionsSet.addFunction(new CallUserFunction());</span>
<span class="fc" id="L201">		functionsSet.addFunction(new Chr());</span>
<span class="fc" id="L202">		functionsSet.addFunction(new Darken());</span>
<span class="fc" id="L203">		functionsSet.addFunction(new DateFunction());</span>
<span class="fc" id="L204">		functionsSet.addFunction(new Dec2hex());</span>
<span class="fc" id="L205">		functionsSet.addFunction(new Dirpath(defines));</span>
<span class="fc" id="L206">		functionsSet.addFunction(new Dollar());</span>
<span class="fc" id="L207">		functionsSet.addFunction(new Eval());</span>
<span class="fc" id="L208">		functionsSet.addFunction(new Feature());</span>
<span class="fc" id="L209">		functionsSet.addFunction(new Filedate(defines));</span>
<span class="fc" id="L210">		functionsSet.addFunction(new FileExists());</span>
<span class="fc" id="L211">		functionsSet.addFunction(new Filename(defines));</span>
<span class="fc" id="L212">		functionsSet.addFunction(new FilenameNoExtension(defines));</span>
<span class="fc" id="L213">		functionsSet.addFunction(new FunctionExists());</span>
<span class="fc" id="L214">		functionsSet.addFunction(new GetAllStdlib());</span>
<span class="fc" id="L215">		functionsSet.addFunction(new GetAllTheme());</span>
<span class="fc" id="L216">		functionsSet.addFunction(new GetCurrentTheme());</span>
<span class="fc" id="L217">		functionsSet.addFunction(new GetJsonKey());</span>
<span class="fc" id="L218">		functionsSet.addFunction(new GetJsonType());</span>
<span class="fc" id="L219">		functionsSet.addFunction(new GetStdlib());</span>
<span class="fc" id="L220">		functionsSet.addFunction(new GetVariableValue());</span>
<span class="fc" id="L221">		functionsSet.addFunction(new GetVersion());</span>
<span class="fc" id="L222">		functionsSet.addFunction(new Getenv());</span>
<span class="fc" id="L223">		functionsSet.addFunction(new Hex2dec());</span>
<span class="fc" id="L224">		functionsSet.addFunction(new HslColor());</span>
<span class="fc" id="L225">		functionsSet.addFunction(new IntVal());</span>
<span class="fc" id="L226">		functionsSet.addFunction(new InvokeProcedure());</span>
<span class="fc" id="L227">		functionsSet.addFunction(new IsDark());</span>
<span class="fc" id="L228">		functionsSet.addFunction(new IsLight());</span>
<span class="fc" id="L229">		functionsSet.addFunction(new JsonAdd());</span>
<span class="fc" id="L230">		functionsSet.addFunction(new JsonKeyExists());</span>
<span class="fc" id="L231">		functionsSet.addFunction(new JsonMerge());</span>
<span class="fc" id="L232">		functionsSet.addFunction(new JsonRemove());</span>
<span class="fc" id="L233">		functionsSet.addFunction(new JsonSet());</span>
<span class="fc" id="L234">		functionsSet.addFunction(new LeftAlign());</span>
<span class="fc" id="L235">		functionsSet.addFunction(new Lighten());</span>
<span class="fc" id="L236">		functionsSet.addFunction(new LoadJson());</span>
		// functionsSet.addFunction(new LoadJsonLegacy());
<span class="fc" id="L238">		functionsSet.addFunction(new LogicalAnd());</span>
<span class="fc" id="L239">		functionsSet.addFunction(new LogicalNand());</span>
<span class="fc" id="L240">		functionsSet.addFunction(new LogicalNor());</span>
<span class="fc" id="L241">		functionsSet.addFunction(new LogicalNot());</span>
<span class="fc" id="L242">		functionsSet.addFunction(new LogicalNxor());</span>
<span class="fc" id="L243">		functionsSet.addFunction(new LogicalOr());</span>
<span class="fc" id="L244">		functionsSet.addFunction(new LogicalXor());</span>
<span class="fc" id="L245">		functionsSet.addFunction(new Lower());</span>
<span class="fc" id="L246">		functionsSet.addFunction(new Modulo());</span>
<span class="fc" id="L247">		functionsSet.addFunction(new Newline());</span>
<span class="fc" id="L248">		functionsSet.addFunction(new NewlineShort());</span>
<span class="fc" id="L249">		functionsSet.addFunction(new Now());</span>
<span class="fc" id="L250">		functionsSet.addFunction(new Ord());</span>
<span class="fc" id="L251">		functionsSet.addFunction(new Percent());</span>
<span class="fc" id="L252">		functionsSet.addFunction(new RandomFunction());</span>
<span class="fc" id="L253">		functionsSet.addFunction(new RetrieveProcedure());</span>
<span class="fc" id="L254">		functionsSet.addFunction(new ReverseColor());</span>
<span class="fc" id="L255">		functionsSet.addFunction(new ReverseHsluvColor());</span>
<span class="fc" id="L256">		functionsSet.addFunction(new RightAlign());</span>
<span class="fc" id="L257">		functionsSet.addFunction(new SetVariableValue());</span>
<span class="fc" id="L258">		functionsSet.addFunction(new Size());</span>
<span class="fc" id="L259">		functionsSet.addFunction(new SplitStr());</span>
<span class="fc" id="L260">		functionsSet.addFunction(new SplitStrRegex());</span>
<span class="fc" id="L261">		functionsSet.addFunction(new Str2Json());</span>
<span class="fc" id="L262">		functionsSet.addFunction(new StringFunction());</span>
<span class="fc" id="L263">		functionsSet.addFunction(new Strlen());</span>
<span class="fc" id="L264">		functionsSet.addFunction(new Strpos());</span>
<span class="fc" id="L265">		functionsSet.addFunction(new Substr());</span>
<span class="fc" id="L266">		functionsSet.addFunction(new Tabulation());</span>
<span class="fc" id="L267">		functionsSet.addFunction(new Upper());</span>
<span class="fc" id="L268">		functionsSet.addFunction(new VariableExists());</span>
<span class="fc" id="L269">		functionsSet.addFunction(new Xargs());</span>
		// %standard_exists_function
		// %str_replace
		// !exit
		// !log
		// %min
		// %max
		// Regexp
		// %time
		// %trim
<span class="fc" id="L279">	}</span>

	public TContext(PathSystem pathSystem, Defines defines, Charset charset,
<span class="fc" id="L282">			DefinitionsContainer definitionsContainer) {</span>
<span class="fc" id="L283">		this.pathSystem = pathSystem;</span>
<span class="fc" id="L284">		this.definitionsContainer = definitionsContainer;</span>
<span class="fc" id="L285">		this.charset = requireNonNull(charset);</span>
<span class="fc" id="L286">		this.addStandardFunctions(defines);</span>
<span class="fc" id="L287">	}</span>

	public Knowledge asKnowledge(final TMemory memory, final LineLocation location) {
<span class="fc" id="L290">		return new Knowledge() {</span>

			public TValue getVariable(String name) throws EaterException {
<span class="pc bpc" id="L293" title="1 of 4 branches missed.">				if (name.contains(&quot;.&quot;) || name.contains(&quot;[&quot;)) {</span>
<span class="fc" id="L294">					final TValue result = fromJson(memory, name, location);</span>
<span class="fc" id="L295">					return result;</span>
				}
<span class="fc" id="L297">				return memory.getVariable(name);</span>
			}

			public TFunction getFunction(TFunctionSignature name) {
<span class="fc" id="L301">				return functionsSet.getFunctionSmart(name);</span>
			}
		};
	}

	private TValue fromJson(TMemory memory, String name, LineLocation location) throws EaterException {
<span class="fc" id="L307">		final String result = applyFunctionsAndVariables(memory, new StringLocated(name, location));</span>
		try {
<span class="nc" id="L309">			final JsonValue json = Json.parse(result);</span>
<span class="nc" id="L310">			return TValue.fromJson(json);</span>
<span class="fc" id="L311">		} catch (Exception e) {</span>
<span class="fc" id="L312">			return TValue.fromString(result);</span>
		}
	}

	private CodeIterator buildCodeIterator(TMemory memory, List&lt;StringLocated&gt; body) {
<span class="fc" id="L317">		final CodeIterator it10 = new CodeIteratorImpl(body);</span>
<span class="fc" id="L318">		final CodeIterator it20 = new CodeIteratorLongComment(it10, debug);</span>
<span class="fc" id="L319">		final CodeIterator it30 = new CodeIteratorShortComment(it20, debug);</span>
<span class="fc" id="L320">		final CodeIterator it40 = new CodeIteratorInnerComment(it30);</span>
<span class="fc" id="L321">		final CodeIterator it50 = new CodeIteratorSub(it40, subs, this, memory);</span>
<span class="fc" id="L322">		final CodeIterator it60 = new CodeIteratorReturnFunction(it50, this, memory, functionsSet, debug);</span>
<span class="fc" id="L323">		final CodeIterator it61 = new CodeIteratorProcedure(it60, this, memory, functionsSet, debug);</span>
<span class="fc" id="L324">		final CodeIterator it70 = new CodeIteratorIf(it61, this, memory, debug);</span>
<span class="fc" id="L325">		final CodeIterator it80 = new CodeIteratorLegacyDefine(it70, this, memory, functionsSet, debug);</span>
<span class="fc" id="L326">		final CodeIterator it90 = new CodeIteratorWhile(it80, this, memory, debug);</span>
<span class="fc" id="L327">		final CodeIterator it100 = new CodeIteratorForeach(it90, this, memory, debug);</span>
<span class="fc" id="L328">		final CodeIterator it110 = new CodeIteratorAffectation(it100, this, memory, debug);</span>

<span class="fc" id="L330">		final CodeIterator it = it110;</span>
<span class="fc" id="L331">		return it;</span>
	}

	public TValue executeLines(TMemory memory, List&lt;StringLocated&gt; body, TFunctionType ftype, boolean modeSpecial)
			throws EaterException {
<span class="fc" id="L336">		final CodeIterator it = buildCodeIterator(memory, body);</span>

<span class="fc" id="L338">		StringLocated s = null;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">		while ((s = it.peek()) != null) {</span>
<span class="fc" id="L340">			final TValue result = executeOneLineSafe(memory, s, ftype, modeSpecial);</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">			if (result != null)</span>
<span class="fc" id="L342">				return result;</span>

<span class="fc" id="L344">			it.next();</span>
<span class="fc" id="L345">		}</span>
<span class="fc" id="L346">		return null;</span>

	}

	private void executeLinesInternal(TMemory memory, List&lt;StringLocated&gt; body, TFunctionType ftype)
			throws EaterException {
<span class="nc" id="L352">		final CodeIterator it = buildCodeIterator(memory, body);</span>

<span class="nc" id="L354">		StringLocated s = null;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">		while ((s = it.peek()) != null) {</span>
<span class="nc" id="L356">			executeOneLineSafe(memory, s, ftype, false);</span>
<span class="nc" id="L357">			it.next();</span>
		}

<span class="nc" id="L360">	}</span>

	private TValue executeOneLineSafe(TMemory memory, StringLocated s, TFunctionType ftype, boolean modeSpecial)
			throws EaterException {
		try {
<span class="fc" id="L365">			this.debug.add(s);</span>
<span class="fc" id="L366">			return executeOneLineNotSafe(memory, s, ftype, modeSpecial);</span>
<span class="fc" id="L367">		} catch (Exception e) {</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">			if (e instanceof EaterException)</span>
<span class="fc" id="L369">				throw (EaterException) e;</span>
<span class="nc" id="L370">			Logme.error(e);</span>
<span class="nc" id="L371">			throw new EaterException(&quot;Fatal parsing error&quot;, s);</span>
		}
	}

	private TValue executeOneLineNotSafe(TMemory memory, StringLocated s, TFunctionType ftype, boolean modeSpecial)
			throws EaterException {
<span class="fc" id="L377">		final TLineType type = s.getType();</span>

<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if (type == TLineType.INCLUDESUB) {</span>
<span class="nc" id="L380">			this.executeIncludesub(memory, s);</span>
<span class="nc" id="L381">			return null;</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">		} else if (type == TLineType.THEME) {</span>
<span class="fc" id="L383">			this.executeTheme(memory, s);</span>
<span class="fc" id="L384">			return null;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">		} else if (type == TLineType.INCLUDE) {</span>
<span class="fc" id="L386">			this.executeInclude(memory, s);</span>
<span class="fc" id="L387">			return null;</span>
//		} else if (type == TLineType.INCLUDE_SPRITES) {
//			this.executeIncludeSprites(memory, s);
//			return null;
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">		} else if (type == TLineType.INCLUDE_DEF) {</span>
<span class="nc" id="L392">			this.executeIncludeDef(memory, s);</span>
<span class="nc" id="L393">			return null;</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">		} else if (type == TLineType.IMPORT) {</span>
<span class="nc" id="L395">			this.executeImport(memory, s);</span>
<span class="nc" id="L396">			return null;</span>
		}
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">		if (type == TLineType.DUMP_MEMORY) {</span>
<span class="nc" id="L399">			this.executeDumpMemory(memory, s.getTrimmed());</span>
<span class="nc" id="L400">			return null;</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">		} else if (type == TLineType.ASSERT) {</span>
<span class="nc" id="L402">			this.executeAssert(memory, s.getTrimmed());</span>
<span class="nc" id="L403">			return null;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">		} else if (type == TLineType.OPTION) {</span>
<span class="nc" id="L405">			this.executeOption(memory, s.getTrimmed());</span>
<span class="nc" id="L406">			return null;</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">		} else if (type == TLineType.UNDEF) {</span>
<span class="nc" id="L408">			this.executeUndef(memory, s);</span>
<span class="nc" id="L409">			return null;</span>
<span class="pc bpc" id="L410" title="1 of 4 branches missed.">		} else if (ftype != TFunctionType.RETURN_FUNCTION &amp;&amp; type == TLineType.PLAIN) {</span>
<span class="fc" id="L411">			this.addPlain(memory, s);</span>
<span class="fc" id="L412">			return null;</span>
<span class="pc bpc" id="L413" title="1 of 4 branches missed.">		} else if (ftype == TFunctionType.RETURN_FUNCTION &amp;&amp; type == TLineType.RETURN) {</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">			if (modeSpecial) {</span>
<span class="fc" id="L415">				final EaterReturn eaterReturn = new EaterReturn(s);</span>
<span class="fc" id="L416">				eaterReturn.analyze(this, memory);</span>
<span class="fc" id="L417">				final TValue result = eaterReturn.getValue2();</span>
<span class="fc" id="L418">				return result;</span>
			}
			// Actually, ignore because we are in a if
<span class="nc" id="L421">			return null;</span>
<span class="pc bpc" id="L422" title="2 of 4 branches missed.">		} else if (ftype == TFunctionType.RETURN_FUNCTION &amp;&amp; type == TLineType.PLAIN) {</span>
<span class="fc" id="L423">			this.simulatePlain(memory, s);</span>
<span class="fc" id="L424">			return null;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">		} else if (type == TLineType.AFFECTATION_DEFINE) {</span>
<span class="nc" id="L426">			this.executeAffectationDefine(memory, s);</span>
<span class="nc" id="L427">			return null;</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">		} else if (ftype == null &amp;&amp; type == TLineType.END_FUNCTION) {</span>
<span class="nc" id="L429">			CommandExecutionResult.error(&quot;error endfunc&quot;);</span>
<span class="nc" id="L430">			return null;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">		} else if (type == TLineType.LOG) {</span>
<span class="nc" id="L432">			this.executeLog(memory, s);</span>
<span class="nc" id="L433">			return null;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		} else if (s.getString().matches(&quot;^\\s+$&quot;)) {</span>
<span class="nc" id="L435">			return null;</span>
		} else {
<span class="nc" id="L437">			throw new EaterException(&quot;Compile Error &quot; + ftype + &quot; &quot; + type, s);</span>
		}
	}

	private void addPlain(TMemory memory, StringLocated s) throws EaterException {
<span class="fc" id="L442">		final StringLocated tmp[] = applyFunctionsAndVariablesInternal(memory, s);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">		if (tmp != null) {</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">			if (pendingAdd != null) {</span>
<span class="fc" id="L445">				tmp[0] = new StringLocated(pendingAdd + tmp[0].getString(), tmp[0].getLocation());</span>
<span class="fc" id="L446">				pendingAdd = null;</span>
			}
<span class="fc bfc" id="L448" title="All 2 branches covered.">			for (StringLocated line : tmp)</span>
<span class="fc" id="L449">				addToResultList(line);</span>

		}
<span class="fc" id="L452">	}</span>

	private boolean addToResultList(StringLocated line) {
		if (Jaws.TRACE)
			System.err.println(&quot;adding &quot; + line);
<span class="fc" id="L457">		return resultList.add(line);</span>
	}

	private void simulatePlain(TMemory memory, StringLocated s) throws EaterException {
<span class="fc" id="L461">		final StringLocated ignored[] = applyFunctionsAndVariablesInternal(memory, s);</span>
<span class="fc" id="L462">	}</span>

	private void executeAffectationDefine(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L465">		new EaterAffectationDefine(s).analyze(this, memory);</span>
<span class="nc" id="L466">	}</span>

	private void executeDumpMemory(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L469">		final EaterDumpMemory condition = new EaterDumpMemory(s);</span>
<span class="nc" id="L470">		condition.analyze(this, memory);</span>
<span class="nc" id="L471">	}</span>

	private void executeAssert(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L474">		final EaterAssert condition = new EaterAssert(s);</span>
<span class="nc" id="L475">		condition.analyze(this, memory);</span>
<span class="nc" id="L476">	}</span>

	private void executeOption(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L479">		final EaterOption condition = new EaterOption(s);</span>
<span class="nc" id="L480">		condition.analyze(this, memory);</span>
<span class="nc" id="L481">	}</span>

	private void executeUndef(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L484">		final EaterUndef undef = new EaterUndef(s);</span>
<span class="nc" id="L485">		undef.analyze(this, memory);</span>
<span class="nc" id="L486">	}</span>

	@JawsStrange
	private StringLocated[] applyFunctionsAndVariablesInternal(TMemory memory, StringLocated located)
			throws EaterException {
<span class="pc bpc" id="L491" title="1 of 4 branches missed.">		if (memory.isEmpty() &amp;&amp; functionsSet.size() == 0)</span>
<span class="nc" id="L492">			return new StringLocated[] { located };</span>

<span class="fc" id="L494">		final String result = applyFunctionsAndVariables(memory, located);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">		if (result == null)</span>
<span class="fc" id="L496">			return null;</span>

<span class="pc bpc" id="L498" title="1 of 2 branches missed.">		if (Pragma.legacyReplaceBackslashNByNewline()) {</span>
<span class="fc" id="L499">			final String[] splited = result.split(&quot;\n&quot;);</span>
<span class="fc" id="L500">			final StringLocated[] tab = new StringLocated[splited.length];</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">			for (int i = 0; i &lt; splited.length; i++)</span>
<span class="fc" id="L502">				tab[i] = new StringLocated(splited[i], located.getLocation());</span>

<span class="fc" id="L504">			return tab;</span>
		}
<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (result.contains(&quot;\n&quot;))</span>
<span class="nc" id="L507">			throw new IllegalStateException(result);</span>
<span class="nc" id="L508">		return new StringLocated[] { new StringLocated(result, located.getLocation()) };</span>

	}

<span class="fc" id="L512">	private String pendingAdd = null;</span>

	@JawsStrange
	public String applyFunctionsAndVariables(TMemory memory, final StringLocated str) throws EaterException {
		// https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm
		// https://stackoverflow.com/questions/1326682/java-replacing-multiple-different-substring-in-a-string-at-once-or-in-the-most
		// https://en.wikipedia.org/wiki/String-searching_algorithm
		// https://www.quora.com/What-is-the-most-efficient-algorithm-to-replace-all-occurrences-of-a-pattern-P-in-a-string-with-a-pattern-P
		// https://en.wikipedia.org/wiki/Trie
<span class="pc bpc" id="L521" title="1 of 4 branches missed.">		if (memory.isEmpty() &amp;&amp; functionsSet.size() == 0)</span>
<span class="nc" id="L522">			return str.getString();</span>

<span class="fc" id="L524">		final StringBuilder result = new StringBuilder();</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">		for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc" id="L526">			final char c = str.charAt(i);</span>
<span class="fc" id="L527">			final String presentFunction = getFunctionNameAt(str.getString(), i);</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">			if (presentFunction != null) {</span>
<span class="fc" id="L529">				final String sub = str.getString().substring(i);</span>
<span class="fc" id="L530">				final EaterFunctionCall call = new EaterFunctionCall(new StringLocated(sub, str.getLocation()),</span>
<span class="fc" id="L531">						isLegacyDefine(presentFunction), isUnquoted(presentFunction));</span>
<span class="fc" id="L532">				call.analyze(this, memory);</span>
<span class="fc" id="L533">				final TFunctionSignature signature = new TFunctionSignature(presentFunction, call.getValues().size(),</span>
<span class="fc" id="L534">						call.getNamedArguments().keySet());</span>
<span class="fc" id="L535">				final TFunction function = functionsSet.getFunctionSmart(signature);</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">				if (function == null)</span>
<span class="nc" id="L537">					throw new EaterException(&quot;Function not found &quot; + presentFunction, str);</span>

<span class="fc bfc" id="L539" title="All 2 branches covered.">				if (function.getFunctionType() == TFunctionType.PROCEDURE) {</span>
<span class="fc" id="L540">					this.pendingAdd = result.toString();</span>
<span class="fc" id="L541">					executeVoid3(str, memory, function, call);</span>
<span class="fc" id="L542">					i += call.getCurrentPosition();</span>
<span class="fc" id="L543">					final String remaining = str.getString().substring(i);</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">					if (remaining.length() &gt; 0)</span>
<span class="fc" id="L545">						appendToLastResult(remaining);</span>

<span class="fc" id="L547">					return null;</span>
				}
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">				if (function.getFunctionType() == TFunctionType.LEGACY_DEFINELONG) {</span>
<span class="nc" id="L550">					this.pendingAdd = str.getString().substring(0, i);</span>
<span class="nc" id="L551">					executeVoid3(str, memory, function, call);</span>
<span class="nc" id="L552">					return null;</span>
				}
<span class="pc bfc" id="L554" title="All 2 branches covered.">				assert function.getFunctionType() == TFunctionType.RETURN_FUNCTION</span>
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">						|| function.getFunctionType() == TFunctionType.LEGACY_DEFINE;</span>
<span class="fc" id="L556">				final TValue functionReturn = function.executeReturnFunction(this, memory, str, call.getValues(),</span>
<span class="fc" id="L557">						call.getNamedArguments());</span>
<span class="fc" id="L558">				String tmp = functionReturn.toString();</span>
				// if (tmp.indexOf(Jaws.BLOCK_E1_NEWLINE) &gt; 0)
				// System.err.println(&quot;tmp=&quot; + tmp + &quot; (&quot; + function.getFunctionType() + &quot;)&quot;);
				// if (function.getFunctionType() == TFunctionType.RETURN_FUNCTION &amp;&amp;
				// tmp.length() &gt; 1) {
				// System.err.println(&quot;JE REPLACE&quot;);
				// tmp = StringLocated.expandsJaws32(tmp);
				// tmp = tmp.replace(Jaws.BLOCK_E1_NEWLINE, '\n');
				// System.err.println(&quot;DONC tmp=&quot; + tmp);
				// }
<span class="fc" id="L568">				result.append(tmp);</span>
<span class="fc" id="L569">				i += call.getCurrentPosition() - 1;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">			} else if (new VariableManager(this, memory, str).getVarnameAt(str.getString(), i) != null) {</span>
<span class="fc" id="L571">				i = new VariableManager(this, memory, str).replaceVariables(str.getString(), i, result);</span>
			} else {
<span class="fc" id="L573">				result.append(c);</span>
			}
		}
<span class="fc" id="L576">		return result.toString();</span>
	}

	private void appendToLastResult(String remaining) {
<span class="fc" id="L580">		final StringLocated last = this.resultList.get(this.resultList.size() - 1);</span>
<span class="fc" id="L581">		this.resultList.set(this.resultList.size() - 1, last.append(remaining));</span>
<span class="fc" id="L582">	}</span>

	private void executeVoid3(StringLocated location, TMemory memory, TFunction function, EaterFunctionCall call)
			throws EaterException {
<span class="fc" id="L586">		function.executeProcedureInternal(this, memory, location, call.getValues(), call.getNamedArguments());</span>
<span class="fc" id="L587">	}</span>

	private void executeImport(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L590">		final EaterImport _import = new EaterImport(s.getTrimmed());</span>
<span class="nc" id="L591">		_import.analyze(this, memory);</span>

		try {
<span class="nc" id="L594">			final SFile file = FileSystem.getInstance()</span>
<span class="nc" id="L595">					.getFile(applyFunctionsAndVariables(memory, new StringLocated(_import.getWhat(), s.getLocation())));</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">			if (file.exists() &amp;&amp; file.isDirectory() == false) {</span>
<span class="nc" id="L597">				pathSystem.addImportFile(file);</span>
<span class="nc" id="L598">				return;</span>
			}
<span class="nc" id="L600">		} catch (IOException e) {</span>
<span class="nc" id="L601">			Logme.error(e);</span>
<span class="nc" id="L602">			throw new EaterException(&quot;Cannot import &quot; + e.getMessage(), s);</span>
<span class="nc" id="L603">		}</span>

<span class="nc" id="L605">		throw new EaterException(&quot;Cannot import&quot;, s);</span>
	}

	private void executeLog(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L609">		final EaterLog log = new EaterLog(s.getTrimmed());</span>
<span class="nc" id="L610">		log.analyze(this, memory);</span>
<span class="nc" id="L611">	}</span>

//	public FileWithSuffix getFileWithSuffix(String from, String realName) throws IOException {
//		throw new IOException(&quot;to be finished&quot;);
////		final String s = ThemeUtils.getFullPath(from, realName);
////		final FileWithSuffix file = importedFiles.getFile(s, null);
////		return file;
//
//	}

	private void executeIncludesub(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L622">		PathSystem saveImportedFiles = null;</span>
		try {
<span class="nc" id="L624">			final EaterIncludesub include = new EaterIncludesub(s.getTrimmed());</span>
<span class="nc" id="L625">			include.analyze(this, memory);</span>
<span class="nc" id="L626">			final String what = include.getWhat();</span>
<span class="nc" id="L627">			final int idx = what.indexOf('!');</span>
<span class="nc" id="L628">			Sub sub = null;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">			if (idx != -1) {</span>
<span class="nc" id="L630">				final String filename = what.substring(0, idx);</span>
<span class="nc" id="L631">				final String blocname = what.substring(idx + 1);</span>
				try {
<span class="nc" id="L633">					final InputFile f2 = pathSystem.getFile(filename, null);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">					if (f2 != null) {</span>
<span class="nc" id="L635">						saveImportedFiles = this.pathSystem;</span>
<span class="nc" id="L636">						this.pathSystem = this.pathSystem.withCurrentDir(f2.getParentFolder());</span>
<span class="nc" id="L637">						final Reader reader = f2.getReader(charset);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">						if (reader == null)</span>
<span class="nc" id="L639">							throw new EaterException(&quot;cannot include &quot; + what, s);</span>

						try {
<span class="nc" id="L642">							ReadLine readerline = ReadLineReader.create(reader, what, s.getLocation());</span>
<span class="nc" id="L643">							readerline = new UncommentReadLine(readerline);</span>
<span class="nc" id="L644">							sub = Sub.fromFile(readerline, blocname, this, memory);</span>
						} finally {
<span class="nc" id="L646">							reader.close();</span>
						}
					}
<span class="nc" id="L649">				} catch (IOException e) {</span>
<span class="nc" id="L650">					Logme.error(e);</span>
<span class="nc" id="L651">					throw new EaterException(&quot;cannot include &quot; + what, s);</span>
<span class="nc" id="L652">				}</span>
			}
<span class="nc bnc" id="L654" title="All 2 branches missed.">			if (sub == null)</span>
<span class="nc" id="L655">				sub = subs.get(what);</span>

<span class="nc bnc" id="L657" title="All 2 branches missed.">			if (sub == null)</span>
<span class="nc" id="L658">				throw new EaterException(&quot;cannot include &quot; + what, s);</span>

<span class="nc" id="L660">			executeLinesInternal(memory, sub.lines(), null);</span>
		} finally {
<span class="nc bnc" id="L662" title="All 2 branches missed.">			if (saveImportedFiles != null)</span>
<span class="nc" id="L663">				this.pathSystem = saveImportedFiles;</span>

		}
<span class="nc" id="L666">	}</span>

	private void executeIncludeDef(TMemory memory, StringLocated s) throws EaterException {
<span class="nc" id="L669">		final EaterIncludeDef include = new EaterIncludeDef(s.getTrimmed());</span>
<span class="nc" id="L670">		include.analyze(this, memory);</span>
<span class="nc" id="L671">		final String definitionName = include.getLocation();</span>
<span class="nc" id="L672">		final List&lt;String&gt; definition = definitionsContainer.getDefinition(definitionName);</span>
<span class="nc" id="L673">		final ReadLine reader2 = new ReadLineList(definition, s.getLocation());</span>

		try {
<span class="nc" id="L676">			final List&lt;StringLocated&gt; body = new ArrayList&lt;&gt;();</span>
			do {
<span class="nc" id="L678">				final StringLocated sl = reader2.readLine();</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">				if (sl == null) {</span>
<span class="nc" id="L680">					executeLinesInternal(memory, body, null);</span>
<span class="nc" id="L681">					return;</span>
				}
<span class="nc" id="L683">				body.add(sl);</span>
<span class="nc" id="L684">			} while (true);</span>
<span class="nc" id="L685">		} catch (IOException e) {</span>
<span class="nc" id="L686">			Logme.error(e);</span>
<span class="nc" id="L687">			throw new EaterException(&quot;&quot; + e, s);</span>
		} finally {
			try {
<span class="nc" id="L690">				reader2.close();</span>
<span class="nc" id="L691">			} catch (IOException e) {</span>
<span class="nc" id="L692">				Logme.error(e);</span>
<span class="nc" id="L693">			}</span>
		}
	}

<span class="fc" id="L697">	private JsonObject themeMetadata = new JsonObject();</span>

	public JsonObject getThemeMetadata() {
<span class="nc" id="L700">		return themeMetadata;</span>
	}

	private void executeTheme(TMemory memory, StringLocated s) throws EaterException {
<span class="fc" id="L704">		final EaterTheme eater = new EaterTheme(s.getTrimmed(), pathSystem);</span>
<span class="fc" id="L705">		eater.analyze(this, memory);</span>
<span class="fc" id="L706">		final Theme theme = eater.getTheme();</span>
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">		if (theme == null)</span>
<span class="nc" id="L708">			throw new EaterException(&quot;No such theme &quot; + eater.getName(), s);</span>

<span class="fc" id="L710">		final PathSystem saveImportedFiles = this.pathSystem;</span>
<span class="fc" id="L711">		this.pathSystem = eater.getNewImportedFiles();</span>

		try {
<span class="fc" id="L714">			final List&lt;StringLocated&gt; body = new ArrayList&lt;&gt;();</span>
			do {
<span class="fc" id="L716">				final StringLocated sl = theme.readLine();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">				if (sl == null) {</span>
<span class="fc" id="L718">					executeLines(memory, body, null, false);</span>
<span class="fc" id="L719">					return;</span>
				}
<span class="fc" id="L721">				body.add(sl);</span>
<span class="fc" id="L722">			} while (true);</span>
<span class="nc" id="L723">		} catch (IOException e) {</span>
<span class="nc" id="L724">			Logme.error(e);</span>
<span class="nc" id="L725">			throw new EaterException(&quot;Error reading theme &quot; + e, s);</span>
		} finally {
<span class="fc" id="L727">			this.themeMetadata = theme.getMetadata();</span>
<span class="fc" id="L728">			this.pathSystem = saveImportedFiles;</span>
			try {
<span class="fc" id="L730">				theme.close();</span>
<span class="nc" id="L731">			} catch (IOException e) {</span>
<span class="nc" id="L732">				Logme.error(e);</span>
<span class="fc" id="L733">			}</span>
		}
	}

//	private void executeIncludeSprites(TMemory memory, StringLocated s) throws EaterException {
//		final EaterIncludeSprites include = new EaterIncludeSprites(s.getTrimmed());
//		include.analyze(this, memory);
//		final String what = include.getWhat();
//		if (what.startsWith(&quot;&lt;&quot;) &amp;&amp; what.endsWith(&quot;&gt;&quot;)) {
//			ReadLine reader = null;
//			try {
//				reader = PreprocessorUtils.getReaderStdlibIncludeSprites(s, what.substring(1, what.length() - 1));
//				final List&lt;StringLocated&gt; body = new ArrayList&lt;&gt;();
//				do {
//					final StringLocated sl = reader.readLine();
//					if (sl == null) {
//						executeLines(memory, body, null, false);
//						return;
//					}
//					body.add(sl);
//				} while (true);
//			} catch (IOException e) {
//				Logme.error(e);
//				throw new EaterException(&quot;cannot include &quot; + e, s);
//			} finally {
//				if (reader != null)
//					try {
//						reader.close();
//					} catch (IOException e) {
//						Logme.error(e);
//					}
//			}
//
//		}
//		throw new EaterException(&quot;cannot include sprites from &quot; + what, s);
//	}

	private void executeInclude(TMemory memory, StringLocated s) throws EaterException {
<span class="fc" id="L771">		final EaterInclude include = new EaterInclude(s.getTrimmed());</span>
<span class="fc" id="L772">		include.analyze(this, memory);</span>
<span class="fc" id="L773">		String what = include.getWhat();</span>
<span class="fc" id="L774">		final PreprocessorIncludeStrategy strategy = include.getPreprocessorIncludeStrategy();</span>
<span class="fc" id="L775">		final int idx = what.lastIndexOf('!');</span>
<span class="fc" id="L776">		String suf = null;</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">		if (idx != -1) {</span>
<span class="nc" id="L778">			suf = what.substring(idx + 1);</span>
<span class="nc" id="L779">			what = what.substring(0, idx);</span>
		}

<span class="fc" id="L782">		ReadLine reader = null;</span>
<span class="fc" id="L783">		PathSystem saveImportedFiles = null;</span>
		try {
<span class="pc bpc" id="L785" title="2 of 4 branches missed.">			if (what.startsWith(&quot;http://&quot;) || what.startsWith(&quot;https://&quot;)) {</span>
<span class="nc" id="L786">				final SURL url = SURL.create(what);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">				if (url == null)</span>
<span class="nc" id="L788">					throw new EaterException(&quot;Cannot open URL&quot;, s);</span>

<span class="nc" id="L790">				reader = PreprocessorUtils.getReaderIncludeUrl(url, s, suf, charset);</span>
<span class="pc bpc" id="L791" title="1 of 4 branches missed.">			} else if (what.startsWith(&quot;&lt;&quot;) &amp;&amp; what.endsWith(&quot;&gt;&quot;)) {</span>
<span class="fc" id="L792">				final String stdlibPath = what.substring(1, what.length() - 1);</span>
//				final String libname = stdlibPath.substring(0, stdlibPath.indexOf('/'));
<span class="fc" id="L794">				saveImportedFiles = this.pathSystem;</span>
<span class="fc" id="L795">				InputFile tmp = this.pathSystem.getInputFile(what);</span>
<span class="fc" id="L796">				this.pathSystem = this.pathSystem.changeCurrentDirectory(tmp.getParentFolder());</span>
				// this.importedFiles = this.importedFiles.withCurrentDir(new
				// AParentFolderStdlib(s, libname));
<span class="fc" id="L799">				reader = PreprocessorUtils.getReaderStdlibInclude(s, stdlibPath);</span>
				// ::comment when __CORE__
<span class="pc bpc" id="L801" title="3 of 4 branches missed.">			} else if (what.startsWith(&quot;[&quot;) &amp;&amp; what.endsWith(&quot;]&quot;)) {</span>
<span class="nc" id="L802">				throw new IOException(&quot;To be finished&quot;);</span>
				// reader = PreprocessorUtils.getReaderNonstandardInclude(s, what.substring(1,
				// what.length() - 1));
				// ::done
//			} else if (importedFiles.getCurrentDir() instanceof AParentFolderStdlib) {
//				final AParentFolderStdlib folderStdlib = (AParentFolderStdlib) importedFiles.getCurrentDir();
//				reader = folderStdlib.getReader(what);
			} else {
<span class="fc" id="L810">				final InputFile f2 = this.pathSystem.getInputFile(what);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">				if (f2 != null) {</span>
<span class="pc bpc" id="L812" title="2 of 4 branches missed.">					if (strategy == PreprocessorIncludeStrategy.DEFAULT &amp;&amp; filesUsedCurrent.contains(f2))</span>
<span class="nc" id="L813">						return;</span>

<span class="pc bpc" id="L815" title="3 of 4 branches missed.">					if (strategy == PreprocessorIncludeStrategy.ONCE &amp;&amp; filesUsedCurrent.contains(f2))</span>
<span class="nc" id="L816">						throw new EaterException(&quot;This file has already been included&quot;, s);</span>

<span class="fc" id="L818">					reader = DiagramDetector.extractFromFile(f2, &quot;desc2&quot;);</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">					if (reader == null) {</span>
<span class="fc" id="L821">						final Reader tmp = f2.getReader(charset);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">						if (tmp == null)</span>
<span class="nc" id="L823">							throw new EaterException(&quot;Cannot include file&quot;, s);</span>

<span class="fc" id="L825">						reader = ReadLineReader.create(tmp, what, s.getLocation());</span>
					}
<span class="fc" id="L827">					saveImportedFiles = this.pathSystem;</span>
<span class="fc" id="L828">					this.pathSystem = this.pathSystem.withCurrentDir(f2.getParentFolder());</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">					assert reader != null;</span>
					// filesUsedCurrent.add(f2);
				}
			}
<span class="fc bfc" id="L833" title="All 2 branches covered.">			if (reader != null)</span>
				try {
<span class="fc" id="L835">					final List&lt;StringLocated&gt; body = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L836">					reader = new ReadLineWithYamlHeader(reader);</span>
					do {
<span class="fc" id="L838">						final StringLocated sl = reader.readLine();</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">						if (sl == null) {</span>
<span class="fc" id="L840">							executeLines(memory, body, null, false);</span>
<span class="fc" id="L841">							return;</span>
						}
<span class="fc" id="L843">						body.add(sl);</span>
<span class="fc" id="L844">					} while (true);</span>
				} finally {
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">					if (saveImportedFiles != null)</span>
<span class="fc" id="L847">						this.pathSystem = saveImportedFiles;</span>

				}

<span class="nc" id="L851">		} catch (IOException e) {</span>
<span class="nc" id="L852">			Logme.error(e);</span>
<span class="nc" id="L853">			throw new EaterException(&quot;cannot include &quot; + e, s);</span>
		} finally {
<span class="fc bfc" id="L855" title="All 2 branches covered.">			if (reader != null)</span>
				try {
<span class="fc" id="L857">					reader.close();</span>
<span class="nc" id="L858">				} catch (IOException e) {</span>
<span class="nc" id="L859">					Logme.error(e);</span>
<span class="fc" id="L860">				}</span>

		}

<span class="fc" id="L864">		throw new EaterException(&quot;cannot include &quot; + what, s);</span>
	}

	public boolean isLegacyDefine(String functionName) {
<span class="fc bfc" id="L868" title="All 2 branches covered.">		for (Map.Entry&lt;TFunctionSignature, TFunction&gt; ent : functionsSet.functions().entrySet())</span>
<span class="fc bfc" id="L869" title="All 4 branches covered.">			if (ent.getKey().getFunctionName().equals(functionName) &amp;&amp; ent.getValue().getFunctionType().isLegacy())</span>
<span class="fc" id="L870">				return true;</span>

<span class="fc" id="L872">		return false;</span>
	}

	public boolean isUnquoted(String functionName) {
<span class="fc bfc" id="L876" title="All 2 branches covered.">		for (Map.Entry&lt;TFunctionSignature, TFunction&gt; ent : functionsSet.functions().entrySet())</span>
<span class="fc bfc" id="L877" title="All 4 branches covered.">			if (ent.getKey().getFunctionName().equals(functionName) &amp;&amp; ent.getValue().isUnquoted())</span>
<span class="fc" id="L878">				return true;</span>

<span class="fc" id="L880">		return false;</span>
	}

	public boolean doesFunctionExist(String functionName) {
<span class="fc bfc" id="L884" title="All 2 branches covered.">		for (Map.Entry&lt;TFunctionSignature, TFunction&gt; ent : functionsSet.functions().entrySet())</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">			if (ent.getKey().getFunctionName().equals(functionName))</span>
<span class="fc" id="L886">				return true;</span>

<span class="fc" id="L888">		return false;</span>
	}

	@JawsStrange
	private String getFunctionNameAt(String s, int pos) {
<span class="fc bfc" id="L893" title="All 4 branches covered.">		final boolean justAfterALetter = pos &gt; 0 &amp;&amp; TLineType.isLetterOrEmojiOrUnderscoreOrDigit(s.charAt(pos - 1))</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">				&amp;&amp; VariableManager.justAfterBackslashN(s, pos) == false;</span>
<span class="pc bpc" id="L895" title="1 of 6 branches missed.">		if (justAfterALetter &amp;&amp; s.charAt(pos) != '%' &amp;&amp; s.charAt(pos) != '$')</span>
<span class="fc" id="L896">			return null;</span>

<span class="fc" id="L898">		final String fname = functionsSet.getLonguestMatchStartingIn(s, pos);</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">		if (fname.length() == 0)</span>
<span class="fc" id="L900">			return null;</span>

<span class="fc" id="L902">		return fname.substring(0, fname.length() - 1);</span>
	}

	public List&lt;StringLocated&gt; getResultList() {
<span class="fc" id="L906">		return resultList;</span>
	}

	public List&lt;StringLocated&gt; getDebug() {
<span class="fc" id="L910">		return debug;</span>
	}

	public String extractFromResultList(int n1) {
<span class="nc" id="L914">		final StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">		while (resultList.size() &gt; n1) {</span>
<span class="nc" id="L916">			sb.append(resultList.get(n1).getString());</span>
<span class="nc" id="L917">			resultList.remove(n1);</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">			if (resultList.size() &gt; n1)</span>
<span class="nc" id="L919">				sb.append(Jaws.BLOCK_E1_NEWLINE);</span>

		}
<span class="nc" id="L922">		return sb.toString();</span>
	}

	public void appendEndOfLine(String endOfLine) {
<span class="nc bnc" id="L926" title="All 2 branches missed.">		if (endOfLine.length() &gt; 0) {</span>
<span class="nc" id="L927">			final int idx = resultList.size() - 1;</span>
<span class="nc" id="L928">			StringLocated last = resultList.get(idx);</span>
<span class="nc" id="L929">			last = last.append(endOfLine);</span>
<span class="nc" id="L930">			resultList.set(idx, last);</span>
		}
<span class="nc" id="L932">	}</span>

	public TFunction getFunctionSmart(TFunctionSignature signature) {
<span class="nc" id="L935">		return functionsSet.getFunctionSmart(signature);</span>
	}

	/**
	 * Retrieve data given after @startuml.
	 */
	public Optional&lt;String&gt; getXargs() {
<span class="nc bnc" id="L942" title="All 2 branches missed.">		if (resultList.size() == 0)</span>
<span class="nc" id="L943">			return Optional.empty();</span>

<span class="nc" id="L945">		final String first = resultList.get(0).toString();</span>
<span class="nc" id="L946">		final int idx = first.indexOf(' ');</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">		if (idx == -1)</span>
<span class="nc" id="L948">			return Optional.empty();</span>

<span class="nc" id="L950">		return Optional.of(first.substring(idx + 1).trim());</span>
	}

	public PreprocessingArtifact getPreprocessingArtifact() {
<span class="fc" id="L954">		return preprocessingArtifact;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>