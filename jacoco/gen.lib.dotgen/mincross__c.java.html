<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>mincross__c.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">gen.lib.dotgen</a> &gt; <span class="el_source">mincross__c.java</span></div><h1>mincross__c.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of Smetana.
 * Smetana is a partial translation of Graphviz/Dot sources from C to Java.
 *
 * (C) Copyright 2009-2022, Arnaud Roques
 *
 * This translation is distributed under the same Licence as the original C program:
 * 
 *************************************************************************
 * Copyright (c) 2011 AT&amp;T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 * LICENSE (&quot;AGREEMENT&quot;). [Eclipse Public License - v 1.0]
 * 
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package gen.lib.dotgen;
import static gen.lib.cgraph.attr__c.agget;
import static gen.lib.cgraph.edge__c.agfstout;
import static gen.lib.cgraph.edge__c.aghead;
import static gen.lib.cgraph.edge__c.agnxtout;
import static gen.lib.cgraph.edge__c.agtail;
import static gen.lib.cgraph.graph__c.agnedges;
import static gen.lib.cgraph.node__c.agfstnode;
import static gen.lib.cgraph.node__c.agnxtnode;
import static gen.lib.cgraph.obj__c.agcontains;
import static gen.lib.common.utils__c.dequeue;
import static gen.lib.common.utils__c.enqueue;
import static gen.lib.common.utils__c.free_queue;
import static gen.lib.common.utils__c.mapbool;
import static gen.lib.common.utils__c.new_queue;
import static gen.lib.dotgen.class2__c.class2;
import static gen.lib.dotgen.cluster__c.expand_cluster;
import static gen.lib.dotgen.cluster__c.install_cluster;
import static gen.lib.dotgen.cluster__c.mark_lowclusters;
import static gen.lib.dotgen.decomp__c.decompose;
import static gen.lib.dotgen.dotinit__c.dot_root;
import static gen.lib.dotgen.fastgr__c.delete_flat_edge;
import static gen.lib.dotgen.fastgr__c.flat_edge;
import static gen.lib.dotgen.fastgr__c.merge_oneway;
import static gen.lib.dotgen.fastgr__c.new_virtual_edge;
import static smetana.core.JUtils.atof;
import static smetana.core.JUtils.qsort;
import static smetana.core.JUtils.qsortInt;
import static smetana.core.Macro.ALLOC_INT;
import static smetana.core.Macro.CLUSTER;
import static smetana.core.Macro.ED_edge_type;
import static smetana.core.Macro.ED_head_port;
import static smetana.core.Macro.ED_label;
import static smetana.core.Macro.ED_tail_port;
import static smetana.core.Macro.ED_to_orig;
import static smetana.core.Macro.ED_to_virt;
import static smetana.core.Macro.ED_weight;
import static smetana.core.Macro.ED_xpenalty;
import static smetana.core.Macro.FLATORDER;
import static smetana.core.Macro.GD_clust;
import static smetana.core.Macro.GD_comp;
import static smetana.core.Macro.GD_flags;
import static smetana.core.Macro.GD_flip;
import static smetana.core.Macro.GD_has_flat_edges;
import static smetana.core.Macro.GD_maxrank;
import static smetana.core.Macro.GD_minrank;
import static smetana.core.Macro.GD_n_cluster;
import static smetana.core.Macro.GD_n_nodes;
import static smetana.core.Macro.GD_nlist;
import static smetana.core.Macro.GD_rank;
import static smetana.core.Macro.GD_rankleader;
import static smetana.core.Macro.INT_MAX;
import static smetana.core.Macro.ND_clust;
import static smetana.core.Macro.ND_coord;
import static smetana.core.Macro.ND_flat_in;
import static smetana.core.Macro.ND_flat_out;
import static smetana.core.Macro.ND_has_port;
import static smetana.core.Macro.ND_in;
import static smetana.core.Macro.ND_low;
import static smetana.core.Macro.ND_mark;
import static smetana.core.Macro.ND_mval;
import static smetana.core.Macro.ND_next;
import static smetana.core.Macro.ND_node_type;
import static smetana.core.Macro.ND_onstack;
import static smetana.core.Macro.ND_order;
import static smetana.core.Macro.ND_other;
import static smetana.core.Macro.ND_out;
import static smetana.core.Macro.ND_prev;
import static smetana.core.Macro.ND_rank;
import static smetana.core.Macro.ND_ranktype;
import static smetana.core.Macro.ND_weight_class;
import static smetana.core.Macro.NEW_RANK;
import static smetana.core.Macro.NORMAL;
import static smetana.core.Macro.UNSUPPORTED;
import static smetana.core.Macro.VIRTUAL;
import static smetana.core.Macro.elist_append;
import static smetana.core.Macro.flatindex;
import static smetana.core.debug.SmetanaDebug.ENTERING;
import static smetana.core.debug.SmetanaDebug.LEAVING;

import gen.annotation.Difficult;
import gen.annotation.Original;
import gen.annotation.Reviewed;
import gen.annotation.Unused;
import h.ST_Agedge_s;
import h.ST_Agnode_s;
import h.ST_Agraph_s;
import h.ST_adjmatrix_t;
import h.ST_elist;
import h.ST_nodequeue;
import h.ST_rank_t;
import smetana.core.CArray;
import smetana.core.CArrayOfStar;
import smetana.core.CFunction;
import smetana.core.CFunctionAbstract;
import smetana.core.CString;
import smetana.core.Globals;
import smetana.core.Memory;
import smetana.core.ZType;

/* 
 * dot_mincross(g) takes a ranked graphs, and finds an ordering
 * that avoids edge crossings.  clusters are expanded.
 * N.B. the rank structure is global (not allocated per cluster)
 * because mincross may compare nodes in different clusters.
 */
<span class="nc" id="L152">public class mincross__c {</span>



/* dot_mincross:
 * Minimize edge crossings
 * Note that nodes are not placed into GD_rank(g) until mincross()
 * is called.
 */
@Unused
@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;dot_mincross&quot;, key=&quot;e876vp4hgkzshluz6qk77cjwk&quot;, definition=&quot;void dot_mincross(graph_t * g, int doBalance)&quot;)
public static void dot_mincross(Globals zz, ST_Agraph_s g, boolean doBalance) {
<span class="fc" id="L165">ENTERING(&quot;e876vp4hgkzshluz6qk77cjwk&quot;,&quot;dot_mincross&quot;);</span>
try {
    int c, nc;
    CString s;
    
<span class="fc" id="L170">    init_mincross(zz, g);</span>
    
<span class="fc bfc" id="L172" title="All 2 branches covered.">    for (nc = c = 0; c &lt; GD_comp(g).size; c++) {</span>
<span class="fc" id="L173">	init_mccomp(g, c);</span>
<span class="fc" id="L174">	nc += mincross_(zz, g, 0, 2, doBalance);</span>
    }
    
<span class="fc" id="L177">    merge2(zz, g);</span>
    
    /* run mincross on contents of each cluster */
<span class="fc bfc" id="L180" title="All 2 branches covered.">    for (c = 1; c &lt;= GD_n_cluster(g); c++) {</span>
<span class="fc" id="L181">	nc += mincross_clust(zz, g, GD_clust(g).get_(c), doBalance);</span>
    }
    
    
    
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if ((GD_n_cluster(g) &gt; 0)</span>
<span class="pc bpc" id="L187" title="3 of 4 branches missed.">	&amp;&amp; (((s = agget(zz, g, new CString(&quot;remincross&quot;))))==null || (mapbool(s)))) {</span>
<span class="fc" id="L188">	mark_lowclusters(zz, g);</span>
<span class="fc" id="L189">	zz.ReMincross = true;</span>
<span class="fc" id="L190">	nc = mincross_(zz, g, 2, 2, doBalance);</span>
    }
<span class="fc" id="L192">    cleanup2(zz, g, nc);</span>
} finally {
<span class="fc" id="L194">LEAVING(&quot;e876vp4hgkzshluz6qk77cjwk&quot;,&quot;dot_mincross&quot;);</span>
}
<span class="fc" id="L196">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;&quot;, key=&quot;756bre1tpxb1tq68p7xhkrxkc&quot;, definition=&quot;static adjmatrix_t *new_matrix(int i, int j)&quot;)
public static ST_adjmatrix_t new_matrix(int i, int j) {
<span class="fc" id="L204">ENTERING(&quot;756bre1tpxb1tq68p7xhkrxkc&quot;,&quot;new_matrix&quot;);</span>
try {
<span class="fc" id="L206">	ST_adjmatrix_t rv = new ST_adjmatrix_t();</span>
<span class="fc" id="L207">    rv.nrows = i;</span>
<span class="fc" id="L208">    rv.ncols = j;</span>
    // Arnaud 15/09/2022: the j+1 is needed in some case to avoid ArrayIndexOutOfBoundsException
    // Arnaud 02/03/2023: the j+3 is needed in some case to avoid ArrayIndexOutOfBoundsException
    // Arnaud 15/03/2023: the i+3 is needed in some case to avoid ArrayIndexOutOfBoundsException when LR direction
    // Arnaud 20/12/2024: Even bigger
<span class="fc" id="L213">    rv.data = new int[Math.max(i, j) + 8][Math.max(i, j) + 8];</span>
<span class="fc" id="L214">    return rv;</span>
} finally {
<span class="fc" id="L216">LEAVING(&quot;756bre1tpxb1tq68p7xhkrxkc&quot;,&quot;new_matrix&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;free_matrix&quot;, key=&quot;1n1e0k0wtlbugwm3cb4na6av6&quot;, definition=&quot;static void free_matrix(adjmatrix_t * p)&quot;)
public static void free_matrix(ST_adjmatrix_t p) {
<span class="fc" id="L226">ENTERING(&quot;1n1e0k0wtlbugwm3cb4na6av6&quot;,&quot;free_matrix&quot;);</span>
try {
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (p!=null) {</span>
<span class="fc" id="L229">	Memory.free(p.data);</span>
<span class="fc" id="L230">	Memory.free(p);</span>
    }
} finally {
<span class="fc" id="L233">LEAVING(&quot;1n1e0k0wtlbugwm3cb4na6av6&quot;,&quot;free_matrix&quot;);</span>
}
<span class="fc" id="L235">}</span>




@Difficult
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;init_mccomp&quot;, key=&quot;49vw7fkn99wbojtfksugvuruh&quot;, definition=&quot;static void init_mccomp(graph_t * g, int c)&quot;)
public static void init_mccomp(ST_Agraph_s g, int c) {
<span class="fc" id="L244">ENTERING(&quot;49vw7fkn99wbojtfksugvuruh&quot;,&quot;init_mccomp&quot;);</span>
try {
    int r;
    
<span class="fc" id="L248">    GD_nlist(g, GD_comp(g).list.get_(c));</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (c &gt; 0) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">	for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L251">	    GD_rank(g).get__(r).v = GD_rank(g).get__(r).v.plus_(GD_rank(g).get__(r).n);</span>
<span class="fc" id="L252">	    GD_rank(g).get__(r).n = 0;</span>
	}
    }
} finally {
<span class="fc" id="L256">LEAVING(&quot;49vw7fkn99wbojtfksugvuruh&quot;,&quot;init_mccomp&quot;);</span>
}
<span class="fc" id="L258">}</span>




/* ordered_edges:
 * handle case where graph specifies edge ordering
 * If the graph does not have an ordering attribute, we then
 * check for nodes having the attribute.
 * Note that, in this implementation, the value of G_ordering
 * dominates the value of N_ordering.
 */
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;ordered_edges&quot;, key=&quot;hzoz2czb672i0nbjvjhbc3na&quot;, definition=&quot;static void ordered_edges(graph_t * g)&quot;)
public static void ordered_edges(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L273">ENTERING(&quot;hzoz2czb672i0nbjvjhbc3na&quot;,&quot;ordered_edges&quot;);</span>
try {
    CString ordering;
<span class="pc bpc" id="L276" title="2 of 4 branches missed.">    if ((zz.G_ordering) == null &amp;&amp; (zz.N_ordering) == null)</span>
<span class="fc" id="L277">	return;</span>
<span class="nc" id="L278">UNSUPPORTED(&quot;98iqppixxkdndoz210i5ejppy&quot;); //     if ((ordering = late_string(g, G_ordering, NULL))) {</span>
<span class="nc" id="L279">UNSUPPORTED(&quot;lhhw62wj3on36enoy6ug6u1p&quot;); // 	if ((*(ordering)==*(&quot;out&quot;)&amp;&amp;!strcmp(ordering,&quot;out&quot;)))</span>
<span class="nc" id="L280">UNSUPPORTED(&quot;ctbadiyd3jjtlt2f5t9p94au7&quot;); // 	    do_ordering(g, NOT(0));</span>
<span class="nc" id="L281">UNSUPPORTED(&quot;259y9uhqwc8w6jhrpm1eaa7hf&quot;); // 	else if ((*(ordering)==*(&quot;in&quot;)&amp;&amp;!strcmp(ordering,&quot;in&quot;)))</span>
<span class="nc" id="L282">UNSUPPORTED(&quot;312ij4z5d42rye9s30l9io097&quot;); // 	    do_ordering(g, 0);</span>
<span class="nc" id="L283">UNSUPPORTED(&quot;25yw5chxmy54pmo88tre1w2ir&quot;); // 	else if (ordering[0])</span>
<span class="nc" id="L284">UNSUPPORTED(&quot;5ugg9zy8378pijqru97mxmen5&quot;); // 	    agerr(AGERR, &quot;ordering '%s' not recognized.\n&quot;, ordering);</span>
<span class="nc" id="L285">UNSUPPORTED(&quot;dvgyxsnyeqqnyzq696k3vskib&quot;); //     }</span>
<span class="nc" id="L286">UNSUPPORTED(&quot;div10atae09n36x269sl208r1&quot;); //     else</span>
<span class="nc" id="L287">UNSUPPORTED(&quot;6ld19omy1z68vprfzbhrjqr2z&quot;); //     {</span>
<span class="nc" id="L288">UNSUPPORTED(&quot;50itbchatjp61haxvg3xnhvoo&quot;); // 	graph_t *subg;</span>
<span class="nc" id="L289">UNSUPPORTED(&quot;evzjoqkm2xukapjvpccu2f23e&quot;); // 	for (subg = agfstsubg(g); subg; subg = agnxtsubg(subg)) {</span>
<span class="nc" id="L290">UNSUPPORTED(&quot;1016hqxaexp4j33vmkzvdpq80&quot;); // 	    /* clusters are processed by separate calls to ordered_edges */</span>
<span class="nc" id="L291">UNSUPPORTED(&quot;7ah0zlu96u6g6cquxebenj4z3&quot;); // 	    if (!is_cluster(subg))</span>
<span class="nc" id="L292">UNSUPPORTED(&quot;7sqzaehh40dvpm11hlxhef6cw&quot;); // 		ordered_edges(subg);</span>
<span class="nc" id="L293">UNSUPPORTED(&quot;flupwh3kosf3fkhkxllllt1&quot;); // 	}</span>
<span class="nc" id="L294">UNSUPPORTED(&quot;h2b3ao18r091ie7yk9v20pqq&quot;); // 	if (N_ordering) do_ordering_for_nodes (g);</span>
<span class="nc" id="L295">UNSUPPORTED(&quot;dvgyxsnyeqqnyzq696k3vskib&quot;); //     }</span>
<span class="nc" id="L296">UNSUPPORTED(&quot;c24nfmv9i7o5eoqaymbibp7m7&quot;); // }</span>

<span class="nc" id="L298">throw new UnsupportedOperationException();</span>
} finally {
<span class="fc" id="L300">LEAVING(&quot;hzoz2czb672i0nbjvjhbc3na&quot;,&quot;ordered_edges&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;mincross_clust&quot;, key=&quot;crwc5qe7fmrpgcqh1a80toyvo&quot;, definition=&quot;static int mincross_clust(graph_t * par, graph_t * g, int doBalance)&quot;)
public static int mincross_clust(Globals zz, ST_Agraph_s par, ST_Agraph_s g, boolean doBalance) {
<span class="fc" id="L310">ENTERING(&quot;crwc5qe7fmrpgcqh1a80toyvo&quot;,&quot;mincross_clust&quot;);</span>
try {
    int c, nc;
    
<span class="fc" id="L314">    expand_cluster(zz, g);</span>
<span class="fc" id="L315">    ordered_edges(zz, g);</span>
<span class="fc" id="L316">    flat_breakcycles(zz, g);</span>
<span class="fc" id="L317">    flat_reorder(zz, g);</span>
<span class="fc" id="L318">    nc = mincross_(zz, g, 2, 2, doBalance);</span>
    
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    for (c = 1; c &lt;= GD_n_cluster(g); c++)</span>
<span class="nc" id="L321">	nc += mincross_clust(zz, g, GD_clust(g).get_(c), doBalance);</span>
    
<span class="fc" id="L323">    save_vlist(g);</span>
<span class="fc" id="L324">    return nc;</span>
} finally {
<span class="fc" id="L326">LEAVING(&quot;crwc5qe7fmrpgcqh1a80toyvo&quot;,&quot;mincross_clust&quot;);</span>
}
}




//3 657v773m21j5w3g3v94o7464t
// static int left2right(graph_t * g, node_t * v, node_t * w) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;left2right&quot;, key=&quot;657v773m21j5w3g3v94o7464t&quot;, definition=&quot;static int left2right(graph_t * g, node_t * v, node_t * w)&quot;)
public static boolean left2right(Globals zz, ST_Agraph_s g, ST_Agnode_s v, ST_Agnode_s w) {
<span class="fc" id="L338">ENTERING(&quot;657v773m21j5w3g3v94o7464t&quot;,&quot;left2right&quot;);</span>
try {
	ST_adjmatrix_t M;
<span class="fc" id="L341">    boolean rv=false;</span>
    /* CLUSTER indicates orig nodes of clusters, and vnodes of skeletons */
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">    if (zz.ReMincross == false) {</span>
<span class="pc bpc" id="L344" title="5 of 6 branches missed.">	if ((ND_clust(v) != ND_clust(w)) &amp;&amp; (ND_clust(v)!=null) &amp;&amp; (ND_clust(w)!=null)) {</span>
	    /* the following allows cluster skeletons to be swapped */
<span class="nc bnc" id="L346" title="All 2 branches missed.">	    if ((ND_ranktype(v) == 7)</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">		&amp;&amp; (ND_node_type(v) == 1))</span>
<span class="nc" id="L348">		return false;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">	    if ((ND_ranktype(w) == 7)</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		&amp;&amp; (ND_node_type(w) == 1))</span>
<span class="nc" id="L351">		return false;</span>
<span class="nc" id="L352">	    return true;</span>
	    /*return ((ND_ranktype(v) != CLUSTER) &amp;&amp; (ND_ranktype(w) != CLUSTER)); */
	}
    } else {
<span class="nc bnc" id="L356" title="All 2 branches missed."> 	if ((ND_clust(v) != ND_clust(w)))</span>
<span class="nc" id="L357">		return true;</span>
    }
<span class="fc" id="L359">    M = GD_rank(g).get__(ND_rank(v)).flat;</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">    if (M == null)</span>
<span class="fc" id="L361">	rv = false;</span>
    else {
<span class="nc bnc" id="L363" title="All 2 branches missed.">	if (GD_flip(g)) {</span>
<span class="nc" id="L364">	    ST_Agnode_s t = v;</span>
<span class="nc" id="L365">	    v = w;</span>
<span class="nc" id="L366">	    w = t;</span>
	}
<span class="nc bnc" id="L368" title="All 2 branches missed.">	rv = M.data[ND_low(v)][ND_low(w)]!=0;</span>
    }
<span class="fc" id="L370">    return rv;</span>
} finally {
<span class="fc" id="L372">LEAVING(&quot;657v773m21j5w3g3v94o7464t&quot;,&quot;left2right&quot;);</span>
}
}




//3 daknncpjy7g5peiicolbmh55i
// static int in_cross(node_t * v, node_t * w) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;in_cross&quot;, key=&quot;daknncpjy7g5peiicolbmh55i&quot;, definition=&quot;static int in_cross(node_t * v, node_t * w)&quot;)
public static int in_cross(ST_Agnode_s v, ST_Agnode_s w) {
<span class="fc" id="L384">ENTERING(&quot;daknncpjy7g5peiicolbmh55i&quot;,&quot;in_cross&quot;);</span>
try {
<span class="fc" id="L386">    CArrayOfStar&lt;ST_Agedge_s&gt; e2_ = ND_in(w).list;</span>
<span class="fc" id="L387">    int inv, cross = 0, t;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">    for (int ie2 = 0; e2_.get_(ie2)!=null; ie2++) {</span>
<span class="fc" id="L389">	int cnt = ED_xpenalty(e2_.get_(ie2));		</span>
<span class="fc" id="L390">	inv = ND_order((agtail(e2_.get_(ie2))));</span>
<span class="fc" id="L391">    CArrayOfStar&lt;ST_Agedge_s&gt; e1_ = ND_in(v).list;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">	for (int ie1 = 0; e1_.get_(ie1)!=null; ie1++) {</span>
<span class="fc" id="L393">	    t = ND_order(agtail(e1_.get_(ie1))) - inv;</span>
<span class="fc bfc" id="L394" title="All 4 branches covered.">	    if ((t &gt; 0)</span>
		|| ((t == 0)
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">		    &amp;&amp; (  ED_tail_port(e1_.get_(ie1)).p.x &gt; ED_tail_port(e2_.get_(ie2)).p.x)))</span>
<span class="fc" id="L397">		cross += ED_xpenalty(e1_.get_(ie1)) * cnt;</span>
	}
    }
<span class="fc" id="L400">    return cross;</span>
} finally {
<span class="fc" id="L402">LEAVING(&quot;daknncpjy7g5peiicolbmh55i&quot;,&quot;in_cross&quot;);</span>
}
}




//3 b7mf74np8ewrgzwd5u0o8fqod
// static int out_cross(node_t * v, node_t * w) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;out_cross&quot;, key=&quot;b7mf74np8ewrgzwd5u0o8fqod&quot;, definition=&quot;static int out_cross(node_t * v, node_t * w)&quot;)
public static int out_cross(ST_Agnode_s v, ST_Agnode_s w) {
<span class="fc" id="L414">ENTERING(&quot;b7mf74np8ewrgzwd5u0o8fqod&quot;,&quot;out_cross&quot;);</span>
try {
<span class="fc" id="L416"> 	CArrayOfStar&lt;ST_Agedge_s&gt; e2_ = ND_out(w).list;</span>
<span class="fc" id="L417">    int inv, cross = 0, t;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">    for (int ie2 = 0; e2_.get_(ie2)!=null; ie2++) {</span>
<span class="fc" id="L419">	int cnt = ED_xpenalty(e2_.get_(ie2));</span>
<span class="fc" id="L420">	inv = ND_order(aghead(e2_.get_(ie2)));</span>
<span class="fc" id="L421">    CArrayOfStar&lt;ST_Agedge_s&gt; e1_ = ND_out(v).list;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">	for (int ie1 = 0; e1_.get_(ie1)!=null; ie1++) {</span>
<span class="fc" id="L423">	    t = ND_order(aghead(e1_.get_(ie1))) - inv;</span>
<span class="fc bfc" id="L424" title="All 4 branches covered.">	    if ((t &gt; 0)</span>
		|| ((t == 0)
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">		    &amp;&amp; ((ED_head_port(e1_.get_(ie1))).p.x) &gt; (ED_head_port(e2_.get_(ie2))).p.x))</span>
<span class="fc" id="L427">		cross += ((ED_xpenalty(e1_.get_(ie1))) * cnt);</span>
	}
    }
<span class="fc" id="L430">    return cross;</span>
} finally {
<span class="fc" id="L432">LEAVING(&quot;b7mf74np8ewrgzwd5u0o8fqod&quot;,&quot;out_cross&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Difficult
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;exchange&quot;, key=&quot;ba4tbr57wips1dzpgxzx3b6ja&quot;, definition=&quot;static void exchange(node_t * v, node_t * w)&quot;)
public static void exchange(Globals zz, ST_Agnode_s v, ST_Agnode_s w) {
<span class="fc" id="L444">ENTERING(&quot;ba4tbr57wips1dzpgxzx3b6ja&quot;,&quot;exchange&quot;);</span>
try {
    int vi, wi, r;
    
<span class="fc" id="L448">    r = ND_rank(v);</span>
<span class="fc" id="L449">    vi = ND_order(v);</span>
<span class="fc" id="L450">    wi = ND_order(w);</span>
<span class="fc" id="L451">    ND_order(v, wi);</span>
<span class="fc" id="L452">    GD_rank(zz.Root).get__(r).v.set_(wi, v);</span>
<span class="fc" id="L453">    ND_order(w, vi);</span>
<span class="fc" id="L454">    GD_rank(zz.Root).get__(r).v.set_(vi, w);</span>
} finally {
<span class="fc" id="L456">LEAVING(&quot;ba4tbr57wips1dzpgxzx3b6ja&quot;,&quot;exchange&quot;);</span>
}
<span class="fc" id="L458">}</span>





//3 72rj5xs4qh00oh2yi1h5qaadu
// static int balance(graph_t * g) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;balance&quot;, key=&quot;72rj5xs4qh00oh2yi1h5qaadu&quot;, definition=&quot;static int balance(graph_t * g)&quot;)
public static Object balance(Object... arg_) {
<span class="nc" id="L469">UNSUPPORTED(&quot;4223t6rekw3qd8eksvz9kjcqh&quot;); // static int balance(graph_t * g)</span>
<span class="nc" id="L470">UNSUPPORTED(&quot;erg9i1970wdri39osu8hx2a6e&quot;); // {</span>
<span class="nc" id="L471">UNSUPPORTED(&quot;970giwpms1ljmt0px5djlqs0z&quot;); //     int i, c0, c1, rv;</span>
<span class="nc" id="L472">UNSUPPORTED(&quot;8xqnhjfdqnlwlyld1ep6hpnmb&quot;); //     node_t *v, *w;</span>
<span class="nc" id="L473">UNSUPPORTED(&quot;p6jnh7nvcpnl3zbz636pskbs&quot;); //     int r;</span>
<span class="nc" id="L474">UNSUPPORTED(&quot;yy0fwjrmxw3jbi85mvwrka7f&quot;); //     rv = 0;</span>
<span class="nc" id="L475">UNSUPPORTED(&quot;9ey19t6tw2srzaedeng4sq96z&quot;); //     for (r = GD_maxrank(g); r &gt;= GD_minrank(g); r--) {</span>
<span class="nc" id="L476">UNSUPPORTED(&quot;2nlemgjbnd1ygry42bcbuwo9y&quot;); // 	GD_rank(g)[r].candidate = 0;</span>
<span class="nc" id="L477">UNSUPPORTED(&quot;91gzxbmcoy5xbvf8nlhmlj4eh&quot;); // 	for (i = 0; i &lt; GD_rank(g)[r].n - 1; i++) {</span>
<span class="nc" id="L478">UNSUPPORTED(&quot;5ekdr3i8niy7x2ohi7ftgmjke&quot;); // 	    v = GD_rank(g)[r].v[i];</span>
<span class="nc" id="L479">UNSUPPORTED(&quot;efwyjm6j3e7byt6z83lrhgd1r&quot;); // 	    w = GD_rank(g)[r].v[i + 1];</span>
<span class="nc" id="L480">UNSUPPORTED(&quot;8ey6umhtefcrb61ncgis82hw6&quot;); // 	    assert(ND_order(v) &lt; ND_order(w));</span>
<span class="nc" id="L481">UNSUPPORTED(&quot;ddkyq74d5rjfcofczt4hmkxsj&quot;); // 	    if (left2right(g, v, w))</span>
<span class="nc" id="L482">UNSUPPORTED(&quot;6hyelvzskqfqa07xtgjtvg2is&quot;); // 		continue;</span>
<span class="nc" id="L483">UNSUPPORTED(&quot;cdpfb5fmlhe0831jf96pjp9s0&quot;); // 	    c0 = c1 = 0;</span>
<span class="nc" id="L484">UNSUPPORTED(&quot;3l676z6ajeugxvie4r957jap3&quot;); // 	    if (r &gt; 0) {</span>
<span class="nc" id="L485">UNSUPPORTED(&quot;ennnd5cl9xhh55j2bni58iuxv&quot;); // 		c0 += in_cross(v, w);</span>
<span class="nc" id="L486">UNSUPPORTED(&quot;bk4dl2r7nw7j8xvkpg7g7x0z9&quot;); // 		c1 += in_cross(w, v);</span>
<span class="nc" id="L487">UNSUPPORTED(&quot;6t98dcecgbvbvtpycwiq2ynnj&quot;); // 	    }</span>
<span class="nc" id="L488">UNSUPPORTED(&quot;f0ordylgf44hx2l90eof067yo&quot;); // 	    if (GD_rank(g)[r + 1].n &gt; 0) {</span>
<span class="nc" id="L489">UNSUPPORTED(&quot;d945airzpo5xbu0fz68ylmgql&quot;); // 		c0 += out_cross(v, w);</span>
<span class="nc" id="L490">UNSUPPORTED(&quot;e6ez0uwca50uwo7i7i4vak4f2&quot;); // 		c1 += out_cross(w, v);</span>
<span class="nc" id="L491">UNSUPPORTED(&quot;6t98dcecgbvbvtpycwiq2ynnj&quot;); // 	    }</span>
<span class="nc" id="L492">UNSUPPORTED(&quot;884yfwkgyw57w5ivpfrggmq15&quot;); // 	    if (c1 &lt;= c0) {</span>
<span class="nc" id="L493">UNSUPPORTED(&quot;c2sevxb1gtyc2olq8akmvs40u&quot;); // 		balanceNodes(g, r, v, w);</span>
<span class="nc" id="L494">UNSUPPORTED(&quot;6t98dcecgbvbvtpycwiq2ynnj&quot;); // 	    }</span>
<span class="nc" id="L495">UNSUPPORTED(&quot;flupwh3kosf3fkhkxllllt1&quot;); // 	}</span>
<span class="nc" id="L496">UNSUPPORTED(&quot;dvgyxsnyeqqnyzq696k3vskib&quot;); //     }</span>
<span class="nc" id="L497">UNSUPPORTED(&quot;v7vqc9l7ge2bfdwnw11z7rzi&quot;); //     return rv;</span>
<span class="nc" id="L498">UNSUPPORTED(&quot;c24nfmv9i7o5eoqaymbibp7m7&quot;); // }</span>

<span class="nc" id="L500">throw new UnsupportedOperationException();</span>
}




//3 bxwzx4m9ejausu58u7abr6fm0
// static int transpose_step(graph_t * g, int r, int reverse) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;transpose_step&quot;, key=&quot;bxwzx4m9ejausu58u7abr6fm0&quot;, definition=&quot;static int transpose_step(graph_t * g, int r, int reverse)&quot;)
public static int transpose_step(Globals zz, ST_Agraph_s g, int r, boolean reverse) {
<span class="fc" id="L511">ENTERING(&quot;bxwzx4m9ejausu58u7abr6fm0&quot;,&quot;transpose_step&quot;);</span>
try {
    int i, c0, c1, rv;
    ST_Agnode_s v, w;
<span class="fc" id="L515">    rv = 0;</span>
<span class="fc" id="L516">    GD_rank(g).get__(r).candidate= false;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">    for (i = 0; i &lt; GD_rank(g).get__(r).n - 1; i++) {</span>
<span class="fc" id="L518">	v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc" id="L519">	w = GD_rank(g).get__(r).v.get_(i + 1);</span>
	//assert(ND_order(v) &lt; ND_order(w));
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">	if (left2right(zz, g, v, w))</span>
<span class="nc" id="L522">	    continue;</span>
<span class="fc" id="L523">	c0 = c1 = 0;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">	if (r &gt; 0) {</span>
<span class="fc" id="L525">	    c0 += in_cross(v, w);</span>
<span class="fc" id="L526">	    c1 += in_cross(w, v);</span>
	}
<span class="fc bfc" id="L528" title="All 2 branches covered.">	if (GD_rank(g).get__(r + 1).n &gt; 0) {</span>
<span class="fc" id="L529">	    c0 += out_cross(v, w);</span>
<span class="fc" id="L530">	    c1 += out_cross(w, v);</span>
	}
<span class="fc bfc" id="L532" title="All 8 branches covered.">	if ((c1 &lt; c0) || ((c0 &gt; 0) &amp;&amp; reverse &amp;&amp; (c1 == c0))) {</span>
<span class="fc" id="L533">	    exchange(zz, v, w);</span>
<span class="fc" id="L534">	    rv += (c0 - c1);</span>
<span class="fc" id="L535">	    GD_rank(zz.Root).get__(r).valid= 0;</span>
<span class="fc" id="L536">	    GD_rank(g).get__(r).candidate= true;</span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">	    if (r &gt; GD_minrank(g)) {</span>
<span class="fc" id="L538">		GD_rank(zz.Root).get__(r - 1).valid= 0;</span>
<span class="fc" id="L539">		GD_rank(g).get__(r - 1).candidate= true;</span>
	    }
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">	    if (r &lt; GD_maxrank(g)) {</span>
<span class="fc" id="L542">		GD_rank(zz.Root).get__(r + 1).valid= 0;</span>
<span class="fc" id="L543">		GD_rank(g).get__(r + 1).candidate= true;</span>
	    }
	}
    }
<span class="fc" id="L547">    return rv;</span>
} finally {
<span class="fc" id="L549">LEAVING(&quot;bxwzx4m9ejausu58u7abr6fm0&quot;,&quot;transpose_step&quot;);</span>
}
}




//3 2i22bxgg5y7v5c5d40k5zppky
// static void transpose(graph_t * g, int reverse) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;transpose&quot;, key=&quot;2i22bxgg5y7v5c5d40k5zppky&quot;, definition=&quot;static void transpose(graph_t * g, int reverse)&quot;)
public static void transpose(Globals zz, ST_Agraph_s g, boolean reverse) {
<span class="fc" id="L561">ENTERING(&quot;2i22bxgg5y7v5c5d40k5zppky&quot;,&quot;transpose&quot;);</span>
try {
    int r, delta;
<span class="fc bfc" id="L564" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++)</span>
<span class="fc" id="L565">	GD_rank(g).get__(r).candidate= true;</span>
    do {
<span class="fc" id="L567">	delta = 0;</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">	for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">	    if (GD_rank(g).get__(r).candidate) {</span>
<span class="fc" id="L570">		delta += transpose_step(zz, g, r, reverse);</span>
	    }
	}
	/*} while (delta &gt; ncross(g)*(1.0 - Convergence)); */
<span class="fc bfc" id="L574" title="All 2 branches covered.">    } while (delta &gt;= 1);</span>
} finally {
<span class="fc" id="L576">LEAVING(&quot;2i22bxgg5y7v5c5d40k5zppky&quot;,&quot;transpose&quot;);</span>
}
<span class="fc" id="L578">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;mincross&quot;, key=&quot;7lrk2rxqnwwdau8cx85oqkpmv&quot;, definition=&quot;static int mincross(graph_t * g, int startpass, int endpass, int doBalance)&quot;)
public static int mincross_(Globals zz, ST_Agraph_s g, int startpass, int endpass, boolean doBalance) {
<span class="fc" id="L586">ENTERING(&quot;7lrk2rxqnwwdau8cx85oqkpmv&quot;,&quot;mincross_&quot;);</span>
try {
<span class="fc" id="L588">    int maxthispass=0, iter, trying, pass;</span>
    int cur_cross, best_cross;
    
<span class="fc bfc" id="L591" title="All 2 branches covered.">    if (startpass &gt; 1) {</span>
<span class="fc" id="L592">	cur_cross = best_cross = ncross(zz, g);</span>
<span class="fc" id="L593">	save_best(g);</span>
    } else
<span class="fc" id="L595">	cur_cross = best_cross = INT_MAX;</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">    for (pass = startpass; pass &lt;= endpass; pass++) {</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">	if (pass &lt;= 1) {</span>
<span class="fc" id="L598">	    maxthispass = Math.min(4, zz.MaxIter);</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">	    if (g == dot_root(g))</span>
<span class="fc" id="L600">		build_ranks(zz, g, pass);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">	    if (pass == 0)</span>
<span class="fc" id="L602">		flat_breakcycles(zz, g);</span>
<span class="fc" id="L603">	    flat_reorder(zz, g);</span>
	    
<span class="fc bfc" id="L605" title="All 2 branches covered.">	    if ((cur_cross = ncross(zz, g)) &lt;= best_cross) {</span>
<span class="fc" id="L606">		save_best(g);</span>
<span class="fc" id="L607">		best_cross = cur_cross;</span>
	    }
<span class="fc" id="L609">	    trying = 0;</span>
	} else {
<span class="fc" id="L611">	    maxthispass = zz.MaxIter;</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">	    if (cur_cross &gt; best_cross)</span>
<span class="nc" id="L613">		restore_best(zz, g);</span>
<span class="fc" id="L614">	    cur_cross = best_cross;</span>
	}
<span class="fc" id="L616">	trying = 0;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">	for (iter = 0; iter &lt; maxthispass; iter++) {</span>
	    /*if (Verbose)
		fprintf(stderr,
			&quot;mincross: pass %d iter %d trying %d cur_cross %d best_cross %d\n&quot;,
			pass, iter, trying, cur_cross, best_cross);*/
<span class="fc bfc" id="L622" title="All 2 branches covered.">	    if (trying++ &gt;= zz.MinQuit)</span>
<span class="fc" id="L623">		break;</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">	    if (cur_cross == 0)</span>
<span class="fc" id="L625">		break;</span>
<span class="fc" id="L626">	    mincross_step(zz, g, iter);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">	    if ((cur_cross = ncross(zz, g)) &lt;= best_cross) {</span>
<span class="fc" id="L628">		save_best(g);</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">		if (cur_cross &lt; zz.Convergence * best_cross)</span>
<span class="fc" id="L630">		    trying = 0;</span>
<span class="fc" id="L631">		best_cross = cur_cross;</span>
	    }
	}
<span class="fc bfc" id="L634" title="All 2 branches covered.">	if (cur_cross == 0)</span>
<span class="fc" id="L635">	    break;</span>
    }
<span class="fc bfc" id="L637" title="All 2 branches covered.">    if (cur_cross &gt; best_cross)</span>
<span class="fc" id="L638">	restore_best(zz, g);</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">    if (best_cross &gt; 0) {</span>
<span class="fc" id="L640">	transpose(zz, g, false);</span>
<span class="fc" id="L641">	best_cross = ncross(zz, g);</span>
    }
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">    if (doBalance) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">	for (iter = 0; iter &lt; maxthispass; iter++)</span>
<span class="nc" id="L645">	    balance(g);</span>
    }
    
<span class="fc" id="L648">    return best_cross;</span>
} finally {
<span class="fc" id="L650">LEAVING(&quot;7lrk2rxqnwwdau8cx85oqkpmv&quot;,&quot;mincross_&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;restore_best&quot;, key=&quot;520049zkz9mafaeklgvm6s8e5&quot;, definition=&quot;static void restore_best(graph_t * g)&quot;)
public static void restore_best(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L660">ENTERING(&quot;520049zkz9mafaeklgvm6s8e5&quot;,&quot;restore_best&quot;);</span>
try {
    ST_Agnode_s n;
    int r;
    
<span class="fc bfc" id="L665" title="All 2 branches covered.">    for (n = GD_nlist(g); n!=null; n = ND_next(n))</span>
<span class="fc" id="L666">	ND_order(n, (int)ND_coord(n).x);</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L668">	GD_rank(zz.Root).get__(r).valid= 0;</span>
<span class="fc" id="L669">    qsort(zz, GD_rank(g).get__(r).v,</span>
<span class="fc" id="L670">    	    GD_rank(g).get__(r).n,</span>
    	    mincross__c.nodeposcmpf);
    }
} finally {
<span class="fc" id="L674">LEAVING(&quot;520049zkz9mafaeklgvm6s8e5&quot;,&quot;restore_best&quot;);</span>
}
<span class="fc" id="L676">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;save_best&quot;, key=&quot;8uyqc48j0oul206l3np85wj9p&quot;, definition=&quot;static void save_best(graph_t * g)&quot;)
public static void save_best(ST_Agraph_s g) {
<span class="fc" id="L684">ENTERING(&quot;8uyqc48j0oul206l3np85wj9p&quot;,&quot;save_best&quot;);</span>
try {
    ST_Agnode_s n;
<span class="fc bfc" id="L687" title="All 2 branches covered.">    for (n = GD_nlist(g); n!=null; n = ND_next(n))</span>
<span class="fc" id="L688">    (ND_coord(n)).x = ND_order(n);</span>
} finally {
<span class="fc" id="L690">LEAVING(&quot;8uyqc48j0oul206l3np85wj9p&quot;,&quot;save_best&quot;);</span>
}
<span class="fc" id="L692">}</span>




/* merges the connected components of g */
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;merge_components&quot;, key=&quot;6d08fwi4dsk6ikk5d0gy6rq2h&quot;, definition=&quot;static void merge_components(graph_t * g)&quot;)
public static void merge_components(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L701">ENTERING(&quot;6d08fwi4dsk6ikk5d0gy6rq2h&quot;,&quot;merge_components&quot;);</span>
try {
    int c;
    ST_Agnode_s u, v;
    
<span class="fc bfc" id="L706" title="All 2 branches covered.">    if (GD_comp(g).size &lt;= 1)</span>
<span class="fc" id="L707">	return;</span>
<span class="fc" id="L708">    u = null;</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">    for (c = 0; c &lt; GD_comp(g).size; c++) {</span>
<span class="fc" id="L710">    v = (ST_Agnode_s) GD_comp(g).list.get_(c);</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">	if (u!=null)</span>
<span class="fc" id="L712">	    ND_next(u, v);</span>
<span class="fc" id="L713">	ND_prev(v, u);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">	while (ND_next(v)!=null) {</span>
<span class="fc" id="L715">	    v = ND_next(v);</span>
	}
<span class="fc" id="L717">	u = v;</span>
    }
<span class="fc" id="L719">    GD_comp(g).size = 1;</span>
<span class="fc" id="L720">    GD_nlist(g, GD_comp(g).list.get_(0));</span>
<span class="fc" id="L721">    GD_minrank(g, zz.GlobalMinRank);</span>
<span class="fc" id="L722">    GD_maxrank(g, zz.GlobalMaxRank);</span>
} finally {
<span class="fc" id="L724">LEAVING(&quot;6d08fwi4dsk6ikk5d0gy6rq2h&quot;,&quot;merge_components&quot;);</span>
}
<span class="fc" id="L726">}</span>




/* merge connected components, create globally consistent rank lists */
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;merge2&quot;, key=&quot;91vebcdl3q3y0uyxef0iw71n9&quot;, definition=&quot;static void merge2(graph_t * g)&quot;)
public static void merge2(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L735">ENTERING(&quot;91vebcdl3q3y0uyxef0iw71n9&quot;,&quot;merge2&quot;);</span>
try {
    int i, r;
    ST_Agnode_s v;
    
    /* merge the components and rank limits */
<span class="fc" id="L741">    merge_components(zz, g);</span>
    
    /* install complete ranks */
<span class="fc bfc" id="L744" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L745">	GD_rank(g).get__(r).n = GD_rank(g).get__(r).an;</span>
<span class="fc" id="L746">	GD_rank(g).get__(r).v = GD_rank(g).get__(r).av;</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">	for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L748">	    v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">	    if (v == null) {</span>
		/*if (Verbose)
		    fprintf(stderr,
			    &quot;merge2: graph %s, rank %d has only %d &lt; %d nodes\n&quot;,
			    agnameof(g), r, i, GD_rank(g)[r].n);*/
<span class="fc" id="L754">		GD_rank(g).get__(r).n = i;</span>
<span class="fc" id="L755">		break;</span>
	    }
<span class="fc" id="L757">	    ND_order(v, i);</span>
	}
    }
} finally {
<span class="fc" id="L761">LEAVING(&quot;91vebcdl3q3y0uyxef0iw71n9&quot;,&quot;merge2&quot;);</span>
}
<span class="fc" id="L763">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;cleanup2&quot;, key=&quot;3cwiyyk1d1jkoo9iqwb5bge4x&quot;, definition=&quot;static void cleanup2(graph_t * g, int nc)&quot;)
public static void cleanup2(Globals zz, ST_Agraph_s g, int nc) {
<span class="fc" id="L771">ENTERING(&quot;3cwiyyk1d1jkoo9iqwb5bge4x&quot;,&quot;cleanup2&quot;);</span>
try {
    int i, j, r, c;
    ST_Agnode_s v;
    ST_Agedge_s e;
    
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">    if (zz.TI_list!=null) {</span>
<span class="fc" id="L778">	Memory.free(zz.TI_list);</span>
<span class="fc" id="L779">	zz.TI_list = null;</span>
    }
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">    if (zz.TE_list!=null) {</span>
<span class="fc" id="L782">	Memory.free(zz.TE_list);</span>
<span class="fc" id="L783">	zz.TE_list = null;</span>
    }
    /* fix vlists of clusters */
<span class="fc bfc" id="L786" title="All 2 branches covered.">    for (c = 1; c &lt;= GD_n_cluster(g); c++)</span>
<span class="fc" id="L787">	rec_reset_vlists(zz, GD_clust(g).get_(c));</span>
    
    /* remove node temporary edges for ordering nodes */
<span class="fc bfc" id="L790" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">	for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L792">	    v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc" id="L793">	    ND_order(v, i);</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">	    if (ND_flat_out(v).list!=null) {</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">		for (j = 0; (e = (ST_Agedge_s) ND_flat_out(v).list.get_(j))!=null; j++)</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">		    if (ED_edge_type(e) == FLATORDER) {</span>
<span class="nc" id="L797">			delete_flat_edge(e);</span>
<span class="nc" id="L798">			Memory.free(e.base.data);</span>
<span class="nc" id="L799">			Memory.free(e);</span>
<span class="nc" id="L800">			j--;</span>
		    }
	    }
	}
<span class="fc" id="L804">	free_matrix(GD_rank(g).get__(r).flat);</span>
    }
    /*if (Verbose)
	fprintf(stderr, &quot;mincross %s: %d crossings, %.2f secs.\n&quot;,
		agnameof(g), nc, elapsed_sec());*/
} finally {
<span class="fc" id="L810">LEAVING(&quot;3cwiyyk1d1jkoo9iqwb5bge4x&quot;,&quot;cleanup2&quot;);</span>
}
<span class="fc" id="L812">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;&quot;, key=&quot;arax68kzcf86dr2xu0gp962gq&quot;, definition=&quot;static node_t *neighbor(node_t * v, int dir)&quot;)
public static ST_Agnode_s neighbor(Globals zz, ST_Agnode_s v, int dir) {
<span class="fc" id="L820">ENTERING(&quot;arax68kzcf86dr2xu0gp962gq&quot;,&quot;neighbor&quot;);</span>
try {
    ST_Agnode_s rv;
    
<span class="fc" id="L824">    rv = null;</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">assert(v!=null);</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">    if (dir &lt; 0) {</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">	if (ND_order(v) &gt; 0)</span>
<span class="fc" id="L828">	    rv = GD_rank(zz.Root).get__(ND_rank(v)).v.get_(ND_order(v) - 1);</span>
    } else
<span class="fc" id="L830">	rv = GD_rank(zz.Root).get__(ND_rank(v)).v.get_(ND_order(v) + 1);</span>
<span class="pc bpc" id="L831" title="1 of 4 branches missed.">assert((rv == null) || (ND_order(rv)-ND_order(v))*dir &gt; 0);</span>
<span class="fc" id="L832">    return rv;</span>
} finally {
<span class="fc" id="L834">LEAVING(&quot;arax68kzcf86dr2xu0gp962gq&quot;,&quot;neighbor&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;is_a_normal_node_of&quot;, key=&quot;1waqm8z71hi389dt1wqh0bmhr&quot;, definition=&quot;static int is_a_normal_node_of(graph_t * g, node_t * v)&quot;)
public static boolean is_a_normal_node_of(Globals zz, ST_Agraph_s g, ST_Agnode_s v) {
<span class="fc" id="L844">ENTERING(&quot;1waqm8z71hi389dt1wqh0bmhr&quot;,&quot;is_a_normal_node_of&quot;);</span>
try {
<span class="pc bpc" id="L846" title="1 of 4 branches missed.">    return ((ND_node_type(v) == NORMAL) &amp;&amp; agcontains(zz, g, v));</span>
} finally {
<span class="fc" id="L848">LEAVING(&quot;1waqm8z71hi389dt1wqh0bmhr&quot;,&quot;is_a_normal_node_of&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;is_a_vnode_of_an_edge_of&quot;, key=&quot;9f8atyi1unmleplge3rijdt4s&quot;, definition=&quot;static int is_a_vnode_of_an_edge_of(graph_t * g, node_t * v)&quot;)
public static boolean is_a_vnode_of_an_edge_of(Globals zz, ST_Agraph_s g, ST_Agnode_s v) {
<span class="fc" id="L858">ENTERING(&quot;9f8atyi1unmleplge3rijdt4s&quot;,&quot;is_a_vnode_of_an_edge_of&quot;);</span>
try {
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">    if ((ND_node_type(v) == VIRTUAL)</span>
<span class="nc bnc" id="L861" title="All 4 branches missed.">	&amp;&amp; (ND_in(v).size == 1) &amp;&amp; (ND_out(v).size == 1)) {</span>
<span class="nc" id="L862">	ST_Agedge_s e = (ST_Agedge_s) ND_out(v).list.get_(0);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">	while (ED_edge_type(e) != NORMAL)</span>
<span class="nc" id="L864">	    e = ED_to_orig(e);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">	if (agcontains(zz, g, e))</span>
<span class="nc" id="L866">	    return true;</span>
    }
<span class="fc" id="L868">    return false;</span>
} finally {
<span class="fc" id="L870">LEAVING(&quot;9f8atyi1unmleplge3rijdt4s&quot;,&quot;is_a_vnode_of_an_edge_of&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;inside_cluster&quot;, key=&quot;eo7ulc8vwmoaig0j479yapve2&quot;, definition=&quot;static int inside_cluster(graph_t * g, node_t * v)&quot;)
public static boolean inside_cluster(Globals zz, ST_Agraph_s g, ST_Agnode_s v) {
<span class="fc" id="L880">ENTERING(&quot;eo7ulc8vwmoaig0j479yapve2&quot;,&quot;inside_cluster&quot;);</span>
try {
<span class="fc" id="L882">    return (is_a_normal_node_of(zz, g, v) | is_a_vnode_of_an_edge_of(zz, g, v));</span>
} finally {
<span class="fc" id="L884">LEAVING(&quot;eo7ulc8vwmoaig0j479yapve2&quot;,&quot;inside_cluster&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;&quot;, key=&quot;8xkmkt4r6gfqj8gk0mokszoz0&quot;, definition=&quot;static node_t *furthestnode(graph_t * g, node_t * v, int dir)&quot;)
public static ST_Agnode_s furthestnode(Globals zz, ST_Agraph_s g, ST_Agnode_s v, int dir) {
<span class="fc" id="L894">ENTERING(&quot;8xkmkt4r6gfqj8gk0mokszoz0&quot;,&quot;furthestnode&quot;);</span>
try {
    ST_Agnode_s u, rv;
    
<span class="fc" id="L898">    rv = u = v;</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">    while ((u = neighbor(zz, u, dir))!=null) {</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">	if (is_a_normal_node_of(zz, g, u))</span>
<span class="fc" id="L901">	    rv = u;</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">	else if (is_a_vnode_of_an_edge_of(zz, g, u))</span>
<span class="nc" id="L903">	    rv = u;</span>
    }
<span class="fc" id="L905">    return rv;</span>
} finally {
<span class="fc" id="L907">LEAVING(&quot;8xkmkt4r6gfqj8gk0mokszoz0&quot;,&quot;furthestnode&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;save_vlist&quot;, key=&quot;bwmu2hkwud40601oq5vgo2f1h&quot;, definition=&quot;void save_vlist(graph_t * g)&quot;)
public static void save_vlist(ST_Agraph_s g) {
<span class="fc" id="L917">ENTERING(&quot;bwmu2hkwud40601oq5vgo2f1h&quot;,&quot;save_vlist&quot;);</span>
try {
    int r;
    
<span class="fc bfc" id="L921" title="All 2 branches covered.">    if (GD_rankleader(g)!=null)</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">	for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L923">	    GD_rankleader(g).set_(r, GD_rank(g).get__(r).v.get_(0));</span>
	}
} finally {
<span class="fc" id="L926">LEAVING(&quot;bwmu2hkwud40601oq5vgo2f1h&quot;,&quot;save_vlist&quot;);</span>
}
<span class="fc" id="L928">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;rec_save_vlists&quot;, key=&quot;hwdxg97sefkuyd25x2q4pgzg&quot;, definition=&quot;void rec_save_vlists(graph_t * g)&quot;)
public static void rec_save_vlists(ST_Agraph_s g) {
<span class="fc" id="L936">ENTERING(&quot;hwdxg97sefkuyd25x2q4pgzg&quot;,&quot;rec_save_vlists&quot;);</span>
try {
    int c;
    
<span class="fc" id="L940">    save_vlist(g);</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">    for (c = 1; c &lt;= GD_n_cluster(g); c++)</span>
<span class="fc" id="L942">	rec_save_vlists(GD_clust(g).get_(c));</span>
} finally {
<span class="fc" id="L944">LEAVING(&quot;hwdxg97sefkuyd25x2q4pgzg&quot;,&quot;rec_save_vlists&quot;);</span>
}
<span class="fc" id="L946">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;rec_reset_vlists&quot;, key=&quot;f3b4wat4uxn5oil720i5mwq4v&quot;, definition=&quot;void rec_reset_vlists(graph_t * g)&quot;)
public static void rec_reset_vlists(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L954">ENTERING(&quot;f3b4wat4uxn5oil720i5mwq4v&quot;,&quot;rec_reset_vlists&quot;);</span>
try {
    int r, c;
    ST_Agnode_s u, v, w;
    
    /* fix vlists of sub-clusters */
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">    for (c = 1; c &lt;= GD_n_cluster(g); c++)</span>
<span class="nc" id="L961">	rec_reset_vlists(zz, GD_clust(g).get_(c));</span>
    
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">    if (GD_rankleader(g)!=null)</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">	for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L965">	    v = GD_rankleader(g).get_(r);</span>
<span class="fc" id="L966">	    u = furthestnode(zz, g, v, -1);</span>
<span class="fc" id="L967">	    w = furthestnode(zz, g, v, 1);</span>
<span class="fc" id="L968">	    GD_rankleader(g).set_(r, u);</span>
<span class="fc" id="L969">	    GD_rank(g).get__(r).v = GD_rank(dot_root(g)).get__(r).v.plus_(ND_order(u));</span>
<span class="fc" id="L970">	    GD_rank(g).get__(r).n = ND_order(w) - ND_order(u) + 1;</span>
	}
} finally {
<span class="fc" id="L973">LEAVING(&quot;f3b4wat4uxn5oil720i5mwq4v&quot;,&quot;rec_reset_vlists&quot;);</span>
}
<span class="fc" id="L975">}</span>




//3 pv0rbbdopo4hmkbl5916qys1
// static Agraph_t* realFillRanks (Agraph_t* g, int rnks[], int rnks_sz, Agraph_t* sg) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;realFillRanks&quot;, key=&quot;pv0rbbdopo4hmkbl5916qys1&quot;, definition=&quot;static Agraph_t* realFillRanks (Agraph_t* g, int rnks[], int rnks_sz, Agraph_t* sg)&quot;)
public static ST_Agraph_s realFillRanks(ST_Agraph_s g, int[] rnks, int rnks_sz, ST_Agraph_s sg) {
<span class="nc" id="L985">ENTERING(&quot;pv0rbbdopo4hmkbl5916qys1&quot;,&quot;realFillRanks&quot;);</span>
try {
<span class="nc" id="L987"> UNSUPPORTED(&quot;2o2sf6xi2aumo5k0vglp4ik2y&quot;); // static Agraph_t*</span>
<span class="nc" id="L988">UNSUPPORTED(&quot;3pmsfb0uhqmy5u141c932dtn1&quot;); // realFillRanks (Agraph_t* g, int rnks[], int rnks_sz, Agraph_t* sg)</span>
<span class="nc" id="L989">UNSUPPORTED(&quot;erg9i1970wdri39osu8hx2a6e&quot;); // {</span>
<span class="nc" id="L990">UNSUPPORTED(&quot;apiu3v3f9zs9yrq8e25nd2rti&quot;); //     int i, c;</span>
<span class="nc" id="L991">UNSUPPORTED(&quot;6yramhpyls8c6kexupyqip8oq&quot;); //     Agedge_t* e;</span>
<span class="nc" id="L992">UNSUPPORTED(&quot;ci2zh69w6nhi0q816i1ixuy9k&quot;); //     Agnode_t* n;</span>
<span class="nc" id="L993">UNSUPPORTED(&quot;7z5fb6iyowsosn1hiz7opeoc6&quot;); //     for (c = 1; c &lt;= GD_n_cluster(g); c++)</span>
<span class="nc" id="L994">UNSUPPORTED(&quot;wqxqmv4he79njsw6r7sludv&quot;); // 	sg = realFillRanks (GD_clust(g)[c], rnks, rnks_sz, sg);</span>
<span class="nc" id="L995">UNSUPPORTED(&quot;8htor72y55gsejjdeh0e8gdrs&quot;); //     if (dot_root(g) == g)</span>
<span class="nc" id="L996">UNSUPPORTED(&quot;bjae04ek2s3o50399zti5a1jh&quot;); // 	return sg;</span>
<span class="nc" id="L997">UNSUPPORTED(&quot;bqfhaopbxlwv8h4zfae1lhx6s&quot;); //     memset (rnks, 0, sizeof(int)*rnks_sz);</span>
<span class="nc" id="L998">UNSUPPORTED(&quot;7wq24g054kmx3aw25vk5ksj4&quot;); //     for (n = agfstnode(g); n; n = agnxtnode(g,n)) {</span>
<span class="nc" id="L999">UNSUPPORTED(&quot;do7v5atqor4gnpwgo18ibgjha&quot;); // 	rnks[ND_rank(n)] = 1;</span>
<span class="nc" id="L1000">UNSUPPORTED(&quot;9fo44dng5uojukw2kj0z8vvdu&quot;); // 	for (e = agfstout(g,n); e; e = agnxtout(g,e)) {</span>
<span class="nc" id="L1001">UNSUPPORTED(&quot;emlgvc6yzuboae72y6vxpn8z7&quot;); // 	    for (i = ND_rank(n)+1; i &lt;= ND_rank(aghead(e)); i++) </span>
<span class="nc" id="L1002">UNSUPPORTED(&quot;d3fd9x50ix980jjw3old2jrcr&quot;); // 		rnks[i] = 1;</span>
<span class="nc" id="L1003">UNSUPPORTED(&quot;flupwh3kosf3fkhkxllllt1&quot;); // 	}</span>
<span class="nc" id="L1004">UNSUPPORTED(&quot;dvgyxsnyeqqnyzq696k3vskib&quot;); //     }</span>
<span class="nc" id="L1005">UNSUPPORTED(&quot;7gfo0rr0un3w2026kt6ipknty&quot;); //     for (i = GD_minrank(g); i &lt;= GD_maxrank(g); i++) {</span>
<span class="nc" id="L1006">UNSUPPORTED(&quot;6mjvdb94lywg8d7ui6873f18p&quot;); // 	if (rnks[i] == 0) {</span>
<span class="nc" id="L1007">UNSUPPORTED(&quot;8g0zxrf8w2zly4wln02j3lbnb&quot;); // 	    if (!sg) {</span>
<span class="nc" id="L1008">UNSUPPORTED(&quot;eqx93butvb7swnxbz9j29winp&quot;); // 		sg = agsubg (dot_root(g), &quot;_new_rank&quot;, 1);</span>
<span class="nc" id="L1009">UNSUPPORTED(&quot;6t98dcecgbvbvtpycwiq2ynnj&quot;); // 	    }</span>
<span class="nc" id="L1010">UNSUPPORTED(&quot;9h7suegjozc071a939rh9apw1&quot;); // 	    n = agnode (sg, NULL, 1);</span>
<span class="nc" id="L1011">UNSUPPORTED(&quot;8kclviftszfxkowsmlqq31u8&quot;); // 	    agbindrec(n, &quot;Agnodeinfo_t&quot;, sizeof(Agnodeinfo_t), NOT(0));</span>
<span class="nc" id="L1012">UNSUPPORTED(&quot;8wiry1vcdwy6bzdp98nmxss7c&quot;); // 	    ND_rank(n) = i;</span>
<span class="nc" id="L1013">UNSUPPORTED(&quot;dy16sxtk3jj6127wavfcdx4yw&quot;); // 	    ND_lw(n) = ND_rw(n) = 0.5;</span>
<span class="nc" id="L1014">UNSUPPORTED(&quot;6jr3li9af4sp0uxnpnoe8dqh8&quot;); // 	    ND_ht(n) = 1;</span>
<span class="nc" id="L1015">UNSUPPORTED(&quot;c47fetnb62mx46qzuk9ag3qmu&quot;); // 	    ND_UF_size(n) = 1;</span>
<span class="nc" id="L1016">UNSUPPORTED(&quot;899cyghezv8oxs0iomu58zncj&quot;); // 	    alloc_elist(4, ND_in(n));</span>
<span class="nc" id="L1017">UNSUPPORTED(&quot;btfqtg58rqwdh7o4cc0gbaaai&quot;); // 	    alloc_elist(4, ND_out(n));</span>
<span class="nc" id="L1018">UNSUPPORTED(&quot;9zap4z819hsiogrgmekh15f00&quot;); // 	    agsubnode (g, n, 1);</span>
<span class="nc" id="L1019">UNSUPPORTED(&quot;flupwh3kosf3fkhkxllllt1&quot;); // 	}</span>
<span class="nc" id="L1020">UNSUPPORTED(&quot;dvgyxsnyeqqnyzq696k3vskib&quot;); //     }</span>
<span class="nc" id="L1021">UNSUPPORTED(&quot;1jw141gg4omv8r72xcbl5ln0o&quot;); //     return sg;</span>
<span class="nc" id="L1022">UNSUPPORTED(&quot;c24nfmv9i7o5eoqaymbibp7m7&quot;); // }</span>

<span class="nc" id="L1024">throw new UnsupportedOperationException();</span>
} finally {
<span class="nc" id="L1026">LEAVING(&quot;pv0rbbdopo4hmkbl5916qys1&quot;,&quot;realFillRanks&quot;);</span>
}
}




//3 1qy9bupreg1pax62owznr98k
// static void fillRanks (Agraph_t* g) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;fillRanks&quot;, key=&quot;1qy9bupreg1pax62owznr98k&quot;, definition=&quot;static void fillRanks (Agraph_t* g)&quot;)
public static void fillRanks(ST_Agraph_s g) {
<span class="nc" id="L1038">ENTERING(&quot;1qy9bupreg1pax62owznr98k&quot;,&quot;fillRanks&quot;);</span>
try {
    ST_Agraph_s sg;
<span class="nc" id="L1041">    int rnks_sz = GD_maxrank(g) + 2;</span>
<span class="nc" id="L1042">    int[] rnks = new int[rnks_sz];</span>
<span class="nc" id="L1043">    sg = realFillRanks (g, rnks, rnks_sz, null);</span>
<span class="nc" id="L1044">    Memory.free (rnks);</span>
} finally {
<span class="nc" id="L1046">LEAVING(&quot;1qy9bupreg1pax62owznr98k&quot;,&quot;fillRanks&quot;);</span>
}
<span class="nc" id="L1048">}</span>




@Reviewed(when = &quot;14/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;init_mincross&quot;, key=&quot;7fy4chyk12o7bgp1rv3h27yl3&quot;, definition=&quot;static void init_mincross(graph_t * g)&quot;)
public static void init_mincross(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1057">ENTERING(&quot;7fy4chyk12o7bgp1rv3h27yl3&quot;,&quot;init_mincross&quot;);</span>
try {
    int size;
    //if (Verbose)
	//start_timer();
    
<span class="fc" id="L1063">    zz.ReMincross = false;</span>
<span class="fc" id="L1064">    zz.Root = g;</span>
    /* alloc +1 for the null terminator usage in do_ordering() */
    /* also, the +1 avoids attempts to alloc 0 sizes, something
       that efence complains about */
<span class="fc" id="L1068">    size = agnedges(zz, dot_root(g)) + 1;</span>
<span class="fc" id="L1069">    zz.TE_list = CArrayOfStar.&lt;ST_Agedge_s&gt;ALLOC(size, ZType.ST_Agedge_s);</span>
<span class="fc" id="L1070">    zz.TI_list = new int[size];</span>
<span class="fc" id="L1071">    mincross_options(zz, g);</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">    if ((GD_flags(g) &amp; NEW_RANK)!=0)</span>
<span class="nc" id="L1073">	fillRanks (g);</span>
<span class="fc" id="L1074">    class2(zz, g);</span>
<span class="fc" id="L1075">    decompose(zz, g, 1);</span>
<span class="fc" id="L1076">    allocate_ranks(zz, g);</span>
<span class="fc" id="L1077">    ordered_edges(zz, g);</span>
<span class="fc" id="L1078">    zz.GlobalMinRank = GD_minrank(g);</span>
<span class="fc" id="L1079">    zz.GlobalMaxRank = GD_maxrank(g);</span>
} finally {
<span class="fc" id="L1081">LEAVING(&quot;7fy4chyk12o7bgp1rv3h27yl3&quot;,&quot;init_mincross&quot;);</span>
}
<span class="fc" id="L1083">}</span>




//3 6fprrp93vmz0jn3l4ro0iropp
// void flat_rev(Agraph_t * g, Agedge_t * e) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;flat_rev&quot;, key=&quot;6fprrp93vmz0jn3l4ro0iropp&quot;, definition=&quot;void flat_rev(Agraph_t * g, Agedge_t * e)&quot;)
public static void flat_rev(ST_Agraph_s g, ST_Agedge_s e) {
<span class="nc" id="L1093">ENTERING(&quot;6fprrp93vmz0jn3l4ro0iropp&quot;,&quot;flat_rev&quot;);</span>
try {
    int j;
    ST_Agedge_s rev;
<span class="nc bnc" id="L1097" title="All 2 branches missed.">    if (((ND_flat_out(aghead(e)).list))==null)</span>
<span class="nc" id="L1098">	rev = null;</span>
    else
<span class="nc bnc" id="L1100" title="All 2 branches missed.">	for (j = 0; (rev = (ST_Agedge_s) ND_flat_out(aghead(e)).list.get_(j))!=null; j++)</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">	    if (aghead(rev) == agtail(e))</span>
<span class="nc" id="L1102">		break;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">    if (rev!=null) {</span>
<span class="nc" id="L1104">	merge_oneway(e, rev);</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">	if (ED_to_virt(e) == null)</span>
<span class="nc" id="L1106">	    ED_to_virt(e, rev);</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">	if ((ED_edge_type(rev) == 4)</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">	    &amp;&amp; (ED_to_orig(rev) == null))</span>
<span class="nc" id="L1109">	    ED_to_orig(rev, e);</span>
<span class="nc" id="L1110">	elist_append(e, ND_other(agtail(e)));</span>
    } else {
<span class="nc" id="L1112">	rev = new_virtual_edge(aghead(e), agtail(e), e);</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">	if (ED_edge_type(e) == 4)</span>
<span class="nc" id="L1114">	    ED_edge_type(rev, 4);</span>
	else
<span class="nc" id="L1116">	    ED_edge_type(rev, 3);</span>
<span class="nc" id="L1117">	ED_label(rev, ED_label(e));</span>
<span class="nc" id="L1118">	flat_edge(g, rev);</span>
    }
} finally {
<span class="nc" id="L1121">LEAVING(&quot;6fprrp93vmz0jn3l4ro0iropp&quot;,&quot;flat_rev&quot;);</span>
}
<span class="nc" id="L1123">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;flat_search&quot;, key=&quot;63ol0ch6cgln1nvl5oiz6n1v0&quot;, definition=&quot;static void flat_search(graph_t * g, node_t * v)&quot;)
public static void flat_search(Globals zz, ST_Agraph_s g, ST_Agnode_s v) {
<span class="fc" id="L1132">ENTERING(&quot;63ol0ch6cgln1nvl5oiz6n1v0&quot;,&quot;flat_search&quot;);</span>
try {
    int i;
    boolean hascl;
    ST_Agedge_s e;
<span class="fc" id="L1137">    ST_adjmatrix_t M = GD_rank(g).get__(ND_rank(v)).flat;</span>
    
<span class="fc" id="L1139">    ND_mark(v, true);</span>
<span class="fc" id="L1140">    ND_onstack(v, true);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">    hascl = (GD_n_cluster(dot_root(g)) &gt; 0);</span>
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">    if (ND_flat_out(v).list!=null)</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">	for (i = 0; (e = (ST_Agedge_s) ND_flat_out(v).list.get_(i))!=null; i++) {</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">	    if (hascl</span>
<span class="pc bpc" id="L1145" title="2 of 4 branches missed.">		&amp;&amp; !(agcontains(zz, g, agtail(e)) &amp;&amp; agcontains(zz, g, aghead(e))))</span>
<span class="nc" id="L1146">		continue;</span>
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">	    if (ED_weight(e) == 0)</span>
<span class="nc" id="L1148">		continue;</span>
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">	    if (ND_onstack(aghead(e)) == true) {</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">		assert(ND_low(aghead(e)) &lt; M.nrows);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">		assert(ND_low(agtail(e)) &lt; M.ncols);</span>
<span class="nc" id="L1152">		M.data[ND_low(aghead(e))][ND_low(agtail(e))]=1;</span>
<span class="nc" id="L1153">		delete_flat_edge(e);</span>
<span class="nc" id="L1154">		i--;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">		if (ED_edge_type(e) == FLATORDER)</span>
<span class="nc" id="L1156">		    continue;</span>
<span class="nc" id="L1157">		flat_rev(g, e);</span>
	    } else {
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">		assert(ND_low(aghead(e)) &lt; M.nrows);</span>
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">		assert(ND_low(agtail(e)) &lt; M.ncols);</span>
<span class="fc" id="L1161">		M.data[ND_low(agtail(e))][ND_low(aghead(e))]=1;</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">		if (ND_mark(aghead(e)) == 0)</span>
<span class="fc" id="L1163">		    flat_search(zz, g, aghead(e));</span>
	    }
	}
<span class="fc" id="L1166">    ND_onstack(v, 0);</span>
} finally {
<span class="fc" id="L1168">LEAVING(&quot;63ol0ch6cgln1nvl5oiz6n1v0&quot;,&quot;flat_search&quot;);</span>
}
<span class="fc" id="L1170">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;flat_breakcycles&quot;, key=&quot;3v5h7z4vqivibvpt913lg8at0&quot;, definition=&quot;static void flat_breakcycles(graph_t * g)&quot;)
public static void flat_breakcycles(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1179">ENTERING(&quot;3v5h7z4vqivibvpt913lg8at0&quot;,&quot;flat_breakcycles&quot;);</span>
try {
    int i, r, flat;
    ST_Agnode_s v;
    
<span class="fc bfc" id="L1184" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L1185">	flat = 0;</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">	for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L1187">	    v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc" id="L1188">	    ND_mark(v, 0); ND_onstack(v, 0);</span>
<span class="fc" id="L1189">	    flatindex(v, i);</span>
<span class="fc bfc" id="L1190" title="All 4 branches covered.">	    if ((ND_flat_out(v).size &gt; 0) &amp;&amp; (flat == 0)) {</span>
<span class="fc" id="L1191">		GD_rank(g).get__(r).flat =</span>
<span class="fc" id="L1192">		    new_matrix(GD_rank(g).get__(r).n, GD_rank(g).get__(r).n);</span>
<span class="fc" id="L1193">		flat = 1;</span>
	    }
	}
<span class="fc bfc" id="L1196" title="All 2 branches covered.">	if (flat!=0) {</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">	    for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L1198">		v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">		if (ND_mark(v) == 0)</span>
<span class="fc" id="L1200">		    flat_search(zz, g, v);</span>
	    }
	}
    }
} finally {
<span class="fc" id="L1205">LEAVING(&quot;3v5h7z4vqivibvpt913lg8at0&quot;,&quot;flat_breakcycles&quot;);</span>
}
<span class="fc" id="L1207">}</span>



/* allocate_ranks:
 * Allocate rank structure, determining number of nodes per rank.
 * Note that no nodes are put into the structure yet.
 */
@Difficult
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;allocate_ranks&quot;, key=&quot;d5vb6jiw8mhkaa8gjwn4eqfyn&quot;, definition=&quot;void allocate_ranks(graph_t * g)&quot;)
public static void allocate_ranks(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1219">ENTERING(&quot;d5vb6jiw8mhkaa8gjwn4eqfyn&quot;,&quot;allocate_ranks&quot;);</span>
try {
    int r, low, high;
    int cn[];
    ST_Agnode_s n;
    ST_Agedge_s e;
    
<span class="fc" id="L1226">	cn = new int[GD_maxrank(g) + 2];</span>
	/* must be 0 based, not GD_minrank */
<span class="fc bfc" id="L1228" title="All 2 branches covered.">    for (n = agfstnode(zz, g); n!=null; n = agnxtnode(zz, g, n)) {</span>
<span class="fc" id="L1229">   	cn[ND_rank(n)]++;</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">	for (e = agfstout(zz, g, n); e!=null; e = agnxtout(zz, g, e)) {</span>
<span class="fc" id="L1231">	    low = ND_rank(agtail(e));</span>
<span class="fc" id="L1232">	    high = ND_rank(aghead(e));</span>
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">	    if (low &gt; high) {</span>
<span class="nc" id="L1234">		int t = low;</span>
<span class="nc" id="L1235">		low = high;</span>
<span class="nc" id="L1236">		high = t;</span>
	    }
<span class="fc bfc" id="L1238" title="All 2 branches covered.">	    for (r = low + 1; r &lt; high; r++)</span>
<span class="fc" id="L1239">			cn[r]++;</span>
	}
    }
<span class="fc" id="L1242">    GD_rank(g, CArray.&lt;ST_rank_t&gt;ALLOC__(GD_maxrank(g) + 2, ZType.ST_rank_t));</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc" id="L1244">	GD_rank(g).get__(r).n = cn[r];</span>
<span class="fc" id="L1245">	GD_rank(g).get__(r).an = cn[r];</span>
<span class="fc" id="L1246">	CArrayOfStar&lt;ST_Agnode_s&gt; tmp = CArrayOfStar.&lt;ST_Agnode_s&gt;ALLOC(cn[r] + 1, ZType.ST_Agnode_s);</span>
<span class="fc" id="L1247">	GD_rank(g).get__(r).v = tmp;</span>
<span class="fc" id="L1248">	GD_rank(g).get__(r).av = tmp;</span>
    }
<span class="fc" id="L1250">    Memory.free(cn);</span>
} finally {
<span class="fc" id="L1252">LEAVING(&quot;d5vb6jiw8mhkaa8gjwn4eqfyn&quot;,&quot;allocate_ranks&quot;);</span>
}
<span class="fc" id="L1254">}</span>




/* install a node at the current right end of its rank */
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;install_in_rank&quot;, key=&quot;3lxoqxhiri9fgt20zc5jz3aa5&quot;, definition=&quot;void install_in_rank(graph_t * g, node_t * n)&quot;)
public static void install_in_rank(Globals zz, ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L1263">ENTERING(&quot;3lxoqxhiri9fgt20zc5jz3aa5&quot;,&quot;install_in_rank&quot;);</span>
try {
    int i, r;
    
<span class="fc" id="L1267">    r = ND_rank(n);</span>
<span class="fc" id="L1268">    i = GD_rank(g).get__(r).n;</span>
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">    if (GD_rank(g).get__(r).an &lt;= 0) {</span>
<span class="nc" id="L1270">	UNSUPPORTED(&quot;8qk1xhvvb994zhv9aq10k4v12&quot;); // 	agerr(AGERR, &quot;install_in_rank, line %d: %s %s rank %d i = %d an = 0\n&quot;,</span>
<span class="nc" id="L1271">	UNSUPPORTED(&quot;53h8d82ax23hys2k21hjswp72&quot;); // 	      1034, agnameof(g), agnameof(n), r, i);</span>
<span class="nc" id="L1272">	return;</span>
    }
    
<span class="fc" id="L1275">    GD_rank(g).get__(r).v.set_(i, n);</span>
<span class="fc" id="L1276">    ND_order(n, i);</span>
<span class="fc" id="L1277">    GD_rank(g).get__(r).n++;</span>
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">    assert(GD_rank(g).get__(r).n &lt;= GD_rank(g).get__(r).an);</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">    if (ND_order(n) &gt; GD_rank(zz.Root).get__(r).an) {</span>
<span class="nc" id="L1280">	UNSUPPORTED(&quot;399szcw1txekt1xssyw7s2x07&quot;); // 	agerr(AGERR, &quot;install_in_rank, line %d: ND_order(%s) [%d] &gt; GD_rank(Root)[%d].an [%d]\n&quot;,</span>
<span class="nc" id="L1281">	UNSUPPORTED(&quot;9puojrmsk6vb1qc0jtr8ge4g8&quot;); // 	      1052, agnameof(n), ND_order(n), r, GD_rank(Root)[r].an);</span>
<span class="nc" id="L1282">	return;</span>
    }
<span class="pc bpc" id="L1284" title="2 of 4 branches missed.">    if ((r &lt; GD_minrank(g)) || (r &gt; GD_maxrank(g))) {</span>
<span class="nc" id="L1285">	UNSUPPORTED(&quot;7o1thnqda767wqpe2lh9mj03t&quot;); // 	agerr(AGERR, &quot;install_in_rank, line %d: rank %d not in rank range [%d,%d]\n&quot;,</span>
<span class="nc" id="L1286">	UNSUPPORTED(&quot;d2ugluzf7bmj7osicgitgy3sr&quot;); // 	      1057, r, GD_minrank(g), GD_maxrank(g));</span>
<span class="nc" id="L1287">	return;</span>
    }
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">    if (GD_rank(g).get__(r).v.plus_(ND_order(n)).comparePointer_(</span>
<span class="fc" id="L1290">	GD_rank(g).get__(r).av.plus_(GD_rank(zz.Root).get__(r).an))&gt;0) {</span>
<span class="nc" id="L1291">	UNSUPPORTED(&quot;3eb32nc5czs5auwzz5p5mtl04&quot;); // 	agerr(AGERR, &quot;install_in_rank, line %d: GD_rank(g)[%d].v + ND_order(%s) [%d] &gt; GD_rank(g)[%d].av + GD_rank(Root)[%d].an [%d]\n&quot;,</span>
<span class="nc" id="L1292">	UNSUPPORTED(&quot;3qe3qpw5h6vse39xs1ca9sjmo&quot;); // 	      1062, r, agnameof(n),GD_rank(g)[r].v + ND_order(n), r, r, GD_rank(g)[r].av+GD_rank(Root)[r].an);</span>
<span class="nc" id="L1293">	return;</span>
    }
} finally {
<span class="fc" id="L1296">LEAVING(&quot;3lxoqxhiri9fgt20zc5jz3aa5&quot;,&quot;install_in_rank&quot;);</span>
}
<span class="fc" id="L1298">}</span>




/*	install nodes in ranks. the initial ordering ensure that series-parallel
 *	graphs such as trees are drawn with no crossings.  it tries searching
 *	in- and out-edges and takes the better of the two initial orderings.
 */
@Reviewed(when = &quot;15/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;build_ranks&quot;, key=&quot;7t49bz6lfcbd9v63ds2x3518z&quot;, definition=&quot;void build_ranks(graph_t * g, int pass)&quot;)
public static void build_ranks(Globals zz, ST_Agraph_s g, int pass) {
<span class="fc" id="L1311">ENTERING(&quot;7t49bz6lfcbd9v63ds2x3518z&quot;,&quot;build_ranks&quot;);</span>
try {
    int i, j;
<span class="fc" id="L1314">    ST_Agnode_s n, n0 = null;</span>
    CArrayOfStar&lt;ST_Agedge_s&gt; otheredges;
    ST_nodequeue q;
    
<span class="fc" id="L1318">    q = new_queue(GD_n_nodes(g));</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">    for (n = GD_nlist(g); n!=null; n = ND_next(n))</span>
<span class="fc" id="L1320">	ND_mark(n, 0);</span>
    
<span class="fc bfc" id="L1322" title="All 2 branches covered.">    for (i = GD_minrank(g); i &lt;= GD_maxrank(g); i++)</span>
<span class="fc" id="L1323">	GD_rank(g).get__(i).n = 0;</span>
    
<span class="fc bfc" id="L1325" title="All 2 branches covered.">    for (n = GD_nlist(g); n!=null; n = ND_next(n)) {</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">	otheredges = ((pass == 0) ? ND_in(n).list : ND_out(n).list);</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">	if (otheredges.get_(0)!= null)</span>
<span class="fc" id="L1328">	    continue;</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">	if (ND_mark(n) == 0) {</span>
<span class="fc" id="L1330">	    ND_mark(n,  1);</span>
<span class="fc" id="L1331">	    enqueue(q, n);</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">	    while ((n0 = dequeue(q))!=null) {</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">		if (ND_ranktype(n0) != CLUSTER) {</span>
<span class="fc" id="L1334">		    install_in_rank(zz, g, n0);</span>
<span class="fc" id="L1335">		    enqueue_neighbors(q, n0, pass);</span>
		} else {
<span class="fc" id="L1337">		    install_cluster(zz, g, n0, pass, q);</span>
		}
	    }
	}
    }
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">    if (dequeue(q)!=null)</span>
<span class="nc" id="L1343">    UNSUPPORTED(&quot;1b3hbd5artrq77i58q2o9kgz3&quot;); // 	agerr(AGERR, &quot;surprise\n&quot;);</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">    for (i = GD_minrank(g); i &lt;= GD_maxrank(g); i++) {</span>
<span class="fc" id="L1345">	GD_rank(zz.Root).get__(i).valid = 0;</span>
<span class="pc bpc" id="L1346" title="1 of 4 branches missed.">	if (GD_flip(g) &amp;&amp; (GD_rank(g).get__(i).n &gt; 0)) {</span>
	    int nn, ndiv2;
<span class="fc" id="L1348">	    CArrayOfStar&lt;ST_Agnode_s&gt; vlist = GD_rank(g).get__(i).v;</span>
<span class="fc" id="L1349">	    nn = GD_rank(g).get__(i).n - 1;</span>
<span class="fc" id="L1350">	    ndiv2 = nn / 2;</span>
<span class="fc bfc" id="L1351" title="All 2 branches covered.">	    for (j = 0; j &lt;= ndiv2; j++)</span>
<span class="fc" id="L1352">		exchange(zz, vlist.get_(j), vlist.get_(nn - j));</span>
	}
    }
    
    
<span class="fc bfc" id="L1357" title="All 4 branches covered.">    if (g == dot_root(g) &amp;&amp; ncross(zz, g) &gt; 0)</span>
<span class="fc" id="L1358">	transpose(zz, g, false);</span>
<span class="fc" id="L1359">    free_queue(q);</span>
} finally {
<span class="fc" id="L1361">LEAVING(&quot;7t49bz6lfcbd9v63ds2x3518z&quot;,&quot;build_ranks&quot;);</span>
}
<span class="fc" id="L1363">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;enqueue_neighbors&quot;, key=&quot;bmjlneqxex6a9silzkkidkx6s&quot;, definition=&quot;void enqueue_neighbors(nodequeue * q, node_t * n0, int pass)&quot;)
public static void enqueue_neighbors(ST_nodequeue q, ST_Agnode_s n0, int pass) {
<span class="fc" id="L1371">ENTERING(&quot;bmjlneqxex6a9silzkkidkx6s&quot;,&quot;enqueue_neighbors&quot;);</span>
try {
    int i;
    ST_Agedge_s e;
    
<span class="fc bfc" id="L1376" title="All 2 branches covered.">    if (pass == 0) {</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">	for (i = 0; i &lt; ND_out(n0).size; i++) {</span>
<span class="fc" id="L1378">	    e = (ST_Agedge_s) ND_out(n0).list.get_(i);</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">	    if ((ND_mark(aghead(e))) == 0) {</span>
<span class="fc" id="L1380">		ND_mark(aghead(e), 1);</span>
<span class="fc" id="L1381">		enqueue(q, aghead(e));</span>
	    }
	}
    } else {
<span class="fc bfc" id="L1385" title="All 2 branches covered.">	for (i = 0; i &lt; ND_in(n0).size; i++) {</span>
<span class="fc" id="L1386">	    e = (ST_Agedge_s) ND_in(n0).list.get_(i);</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">	    if (((ND_mark(agtail(e)))) == 0) {</span>
<span class="fc" id="L1388">		ND_mark(agtail(e), 1);</span>
<span class="fc" id="L1389">		enqueue(q, agtail(e));</span>
	    }
	}
    }
} finally {
<span class="fc" id="L1394">LEAVING(&quot;bmjlneqxex6a9silzkkidkx6s&quot;,&quot;enqueue_neighbors&quot;);</span>
}
<span class="fc" id="L1396">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;constraining_flat_edge&quot;, key=&quot;c8nqj0v20api63pikohsbx92u&quot;, definition=&quot;static int constraining_flat_edge(Agraph_t *g, Agnode_t *v, Agedge_t *e)&quot;)
public static boolean constraining_flat_edge(Globals zz, ST_Agraph_s g, ST_Agnode_s v, ST_Agedge_s e) {
<span class="fc" id="L1404">ENTERING(&quot;c8nqj0v20api63pikohsbx92u&quot;,&quot;constraining_flat_edge&quot;);</span>
try {
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">	if (ED_weight(e) == 0) return false;</span>
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">	if (!inside_cluster(zz, g,agtail(e))) return false;</span>
<span class="pc bpc" id="L1408" title="1 of 2 branches missed.">	if (!inside_cluster(zz, g,aghead(e))) return false;</span>
<span class="fc" id="L1409">	return true;</span>
} finally {
<span class="fc" id="L1411">LEAVING(&quot;c8nqj0v20api63pikohsbx92u&quot;,&quot;constraining_flat_edge&quot;);</span>
}
}




/* construct nodes reachable from 'here' in post-order.
* This is the same as doing a topological sort in reverse order.
*/
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;postorder&quot;, key=&quot;46to0pkk188af2dlkik2ab7e3&quot;, definition=&quot;static int postorder(graph_t * g, node_t * v, node_t ** list, int r)&quot;)
public static int postorder(Globals zz, ST_Agraph_s g, ST_Agnode_s v, CArrayOfStar&lt;ST_Agnode_s&gt; list, int r) {
<span class="fc" id="L1424">ENTERING(&quot;46to0pkk188af2dlkik2ab7e3&quot;,&quot;postorder&quot;);</span>
try {
    ST_Agedge_s e;
<span class="fc" id="L1427">    int i, cnt = 0;</span>
    
<span class="fc" id="L1429">    ND_mark(v, true);</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">    if (ND_flat_out(v).size &gt; 0) {</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">	for (i = 0; (e = (ST_Agedge_s) ND_flat_out(v).list.get_(i))!=null; i++) {</span>
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">	    if (!constraining_flat_edge(zz, g,v,e)) continue;</span>
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">	    if ((ND_mark(aghead(e))) == 0)</span>
<span class="fc" id="L1434">		cnt += postorder(zz, g, aghead(e), list.plus_(cnt), r);</span>
	}
    }
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">    assert(ND_rank(v) == r);</span>
<span class="fc" id="L1438">    list.set_(cnt++, v);</span>
<span class="fc" id="L1439">    return cnt;</span>
} finally {
<span class="fc" id="L1441">LEAVING(&quot;46to0pkk188af2dlkik2ab7e3&quot;,&quot;postorder&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;flat_reorder&quot;, key=&quot;zuxoswju917kyl08a5f0gtp6&quot;, definition=&quot;static void flat_reorder(graph_t * g)&quot;)
public static void flat_reorder(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1452">ENTERING(&quot;zuxoswju917kyl08a5f0gtp6&quot;,&quot;flat_reorder&quot;);</span>
try {
    int i, j, r, pos, n_search, local_in_cnt, local_out_cnt, base_order;
    ST_Agnode_s v, t;
    CArrayOfStar&lt;ST_Agnode_s&gt; left, right;
<span class="fc" id="L1457">    CArrayOfStar&lt;ST_Agnode_s&gt; temprank = null;</span>
    ST_Agedge_s flat_e, e;
    
<span class="fc bfc" id="L1460" title="All 2 branches covered.">    if (GD_has_flat_edges(g) == 0)</span>
<span class="fc" id="L1461">	return;</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt;= GD_maxrank(g); r++) {</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">	if (GD_rank(g).get__(r).n == 0) continue;</span>
<span class="fc" id="L1464">	base_order = ND_order(GD_rank(g).get__(r).v.get_(0));</span>
<span class="fc bfc" id="L1465" title="All 2 branches covered.">	for (i = 0; i &lt; GD_rank(g).get__(r).n; i++)</span>
<span class="fc" id="L1466">	    ND_mark(GD_rank(g).get__(r).v.get_(i), 0);</span>
<span class="fc" id="L1467">	temprank = CArrayOfStar.&lt;ST_Agnode_s&gt;REALLOC(i + 1, temprank, ZType.ST_Agnode_s);</span>
<span class="fc" id="L1468">	pos = 0;</span>
	
	/* construct reverse topological sort order in temprank */
<span class="fc bfc" id="L1471" title="All 2 branches covered.">	for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="pc bpc" id="L1472" title="1 of 2 branches missed.">	    if (GD_flip(g)) v = (ST_Agnode_s) GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc" id="L1473">	    else v = GD_rank(g).get__(r).v.get_(GD_rank(g).get__(r).n - i - 1);</span>
	    
<span class="fc" id="L1475">	    local_in_cnt = local_out_cnt = 0;</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">	    for (j = 0; j &lt; ND_flat_in(v).size; j++) {</span>
<span class="fc" id="L1477">		flat_e = (ST_Agedge_s) ND_flat_in(v).list.get_(j);</span>
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">		if (constraining_flat_edge(zz, g,v,flat_e)) local_in_cnt++;</span>
	    }
<span class="fc bfc" id="L1480" title="All 2 branches covered.">	    for (j = 0; j &lt; ND_flat_out(v).size; j++) {</span>
<span class="fc" id="L1481">		flat_e = (ST_Agedge_s) ND_flat_out(v).list.get_(j);</span>
<span class="pc bpc" id="L1482" title="1 of 2 branches missed.">		if (constraining_flat_edge(zz, g,v,flat_e)) local_out_cnt++;</span>
	    }
<span class="fc bfc" id="L1484" title="All 4 branches covered.">	    if ((local_in_cnt == 0) &amp;&amp; (local_out_cnt == 0))</span>
<span class="fc" id="L1485">		temprank.set_(pos++, v);</span>
	    else {
<span class="fc bfc" id="L1487" title="All 4 branches covered.">		if ((ND_mark(v) == 0) &amp;&amp; (local_in_cnt == 0)) {</span>
<span class="fc" id="L1488">		    left = temprank.plus_(pos);</span>
<span class="fc" id="L1489">		    n_search = postorder(zz, g, v, left, r);</span>
<span class="fc" id="L1490">		    pos += n_search;</span>
		}
	    }
	}
	
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">	if (pos!=0) {</span>
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">	    if (GD_flip(g) == false) {</span>
<span class="fc" id="L1497">		left = temprank;</span>
<span class="fc" id="L1498">		right = temprank.plus_(pos - 1);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">		while (left.comparePointer_(right) &lt; 0) {</span>
<span class="fc" id="L1500">		    t = left.get_(0);</span>
<span class="fc" id="L1501">		    left.set_(0, right.get_(0));</span>
<span class="fc" id="L1502">		    right.set_(0, t);</span>
<span class="fc" id="L1503">		    left = left.plus_(1);</span>
<span class="fc" id="L1504">		    right = right.plus_(-1);</span>
		}
	    }
<span class="fc bfc" id="L1507" title="All 2 branches covered.">	    for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L1508">		v = temprank.get_(i);</span>
<span class="fc" id="L1509">		GD_rank(g).get__(r).v.set_(i, v);</span>
<span class="fc" id="L1510">		ND_order(v, i + base_order);</span>
	    }
	    
	    /* nonconstraint flat edges must be made LR */
<span class="fc bfc" id="L1514" title="All 2 branches covered.">	    for (i = 0; i &lt; GD_rank(g).get__(r).n; i++) {</span>
<span class="fc" id="L1515">		v = GD_rank(g).get__(r).v.get_(i);</span>
<span class="fc bfc" id="L1516" title="All 2 branches covered.">		if (ND_flat_out(v).list!=null) {</span>
<span class="fc bfc" id="L1517" title="All 2 branches covered.">		    for (j = 0; (e = (ST_Agedge_s) ND_flat_out(v).list.get_(j))!=null; j++) {</span>
<span class="pc bpc" id="L1518" title="2 of 4 branches missed.">			if ( ((GD_flip(g) == false) &amp;&amp; (ND_order(aghead(e)) &lt; ND_order(agtail(e)))) ||</span>
<span class="pc bpc" id="L1519" title="3 of 4 branches missed.">				 ( (GD_flip(g)) &amp;&amp; (ND_order(aghead(e)) &gt; ND_order(agtail(e)) ))) {</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">			    assert(constraining_flat_edge(zz, g,v,e) == false);</span>
<span class="nc" id="L1521">			    delete_flat_edge(e);</span>
<span class="nc" id="L1522">			    j--;</span>
<span class="nc" id="L1523">			    flat_rev(g, e);</span>
			}
		    }
		}
	    }
	    /* postprocess to restore intended order */
	}
	/* else do no harm! */
<span class="fc" id="L1531">	GD_rank(zz.Root).get__(r).valid = 0;</span>
    }
<span class="pc bpc" id="L1533" title="1 of 2 branches missed.">    if (temprank!=null)</span>
<span class="fc" id="L1534">	Memory.free(temprank);</span>
} finally {
<span class="fc" id="L1536">LEAVING(&quot;zuxoswju917kyl08a5f0gtp6&quot;,&quot;flat_reorder&quot;);</span>
}
<span class="fc" id="L1538">}</span>




@Reviewed(when = &quot;16/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;reorder&quot;, key=&quot;inv6wazjcnh4xkzzphsdcmg4&quot;, definition=&quot;static void reorder(graph_t * g, int r, int reverse, int hasfixed)&quot;)
public static void reorder(Globals zz, ST_Agraph_s g, int r, boolean reverse, boolean hasfixed) {
<span class="fc" id="L1546">ENTERING(&quot;inv6wazjcnh4xkzzphsdcmg4&quot;,&quot;reorder&quot;);</span>
try {
<span class="fc" id="L1548">    boolean changed = false;</span>
    int nelt;
    boolean muststay, sawclust;
<span class="fc" id="L1551">    CArrayOfStar&lt;ST_Agnode_s&gt; vlist = GD_rank(g).get__(r).v;</span>
<span class="fc" id="L1552">    CArrayOfStar&lt;ST_Agnode_s&gt; lp, rp=null, ep = vlist.plus_(GD_rank(g).get__(r).n);</span>
    
<span class="fc bfc" id="L1554" title="All 2 branches covered.">    for (nelt = GD_rank(g).get__(r).n - 1; nelt &gt;= 0; nelt--) {</span>
<span class="fc" id="L1555">	lp = vlist;</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">	while (lp.comparePointer_(ep)&lt;0) {</span>
	    /* find leftmost node that can be compared */
<span class="fc bfc" id="L1558" title="All 4 branches covered.">	    while ((lp.comparePointer_(ep) &lt; 0) &amp;&amp; (ND_mval(lp.get_(0)) &lt; 0))</span>
<span class="fc" id="L1559">		lp = lp.plus_(1);</span>
<span class="fc bfc" id="L1560" title="All 2 branches covered.">	    if (lp.comparePointer_(ep) &gt;= 0)</span>
<span class="fc" id="L1561">		break;</span>
	    /* find the node that can be compared */
<span class="fc" id="L1563">	    sawclust = muststay = false;</span>
<span class="fc bfc" id="L1564" title="All 2 branches covered.">	    for (rp = lp.plus_(1); rp.comparePointer_(ep) &lt; 0; rp=rp.plus_(1)) {</span>
<span class="pc bpc" id="L1565" title="3 of 4 branches missed.">		if (sawclust &amp;&amp; ND_clust(rp.get_(0))!=null)</span>
<span class="nc" id="L1566">		    continue;	/* ### */</span>
<span class="pc bpc" id="L1567" title="1 of 2 branches missed.">		if (left2right(zz, g, lp.get_(0), rp.get_(0))) {</span>
<span class="nc" id="L1568">		    muststay = true;</span>
<span class="nc" id="L1569">		    break;</span>
		}
<span class="fc bfc" id="L1571" title="All 2 branches covered.">		if (ND_mval(rp.get_(0)) &gt;= 0)</span>
<span class="fc" id="L1572">		    break;</span>
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">		if (ND_clust(rp.get_(0))!=null)</span>
<span class="nc" id="L1574">		    sawclust = true;	/* ### */</span>
	    }
<span class="fc bfc" id="L1576" title="All 2 branches covered.">	    if (rp.comparePointer_(ep) &gt;= 0)</span>
<span class="fc" id="L1577">		break;</span>
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">	    if (muststay == false) {</span>
<span class="fc" id="L1579">		int p1 = (int) (ND_mval(lp.get_(0)));</span>
<span class="fc" id="L1580">		int p2 = (int) (ND_mval(rp.get_(0)));</span>
<span class="fc bfc" id="L1581" title="All 6 branches covered.">		if ((p1 &gt; p2) || ((p1 == p2) &amp;&amp; (reverse))) {</span>
<span class="fc" id="L1582">		    exchange(zz, lp.get_(0), rp.get_(0));</span>
<span class="fc" id="L1583">		    changed=true;</span>
		}
	    }
<span class="fc" id="L1586">	    lp = rp;</span>
	}
<span class="pc bpc" id="L1588" title="1 of 4 branches missed.">	if ((hasfixed == false) &amp;&amp; (reverse == false))</span>
<span class="fc" id="L1589">	    ep = ep.plus_(-1);</span>
    }
<span class="fc bfc" id="L1591" title="All 2 branches covered.">    if (changed) {</span>
<span class="fc" id="L1592">	GD_rank(zz.Root).get__(r).valid= 0;</span>
<span class="fc bfc" id="L1593" title="All 2 branches covered.">	if (r &gt; 0)</span>
<span class="fc" id="L1594">	    GD_rank(zz.Root).get__(r - 1).valid= 0;</span>
    }
} finally {
<span class="fc" id="L1597">LEAVING(&quot;inv6wazjcnh4xkzzphsdcmg4&quot;,&quot;reorder&quot;);</span>
}
<span class="fc" id="L1599">}</span>




//3 14t80owwvm7io4ou6czb9ba9
// static void mincross_step(graph_t * g, int pass) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;mincross_step&quot;, key=&quot;14t80owwvm7io4ou6czb9ba9&quot;, definition=&quot;static void mincross_step(graph_t * g, int pass)&quot;)
public static void mincross_step(Globals zz, ST_Agraph_s g, int pass) {
<span class="fc" id="L1609">ENTERING(&quot;14t80owwvm7io4ou6czb9ba9&quot;,&quot;mincross_step&quot;);</span>
try {
    int r, other, first, last, dir;
    boolean hasfixed, reverse;
<span class="fc bfc" id="L1613" title="All 2 branches covered.">    if ((pass % 4) &lt; 2)</span>
<span class="fc" id="L1614">	reverse = true;</span>
    else
<span class="fc" id="L1616">	reverse = false;</span>
<span class="fc bfc" id="L1617" title="All 2 branches covered.">    if ((pass % 2)!=0) {</span>
<span class="fc" id="L1618">	r = GD_maxrank(g) - 1;</span>
<span class="fc" id="L1619">	dir = -1;</span>
    } /* up pass */
    else {
<span class="fc" id="L1622">	r = 1;</span>
<span class="fc" id="L1623">	dir = 1;</span>
    }				/* down pass */
<span class="fc bfc" id="L1625" title="All 2 branches covered.">    if (pass % 2 == 0) {	/* down pass */</span>
<span class="fc" id="L1626">	first = GD_minrank(g) + 1;</span>
<span class="pc bpc" id="L1627" title="1 of 2 branches missed.">	if (GD_minrank(g) &gt; GD_minrank(zz.Root))</span>
<span class="nc" id="L1628">	    first--;</span>
<span class="fc" id="L1629">	last = GD_maxrank(g);</span>
<span class="fc" id="L1630">	dir = 1;</span>
    } else {			/* up pass */
<span class="fc" id="L1632">	first = GD_maxrank(g) - 1;</span>
<span class="fc" id="L1633">	last = GD_minrank(g);</span>
<span class="pc bpc" id="L1634" title="1 of 2 branches missed.">	if (GD_maxrank(g) &lt; GD_maxrank(zz.Root))</span>
<span class="nc" id="L1635">	    first++;</span>
<span class="fc" id="L1636">	dir = -1;</span>
    }
<span class="fc bfc" id="L1638" title="All 2 branches covered.">    for (r = first; r != last + dir; r += dir) {</span>
<span class="fc" id="L1639">	other = r - dir;</span>
<span class="fc" id="L1640">	hasfixed = medians(zz, g, r, other);</span>
<span class="fc" id="L1641">	reorder(zz, g, r, reverse, hasfixed);</span>
    }
<span class="fc bfc" id="L1643" title="All 2 branches covered.">    transpose(zz, g, !reverse);</span>
} finally {
<span class="fc" id="L1645">LEAVING(&quot;14t80owwvm7io4ou6czb9ba9&quot;,&quot;mincross_step&quot;);</span>
}
<span class="fc" id="L1647">}</span>




//3 aq18oa4k4grixvfjx7r2qnl6r
@Reviewed(when = &quot;01/12/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;local_cross&quot;, key=&quot;aq18oa4k4grixvfjx7r2qnl6r&quot;, definition=&quot;static int local_cross(elist l, int dir)&quot;)
public static int local_cross(final ST_elist l, int dir) {
// WARNING!! STRUCT
<span class="fc" id="L1657">return local_cross_w_(l.copy(), dir);</span>
}
private static int local_cross_w_(final ST_elist l, int dir) {
<span class="fc" id="L1660">ENTERING(&quot;aq18oa4k4grixvfjx7r2qnl6r&quot;,&quot;local_cross&quot;);</span>
try {
    int i, j;
<span class="fc" id="L1663">    boolean is_out = false;</span>
<span class="fc" id="L1664">    int cross = 0;</span>
    ST_Agedge_s e, f;
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">    if (dir &gt; 0)</span>
<span class="fc" id="L1667">	is_out = true;</span>
    else
<span class="nc" id="L1669">	is_out = false;</span>
<span class="fc bfc" id="L1670" title="All 2 branches covered.">    for (i = 0; (e = l.list.get_(i))!=null; i++) {</span>
<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">	if (is_out)</span>
<span class="fc bfc" id="L1672" title="All 2 branches covered.">	    for (j = i + 1; (f = l.list.get_(j))!=null; j++) {</span>
<span class="fc" id="L1673">		if ((ND_order(aghead(f)) - ND_order(aghead(e)))</span>
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">			 * (ED_tail_port(f).p.x - ED_tail_port(e).p.x) &lt; 0)</span>
<span class="nc" id="L1675">UNSUPPORTED(&quot;bw8rwv11yqzss88pad7ljil8a&quot;); // 		    cross += ED_xpenalty(e) * ED_xpenalty(f);</span>
	} else
<span class="nc bnc" id="L1677" title="All 2 branches missed.">	    for (j = i + 1; (f = l.list.get_(j))!=null; j++) {</span>
<span class="nc" id="L1678">UNSUPPORTED(&quot;bza83c6rmihrkzyllwf0jm4tn&quot;); // 		if ((ND_order(agtail(f)) - ND_order(agtail(e)))</span>
<span class="nc" id="L1679">UNSUPPORTED(&quot;csrxg0y1azmvde7t833lm13sp&quot;); // 			* (ED_head_port(f).p.x - ED_head_port(e).p.x) &lt; 0)</span>
<span class="nc" id="L1680">UNSUPPORTED(&quot;bw8rwv11yqzss88pad7ljil8a&quot;); // 		    cross += ED_xpenalty(e) * ED_xpenalty(f);</span>
	    }
    }
<span class="fc" id="L1683">    return cross;</span>
} finally {
<span class="fc" id="L1685">LEAVING(&quot;aq18oa4k4grixvfjx7r2qnl6r&quot;,&quot;local_cross&quot;);</span>
}
}




//static __ptr__ Count;
//static int C;
//3 bk5nklhfqgg0uwkv7tv6dn8r2
// static int rcross(graph_t * g, int r) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;rcross&quot;, key=&quot;bk5nklhfqgg0uwkv7tv6dn8r2&quot;, definition=&quot;static int rcross(graph_t * g, int r)&quot;)
public static int rcross(Globals zz, ST_Agraph_s g, int r) {
<span class="fc" id="L1699">ENTERING(&quot;bk5nklhfqgg0uwkv7tv6dn8r2&quot;,&quot;rcross&quot;);</span>
try {
    int top, bot, cross, max, i, k;
    ST_Agnode_s v;
    CArrayOfStar&lt;ST_Agnode_s&gt; rtop;
    
<span class="fc" id="L1705">    cross = 0;</span>
<span class="fc" id="L1706">    max = 0;</span>
<span class="fc" id="L1707">    rtop = GD_rank(g).get__(r).v;</span>
    
<span class="fc bfc" id="L1709" title="All 2 branches covered.">    if (zz.C &lt;= GD_rank(zz.Root).get__(r + 1).n) {</span>
<span class="fc" id="L1710">	zz.C = GD_rank(zz.Root).get__(r + 1).n + 1;</span>
<span class="fc" id="L1711">	zz.Count = ALLOC_INT(zz.C, zz.Count);</span>
    }
    
<span class="fc bfc" id="L1714" title="All 2 branches covered.">    for (i = 0; i &lt; GD_rank(g).get__(r + 1).n; i++)</span>
<span class="fc" id="L1715">    	zz.Count[i] = 0;</span>
    
<span class="fc bfc" id="L1717" title="All 2 branches covered.">    for (top = 0; top &lt; GD_rank(g).get__(r).n; top++) {</span>
	ST_Agedge_s e;
<span class="fc bfc" id="L1719" title="All 2 branches covered.">	if (max &gt; 0) {</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">	    for (i = 0; (e = (ST_Agedge_s) ND_out(rtop.get_(top)).list.get_(i))!=null; i++) {</span>
<span class="fc bfc" id="L1721" title="All 2 branches covered.">		for (k = ND_order(aghead(e)) + 1; k &lt;= max; k++)</span>
<span class="fc" id="L1722">		    cross += zz.Count[k] * ED_xpenalty(e);</span>
	    }
	}
<span class="fc bfc" id="L1725" title="All 2 branches covered.">	for (i = 0; (e = (ST_Agedge_s) ND_out(rtop.get_(top)).list.get_(i))!=null; i++) {</span>
<span class="fc" id="L1726">	    int inv = ND_order(aghead(e));</span>
<span class="fc bfc" id="L1727" title="All 2 branches covered.">	    if (inv &gt; max)</span>
<span class="fc" id="L1728">		max = inv;</span>
<span class="fc" id="L1729">	    zz.Count[inv] += ED_xpenalty(e);</span>
	}
    }
<span class="fc bfc" id="L1732" title="All 2 branches covered.">    for (top = 0; top &lt; GD_rank(g).get__(r).n; top++) {</span>
<span class="fc" id="L1733">	v = (ST_Agnode_s) GD_rank(g).get__(r).v.get_(top);</span>
<span class="fc bfc" id="L1734" title="All 2 branches covered.">	if (ND_has_port(v))</span>
<span class="fc" id="L1735">	    cross += local_cross(ND_out(v), 1);</span>
    }
<span class="fc bfc" id="L1737" title="All 2 branches covered.">    for (bot = 0; bot &lt; GD_rank(g).get__(r + 1).n; bot++) {</span>
<span class="fc" id="L1738">	v = (ST_Agnode_s) GD_rank(g).get__(r + 1).v.get_(bot);</span>
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">	if (ND_has_port(v))</span>
<span class="nc" id="L1740">	    cross += local_cross(ND_in(v), -1);</span>
    }
<span class="fc" id="L1742">    return cross;</span>
} finally {
<span class="fc" id="L1744">LEAVING(&quot;bk5nklhfqgg0uwkv7tv6dn8r2&quot;,&quot;rcross&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;ncross&quot;, key=&quot;dbjmz2tnii2pn9sxg26ap6w5r&quot;, definition=&quot;int ncross(graph_t * g)&quot;)
public static int ncross(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1754">ENTERING(&quot;dbjmz2tnii2pn9sxg26ap6w5r&quot;,&quot;ncross&quot;);</span>
try {
    int r, count, nc;
    
<span class="fc" id="L1758">    g = zz.Root;</span>
<span class="fc" id="L1759">    count = 0;</span>
<span class="fc bfc" id="L1760" title="All 2 branches covered.">    for (r = GD_minrank(g); r &lt; GD_maxrank(g); r++) {</span>
<span class="fc bfc" id="L1761" title="All 2 branches covered.">	if (GD_rank(g).get__(r).valid!=0)</span>
<span class="fc" id="L1762">	    count += GD_rank(g).get__(r).cache_nc;</span>
	else {
<span class="fc" id="L1764">	    nc = rcross(zz, g, r);</span>
<span class="fc" id="L1765">	    GD_rank(g).get__(r).cache_nc = nc;</span>
<span class="fc" id="L1766">	    count += nc;</span>
<span class="fc" id="L1767">	    GD_rank(g).get__(r).valid = 1;</span>
	}
    }
<span class="fc" id="L1770">    return count;</span>
} finally {
<span class="fc" id="L1772">LEAVING(&quot;dbjmz2tnii2pn9sxg26ap6w5r&quot;,&quot;ncross&quot;);</span>
}
}




<span class="fc" id="L1779">public static CFunction ordercmpf = new CFunctionAbstract(&quot;ordercmpf&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="fc" id="L1782">		return ordercmpf((Integer)args[0], (Integer)args[1]);</span>
	}};

@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;ordercmpf&quot;, key=&quot;8wrsq8a2vooekcm3cdtv5x3ke&quot;, definition=&quot;static int ordercmpf(int *i0, int *i1)&quot;)
public static int ordercmpf(Integer i0, Integer i1) {
<span class="fc" id="L1788">ENTERING(&quot;8wrsq8a2vooekcm3cdtv5x3ke&quot;,&quot;ordercmpf&quot;);</span>
try {
<span class="fc" id="L1790">    return (i0) - (i1);</span>
} finally {
<span class="fc" id="L1792">LEAVING(&quot;8wrsq8a2vooekcm3cdtv5x3ke&quot;,&quot;ordercmpf&quot;);</span>
}
}




//3 7397kynkpqf2m1jkpmi8pgf0n
// static int flat_mval(node_t * n) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;flat_mval&quot;, key=&quot;7397kynkpqf2m1jkpmi8pgf0n&quot;, definition=&quot;static int flat_mval(node_t * n)&quot;)
public static boolean flat_mval(ST_Agnode_s n) {
<span class="nc" id="L1804">ENTERING(&quot;7397kynkpqf2m1jkpmi8pgf0n&quot;,&quot;flat_mval&quot;);</span>
try {
    int i;
    ST_Agedge_s e;
    CArrayOfStar&lt;ST_Agedge_s&gt; fl;
    ST_Agnode_s nn;
<span class="nc bnc" id="L1810" title="All 2 branches missed.">    if (ND_flat_in(n).size &gt; 0) {</span>
<span class="nc" id="L1811">	fl = ND_flat_in(n).list;</span>
<span class="nc" id="L1812">	nn = agtail(fl.get_(0));</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">	for (i = 1; (e = fl.get_(i))!=null; i++)</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">	    if (ND_order(agtail(e)) &gt; ND_order(nn))</span>
<span class="nc" id="L1815">		nn = agtail(e);</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">	if (ND_mval(nn) &gt;= 0) {</span>
<span class="nc" id="L1817">	    ND_mval(n, ND_mval(nn) + 1);</span>
<span class="nc" id="L1818">	    return false;</span>
	}
<span class="nc bnc" id="L1820" title="All 2 branches missed.">    } else if (ND_flat_out(n).size &gt; 0) {</span>
<span class="nc" id="L1821">	fl = ND_flat_out(n).list;</span>
<span class="nc" id="L1822">	nn = aghead(fl.get_(0));</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">	for (i = 1; (e = fl.get_(i))!=null; i++)</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">	    if (ND_order(aghead(e)) &lt; ND_order(nn))</span>
<span class="nc" id="L1825">		nn = aghead(e);</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">	if (ND_mval(nn) &gt; 0) {</span>
<span class="nc" id="L1827">	    ND_mval(n, ND_mval(nn) - 1);</span>
<span class="nc" id="L1828">	    return false;</span>
	}
    }
<span class="nc" id="L1831">    return true;</span>
} finally {
<span class="nc" id="L1833">LEAVING(&quot;7397kynkpqf2m1jkpmi8pgf0n&quot;,&quot;flat_mval&quot;);</span>
}
}




//3 azvdpixwwxspl31wp7f4k4fmh
// static boolean medians(graph_t * g, int r0, int r1) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;medians&quot;, key=&quot;azvdpixwwxspl31wp7f4k4fmh&quot;, definition=&quot;static boolean medians(graph_t * g, int r0, int r1)&quot;)
public static boolean medians(Globals zz, ST_Agraph_s g, int r0, int r1) {
<span class="fc" id="L1845">ENTERING(&quot;azvdpixwwxspl31wp7f4k4fmh&quot;,&quot;medians&quot;);</span>
try {
    int i, j, j0, lm, rm, lspan, rspan;
    int[] list;
    ST_Agnode_s n;
    CArrayOfStar&lt;ST_Agnode_s&gt; v;
    ST_Agedge_s e;
<span class="fc" id="L1852">    boolean hasfixed = false;</span>
<span class="fc" id="L1853">    list = zz.TI_list;</span>
<span class="fc" id="L1854">    v = GD_rank(g).get__(r0).v;</span>
<span class="fc bfc" id="L1855" title="All 2 branches covered.">    for (i = 0; i &lt; GD_rank(g).get__(r0).n; i++) {</span>
<span class="fc" id="L1856">	n = v.get_(i);</span>
<span class="fc" id="L1857">	j = 0;</span>
<span class="fc bfc" id="L1858" title="All 2 branches covered.">	if (r1 &gt; r0)</span>
<span class="fc bfc" id="L1859" title="All 2 branches covered.">	    for (j0 = 0; (e = ND_out(n).list.get_(j0))!=null; j0++) {</span>
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">		if (ED_xpenalty(e) &gt; 0)</span>
<span class="fc" id="L1861">			list[j++] = ((256 * ND_order(aghead(e)) + (ED_head_port(e)).order));</span>
	} else
<span class="fc bfc" id="L1863" title="All 2 branches covered.">	    for (j0 = 0; (e = ND_in(n).list.get_(j0))!=null; j0++) {</span>
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">		if (ED_xpenalty(e) &gt; 0)</span>
<span class="fc" id="L1865">			list[j++] = ((256 * ND_order(agtail(e)) + (ED_tail_port(e)).order));</span>
	    }
<span class="fc bfc" id="L1867" title="All 4 branches covered.">	switch (j) {</span>
	case 0:
<span class="fc" id="L1869">	    ND_mval(n, -1);</span>
<span class="fc" id="L1870">	    break;</span>
	case 1:
<span class="fc" id="L1872">	    ND_mval(n, list[0]);</span>
<span class="fc" id="L1873">	    break;</span>
	case 2:
<span class="fc" id="L1875">	    ND_mval(n, (list[0] + list[1]) / 2);</span>
<span class="fc" id="L1876">	    break;</span>
	default:
<span class="fc" id="L1878">	    qsortInt(zz, list,</span>
	    	    j,
	    	    mincross__c.ordercmpf);
<span class="fc bfc" id="L1881" title="All 2 branches covered.">	    if (j % 2!=0)</span>
<span class="fc" id="L1882">		ND_mval(n, list[j / 2]);</span>
	    else {
		/* weighted median */
<span class="fc" id="L1885">		rm = j / 2;</span>
<span class="fc" id="L1886">		lm = rm - 1;</span>
<span class="fc" id="L1887">		rspan = list[j - 1] - list[rm];</span>
<span class="fc" id="L1888">		lspan = list[lm] - list[0];</span>
<span class="fc bfc" id="L1889" title="All 2 branches covered.">		if (lspan == rspan)</span>
<span class="fc" id="L1890">		    ND_mval(n, (list[lm] + list[rm]) / 2);</span>
		else {
<span class="fc" id="L1892">		    int w = list[lm] * rspan + list[rm] * lspan;</span>
<span class="fc" id="L1893">		    ND_mval(n, w / (lspan + rspan));</span>
		}
	    }
	}
    }
<span class="fc bfc" id="L1898" title="All 2 branches covered.">    for (i = 0; i &lt; GD_rank(g).get__(r0).n; i++) {</span>
<span class="fc" id="L1899">	n = (ST_Agnode_s) v.get_(i);</span>
<span class="pc bpc" id="L1900" title="1 of 4 branches missed.">	if ((ND_out(n).size == 0) &amp;&amp; (ND_in(n).size == 0))</span>
<span class="nc" id="L1901">	    hasfixed |= flat_mval(n);</span>
    }
<span class="fc" id="L1903">    return hasfixed;</span>
} finally {
<span class="fc" id="L1905">LEAVING(&quot;azvdpixwwxspl31wp7f4k4fmh&quot;,&quot;medians&quot;);</span>
}
}




<span class="fc" id="L1912">public static CFunction nodeposcmpf = new CFunctionAbstract(&quot;nodeposcmpf&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="fc" id="L1915">		return nodeposcmpf((CArrayOfStar&lt;ST_Agnode_s&gt;)args[0], (CArrayOfStar&lt;ST_Agnode_s&gt;)args[1]);</span>
	}};

@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;nodeposcmpf&quot;, key=&quot;2vdhpcykq508ma83aif8sxcbd&quot;, definition=&quot;static int nodeposcmpf(node_t ** n0, node_t ** n1)&quot;)
public static Object nodeposcmpf(CArrayOfStar&lt;ST_Agnode_s&gt; n0, CArrayOfStar&lt;ST_Agnode_s&gt; n1) {
<span class="fc" id="L1921">ENTERING(&quot;2vdhpcykq508ma83aif8sxcbd&quot;,&quot;nodeposcmpf&quot;);</span>
try {
<span class="fc" id="L1923">    return (ND_order(n0.get_(0)) - ND_order(n1.get_(0)));</span>
} finally {
<span class="fc" id="L1925">LEAVING(&quot;2vdhpcykq508ma83aif8sxcbd&quot;,&quot;nodeposcmpf&quot;);</span>
}
}



//1 40as9opn4mzq4gp4nkmp4dj8w
// static int table[3][3] = 
<span class="fc" id="L1933">private static int table[][] = new int[][]{</span>
    /* ordinary */ {1, 1, 1},
    /* singleton */ {1, 2, 2},
    /* virtual */ {1, 2, 4}
};



//3 7j638prioxd97f74v1v4adbsf
// static int endpoint_class(node_t * n) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;endpoint_class&quot;, key=&quot;7j638prioxd97f74v1v4adbsf&quot;, definition=&quot;static int endpoint_class(node_t * n)&quot;)
public static int endpoint_class(ST_Agnode_s n) {
<span class="fc" id="L1946">ENTERING(&quot;7j638prioxd97f74v1v4adbsf&quot;,&quot;endpoint_class&quot;);</span>
try {
<span class="fc bfc" id="L1948" title="All 2 branches covered.">    if (ND_node_type(n) == 1)</span>
<span class="fc" id="L1949">	return 2;</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">    if (ND_weight_class(n) &lt;= 1)</span>
<span class="fc" id="L1951">	return 1;</span>
<span class="fc" id="L1952">    return 0;</span>
} finally {
<span class="fc" id="L1954">LEAVING(&quot;7j638prioxd97f74v1v4adbsf&quot;,&quot;endpoint_class&quot;);</span>
}
}




//3 es57bn7ga4wc9tqtcixpn0451
// void virtual_weight(edge_t * e) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;virtual_weight&quot;, key=&quot;es57bn7ga4wc9tqtcixpn0451&quot;, definition=&quot;void virtual_weight(edge_t * e)&quot;)
public static void virtual_weight(ST_Agedge_s e) {
<span class="fc" id="L1966">ENTERING(&quot;es57bn7ga4wc9tqtcixpn0451&quot;,&quot;virtual_weight&quot;);</span>
try {
    int t;
<span class="fc" id="L1969">    t = table[endpoint_class(agtail(e))][endpoint_class(aghead(e))];</span>
<span class="fc" id="L1970">    ED_weight(e, ED_weight(e) * t);</span>
} finally {
<span class="fc" id="L1972">LEAVING(&quot;es57bn7ga4wc9tqtcixpn0451&quot;,&quot;virtual_weight&quot;);</span>
}
<span class="fc" id="L1974">}</span>




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/mincross.c&quot;, name=&quot;mincross_options&quot;, key=&quot;7ru09oqbudpeofsthzveig2m2&quot;, definition=&quot;static void mincross_options(graph_t * g)&quot;)
public static void mincross_options(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L1982">ENTERING(&quot;7ru09oqbudpeofsthzveig2m2&quot;,&quot;mincross_options&quot;);</span>
try {
    CString p;
    double f;
    
    /* set default values */
<span class="fc" id="L1988">    zz.MinQuit = 8;</span>
<span class="fc" id="L1989">    zz.MaxIter = 24;</span>
<span class="fc" id="L1990">    zz.Convergence = .995;</span>
    
<span class="fc" id="L1992">    p = agget(zz, g, new CString(&quot;mclimit&quot;));</span>
<span class="pc bpc" id="L1993" title="3 of 4 branches missed.">    if (p!=null &amp;&amp; ((f = atof(p)) &gt; 0.0)) {</span>
<span class="nc" id="L1994">UNSUPPORTED(&quot;4iu53eiz077u6joqgwawca8ya&quot;); // 	MinQuit = ((1)&gt;(MinQuit * f)?(1):(MinQuit * f));</span>
<span class="nc" id="L1995">UNSUPPORTED(&quot;38po81l36cibw6jc3qlsscpcu&quot;); // 	MaxIter = ((1)&gt;(MaxIter * f)?(1):(MaxIter * f));</span>
    }   
} finally {
<span class="fc" id="L1998">LEAVING(&quot;7ru09oqbudpeofsthzveig2m2&quot;,&quot;mincross_options&quot;);</span>
}
<span class="fc" id="L2000">}</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>