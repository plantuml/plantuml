<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>fastgr__c.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">gen.lib.dotgen</a> &gt; <span class="el_source">fastgr__c.java</span></div><h1>fastgr__c.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of Smetana.
 * Smetana is a partial translation of Graphviz/Dot sources from C to Java.
 *
 * (C) Copyright 2009-2022, Arnaud Roques
 *
 * This translation is distributed under the same Licence as the original C program:
 * 
 *************************************************************************
 * Copyright (c) 2011 AT&amp;T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 * LICENSE (&quot;AGREEMENT&quot;). [Eclipse Public License - v 1.0]
 * 
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package gen.lib.dotgen;
import static gen.lib.cgraph.edge__c.aghead;
import static gen.lib.cgraph.edge__c.agtail;
import static gen.lib.cgraph.obj__c.agroot;
import static gen.lib.dotgen.dotinit__c.dot_root;
import static smetana.core.Macro.AGINEDGE;
import static smetana.core.Macro.AGNODE;
import static smetana.core.Macro.AGOUTEDGE;
import static smetana.core.Macro.AGSEQ;
import static smetana.core.Macro.AGTYPE;
import static smetana.core.Macro.ED_count;
import static smetana.core.Macro.ED_edge_type;
import static smetana.core.Macro.ED_head_port;
import static smetana.core.Macro.ED_minlen;
import static smetana.core.Macro.ED_tail_port;
import static smetana.core.Macro.ED_to_orig;
import static smetana.core.Macro.ED_to_virt;
import static smetana.core.Macro.ED_weight;
import static smetana.core.Macro.ED_xpenalty;
import static smetana.core.Macro.GD_has_flat_edges;
import static smetana.core.Macro.GD_n_nodes;
import static smetana.core.Macro.GD_nlist;
import static smetana.core.Macro.M_aghead;
import static smetana.core.Macro.M_agtail;
import static smetana.core.Macro.ND_UF_size;
import static smetana.core.Macro.ND_flat_in;
import static smetana.core.Macro.ND_flat_out;
import static smetana.core.Macro.ND_ht;
import static smetana.core.Macro.ND_in;
import static smetana.core.Macro.ND_lw;
import static smetana.core.Macro.ND_next;
import static smetana.core.Macro.ND_node_type;
import static smetana.core.Macro.ND_other;
import static smetana.core.Macro.ND_out;
import static smetana.core.Macro.ND_prev;
import static smetana.core.Macro.ND_rw;
import static smetana.core.Macro.UNSUPPORTED;
import static smetana.core.Macro.UNSURE_ABOUT;
import static smetana.core.Macro.VIRTUAL;
import static smetana.core.Macro.alloc_elist;
import static smetana.core.Macro.elist_append;
import static smetana.core.debug.SmetanaDebug.ENTERING;
import static smetana.core.debug.SmetanaDebug.LEAVING;

import gen.annotation.Difficult;
import gen.annotation.Original;
import gen.annotation.Reviewed;
import gen.annotation.Todo;
import gen.annotation.Unused;
import h.ST_Agedge_s;
import h.ST_Agedgeinfo_t;
import h.ST_Agedgepair_s;
import h.ST_Agnode_s;
import h.ST_Agnodeinfo_t;
import h.ST_Agraph_s;
import h.ST_elist;

<span class="pc" id="L103">public class fastgr__c {</span>


/*
 * operations on the fast internal graph.
 */
@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;econbrl314rr46qnvvw5e32j7&quot;, definition=&quot;static edge_t *ffe(node_t * u, elist uL, node_t * v, elist vL)&quot;)
public static ST_Agedge_s ffe(ST_Agnode_s u, final ST_elist uL, ST_Agnode_s v, final ST_elist vL) {
// WARNING!! STRUCT
<span class="fc" id="L113">return ffe_w_(u, uL.copy(), v, vL.copy());</span>
}
private static ST_Agedge_s ffe_w_(ST_Agnode_s u, final ST_elist uL, ST_Agnode_s v, final ST_elist vL) {
<span class="fc" id="L116">ENTERING(&quot;econbrl314rr46qnvvw5e32j7&quot;,&quot;ffe&quot;);</span>
try {
    int i;
<span class="fc" id="L119">    ST_Agedge_s e = null;</span>
    
<span class="fc bfc" id="L121" title="All 4 branches covered.">    if ((uL.size &gt; 0) &amp;&amp; (vL.size &gt; 0)) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">	if (uL.size &lt; vL.size) {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">	    for (i = 0; (e = (ST_Agedge_s) uL.list.get_(i))!=null; i++)</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">		if (aghead(e) == v)</span>
<span class="nc" id="L125">		    break;</span>
	} else {
<span class="fc bfc" id="L127" title="All 2 branches covered.">	    for (i = 0; (e = (ST_Agedge_s) vL.list.get_(i))!=null; i++)</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">		if (agtail(e) == u)</span>
<span class="fc" id="L129">		    break;</span>
	}
    } else
<span class="fc" id="L132">	e = null;</span>
<span class="fc" id="L133">    return e;</span>
} finally {
<span class="fc" id="L135">LEAVING(&quot;econbrl314rr46qnvvw5e32j7&quot;,&quot;ffe&quot;);</span>
}
}



@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;1uygfrgur73lfy9vsjozwwupm&quot;, definition=&quot;edge_t *find_fast_edge(node_t * u, node_t * v)&quot;)
public static ST_Agedge_s find_fast_edge(ST_Agnode_s u, ST_Agnode_s v) {
<span class="fc" id="L144">ENTERING(&quot;1uygfrgur73lfy9vsjozwwupm&quot;,&quot;find_fast_edge&quot;);</span>
try {
<span class="fc" id="L146">    return ffe(u, ND_out(u), v, ND_in(v));</span>
} finally {
<span class="fc" id="L148">LEAVING(&quot;1uygfrgur73lfy9vsjozwwupm&quot;,&quot;find_fast_edge&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;find_fast_node&quot;, key=&quot;1yw7ahdnxnexnicj552zqyyej&quot;, definition=&quot;static node_t* find_fast_node(graph_t * g, node_t * n)&quot;)
public static ST_Agnode_s find_fast_node(ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L158">ENTERING(&quot;1yw7ahdnxnexnicj552zqyyej&quot;,&quot;find_fast_node&quot;);</span>
try {
    ST_Agnode_s v;
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    for (v = GD_nlist(g); v!=null; v = ND_next(v))</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">	if (v == n)</span>
<span class="fc" id="L163">	    break;</span>
<span class="fc" id="L164">    return v;</span>
} finally {
<span class="fc" id="L166">LEAVING(&quot;1yw7ahdnxnexnicj552zqyyej&quot;,&quot;find_fast_node&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;bf1j97keudu416avridkj9fpb&quot;, definition=&quot;edge_t *find_flat_edge(node_t * u, node_t * v)&quot;)
public static ST_Agedge_s find_flat_edge(ST_Agnode_s u, ST_Agnode_s v) {
<span class="nc" id="L176">ENTERING(&quot;bf1j97keudu416avridkj9fpb&quot;,&quot;find_flat_edge&quot;);</span>
try {
<span class="nc" id="L178">    return ffe(u, ND_flat_out(u), v, ND_flat_in(v));</span>
} finally {
<span class="nc" id="L180">LEAVING(&quot;bf1j97keudu416avridkj9fpb&quot;,&quot;find_flat_edge&quot;);</span>
}
}



@Todo(what = &quot;Strange that elist_append(e, (*L)) is never called&quot;)
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;safe_list_append&quot;, key=&quot;cttswsffgmw1g710jzvdd3wzn&quot;, definition=&quot;static void  safe_list_append(edge_t * e, elist * L)&quot;)
public static void safe_list_append(ST_Agedge_s e, ST_elist L) {
<span class="nc" id="L190">ENTERING(&quot;cttswsffgmw1g710jzvdd3wzn&quot;,&quot;safe_list_append&quot;);</span>
try {
     int i;
     
<span class="nc bnc" id="L194" title="All 2 branches missed.">     for (i = 0; i &lt; L.size; i++)</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">     if (e == L.list.get_(i))</span>
<span class="nc" id="L196"> 	 	return;</span>
<span class="nc" id="L197">     elist_append(e, L);</span>
} finally {
<span class="nc" id="L199">LEAVING(&quot;cttswsffgmw1g710jzvdd3wzn&quot;,&quot;safe_list_append&quot;);</span>
}
<span class="nc" id="L201">}</span>




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;8t6gpubo908pz1pqnt1s88lnt&quot;, definition=&quot;edge_t *fast_edge(edge_t * e)&quot;)
public static ST_Agedge_s fast_edge(ST_Agedge_s e) {
<span class="fc" id="L209">ENTERING(&quot;8t6gpubo908pz1pqnt1s88lnt&quot;,&quot;fast_edge&quot;);</span>
try {
<span class="fc" id="L211">    elist_append(e, ND_out(agtail(e)));</span>
<span class="fc" id="L212">    elist_append(e, ND_in(aghead(e)));</span>
<span class="fc" id="L213">    return e;</span>
} finally {
<span class="fc" id="L215">LEAVING(&quot;8t6gpubo908pz1pqnt1s88lnt&quot;,&quot;fast_edge&quot;);</span>
}
}




//3 dxb0q8ajb7iv25aj6zdqnbwh5
// void zapinlist(elist * L, edge_t * e) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;zapinlist&quot;, key=&quot;dxb0q8ajb7iv25aj6zdqnbwh5&quot;, definition=&quot;void zapinlist(elist * L, edge_t * e)&quot;)
public static void zapinlist(ST_elist L, ST_Agedge_s e) {
<span class="fc" id="L227">ENTERING(&quot;dxb0q8ajb7iv25aj6zdqnbwh5&quot;,&quot;zapinlist&quot;);</span>
try {
    int i;
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    for (i = 0; i &lt; L.size; i++) {</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">	if (L.list.get_(i) == e) {</span>
<span class="fc" id="L232">	    L.size = L.size-1;</span>
<span class="fc" id="L233">	    L.list.set_(i, L.list.get_(L.size));</span>
<span class="fc" id="L234">	    L.list.set_(L.size, null);</span>
<span class="fc" id="L235">	    break;</span>
	}
    }
} finally {
<span class="fc" id="L239">LEAVING(&quot;dxb0q8ajb7iv25aj6zdqnbwh5&quot;,&quot;zapinlist&quot;);</span>
}
<span class="fc" id="L241">}</span>




//3 dkv97rr4ytpehp291etaxe9gc
// void delete_fast_edge(edge_t * e) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;delete_fast_edge&quot;, key=&quot;dkv97rr4ytpehp291etaxe9gc&quot;, definition=&quot;void delete_fast_edge(edge_t * e)&quot;)
public static void delete_fast_edge(ST_Agedge_s e) {
<span class="fc" id="L251">ENTERING(&quot;dkv97rr4ytpehp291etaxe9gc&quot;,&quot;delete_fast_edge&quot;);</span>
try {
    //assert(e != NULL);
<span class="fc" id="L254">    zapinlist((ND_out(agtail(e))), e);</span>
<span class="fc" id="L255">    zapinlist((ND_in(aghead(e))), e);</span>
} finally {
<span class="fc" id="L257">LEAVING(&quot;dkv97rr4ytpehp291etaxe9gc&quot;,&quot;delete_fast_edge&quot;);</span>
}
<span class="fc" id="L259">}</span>





@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;other_edge&quot;, key=&quot;73oebfcfiescklohgt8mddswc&quot;, definition=&quot;void other_edge(edge_t * e)&quot;)
public static void other_edge(ST_Agedge_s e) {
<span class="fc" id="L268">ENTERING(&quot;73oebfcfiescklohgt8mddswc&quot;,&quot;other_edge&quot;);</span>
try {
<span class="fc" id="L270">    elist_append(e, ND_other(agtail(e)));</span>
} finally {
<span class="fc" id="L272">LEAVING(&quot;73oebfcfiescklohgt8mddswc&quot;,&quot;other_edge&quot;);</span>
}
<span class="fc" id="L274">}</span>




@Difficult
@Reviewed(when = &quot;15/11/2020&quot;)
@Todo(what = &quot;Review &amp;(ND_other(agtail(e))&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;safe_other_edge&quot;, key=&quot;4zg1fp1b7bhnx2tbeaij8yeel&quot;, definition=&quot;void safe_other_edge(edge_t * e)&quot;)
public static void safe_other_edge(ST_Agedge_s e) {
<span class="nc" id="L284">ENTERING(&quot;4zg1fp1b7bhnx2tbeaij8yeel&quot;,&quot;safe_other_edge&quot;);</span>
try {
<span class="nc" id="L286">	UNSURE_ABOUT(&quot;safe_list_append(e, &amp;(ND_other(agtail(e))));&quot;);</span>
	// Review &amp;(ND_other(agtail(e))
<span class="nc" id="L288">    safe_list_append(e, ND_other(agtail(e)));	</span>
} finally {
<span class="nc" id="L290">LEAVING(&quot;4zg1fp1b7bhnx2tbeaij8yeel&quot;,&quot;safe_other_edge&quot;);</span>
}
<span class="nc" id="L292">}</span>



/* new_virtual_edge:
 * Create and return a new virtual edge e attached to orig.
 * ED_to_orig(e) = orig
 * ED_to_virt(orig) = e if e is the first virtual edge attached.
 * orig might be an input edge, reverse of an input edge, or virtual edge
 */
@Reviewed(when = &quot;14/11/2020&quot;)
@Difficult
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;4gd9tmpq70q0rij5otj0k6sn2&quot;, definition=&quot;edge_t *new_virtual_edge(node_t * u, node_t * v, edge_t * orig)&quot;)
public static ST_Agedge_s new_virtual_edge(ST_Agnode_s u, ST_Agnode_s v, ST_Agedge_s orig) {
<span class="fc" id="L306">ENTERING(&quot;4gd9tmpq70q0rij5otj0k6sn2&quot;,&quot;new_virtual_edge&quot;);</span>
try {
    ST_Agedge_s e;
    
<span class="fc" id="L310">    ST_Agedgepair_s e2 = new ST_Agedgepair_s();</span>
<span class="fc" id="L311">    AGTYPE(e2.in, AGINEDGE);</span>
<span class="fc" id="L312">    AGTYPE(e2.out, AGOUTEDGE);</span>
<span class="fc" id="L313">    e2.out.base.data = new ST_Agedgeinfo_t();</span>
<span class="fc" id="L314">    e = e2.out;</span>
<span class="fc" id="L315">    M_agtail(e, u);</span>
<span class="fc" id="L316">    M_aghead(e, v);</span>
<span class="fc" id="L317">    ED_edge_type(e, VIRTUAL);</span>
    
    
<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (orig!=null) {</span>
<span class="fc" id="L321">	AGSEQ(e, orig.tag.seq);</span>
<span class="fc" id="L322">	AGSEQ(e2.in, orig.tag.seq);</span>
<span class="fc" id="L323">	ED_count(e, ED_count(orig));</span>
<span class="fc" id="L324">	ED_xpenalty(e, ED_xpenalty(orig));</span>
<span class="fc" id="L325">	ED_weight(e, ED_weight(orig));</span>
<span class="fc" id="L326">	ED_minlen(e, ED_minlen(orig));</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">	if (agtail(e) == agtail(orig))</span>
<span class="fc" id="L328">	    ED_tail_port(e, ED_tail_port(orig));</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">	else if (agtail(e) == aghead(orig))</span>
<span class="nc" id="L330">	    ED_tail_port(e, ED_head_port(orig));</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">	if (aghead(e) == aghead(orig))</span>
<span class="fc" id="L332">	    ED_head_port(e, ED_head_port(orig));</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">	else if (aghead(e) == agtail(orig))</span>
<span class="nc" id="L334">	    ED_head_port(e, ED_tail_port(orig));</span>
	
	
<span class="fc bfc" id="L337" title="All 2 branches covered.">	if (ED_to_virt(orig) == null)</span>
<span class="fc" id="L338">	    ED_to_virt(orig, e);</span>
<span class="fc" id="L339">	ED_to_orig(e, orig);</span>
    } else {
<span class="fc" id="L341">	ED_minlen(e, 1);</span>
<span class="fc" id="L342">	ED_count(e, 1);</span>
<span class="fc" id="L343">	ED_xpenalty(e, 1);</span>
<span class="fc" id="L344">	ED_weight(e, 1);</span>
	}
<span class="fc" id="L346">    return e;</span>
} finally {
<span class="fc" id="L348">LEAVING(&quot;4gd9tmpq70q0rij5otj0k6sn2&quot;,&quot;new_virtual_edge&quot;);</span>
}
}




@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;9obdfflzw4cs2z9r0dng26mvw&quot;, definition=&quot;edge_t *virtual_edge(node_t * u, node_t * v, edge_t * orig)&quot;)
public static ST_Agedge_s virtual_edge(ST_Agnode_s u, ST_Agnode_s v, ST_Agedge_s orig) {
<span class="fc" id="L358">ENTERING(&quot;9obdfflzw4cs2z9r0dng26mvw&quot;,&quot;virtual_edge&quot;);</span>
try {
<span class="fc" id="L360">    return fast_edge(new_virtual_edge(u, v, orig));</span>
} finally {
<span class="fc" id="L362">LEAVING(&quot;9obdfflzw4cs2z9r0dng26mvw&quot;,&quot;virtual_edge&quot;);</span>
}
}




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;fast_node&quot;, key=&quot;98hkec8t6fjk10bjpstumw0ey&quot;, definition=&quot;void fast_node(graph_t * g, Agnode_t * n)&quot;)
public static void fast_node(ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L372">ENTERING(&quot;98hkec8t6fjk10bjpstumw0ey&quot;,&quot;fast_node&quot;);</span>
try {
<span class="fc" id="L374">    ND_next(n, GD_nlist(g));</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">    if (ND_next(n)!=null)</span>
<span class="fc" id="L376">	ND_prev(ND_next(n), n);</span>
<span class="fc" id="L377">    GD_nlist(g, n);</span>
<span class="fc" id="L378">    ND_prev(n, null);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">    assert((n != ND_next(n)));</span>
} finally {
<span class="fc" id="L381">LEAVING(&quot;98hkec8t6fjk10bjpstumw0ey&quot;,&quot;fast_node&quot;);</span>
}
<span class="fc" id="L383">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;delete_fast_node&quot;, key=&quot;emsq7b6s5100lscckzy3ileqd&quot;, definition=&quot;void delete_fast_node(graph_t * g, node_t * n)&quot;)
public static void delete_fast_node(ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L391">ENTERING(&quot;emsq7b6s5100lscckzy3ileqd&quot;,&quot;delete_fast_node&quot;);</span>
try {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">    assert(find_fast_node(g, n)!=null);</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">    if (ND_next(n)!=null)</span>
<span class="fc" id="L395">	ND_prev(ND_next(n), ND_prev(n));</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (ND_prev(n)!=null)</span>
<span class="fc" id="L397">	ND_next(ND_prev(n), ND_next(n));</span>
    else
<span class="fc" id="L399">	GD_nlist(g, ND_next(n));</span>
} finally {
<span class="fc" id="L401">LEAVING(&quot;emsq7b6s5100lscckzy3ileqd&quot;,&quot;delete_fast_node&quot;);</span>
}
<span class="fc" id="L403">}</span>




@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;&quot;, key=&quot;eg08ajzojsm0224btmfi7kdxt&quot;, definition=&quot;node_t *virtual_node(graph_t * g)&quot;)
public static ST_Agnode_s virtual_node(ST_Agraph_s g) {
<span class="fc" id="L411">ENTERING(&quot;eg08ajzojsm0224btmfi7kdxt&quot;,&quot;virtual_node&quot;);</span>
try {
	ST_Agnode_s n;
	
<span class="fc" id="L415">    n = new ST_Agnode_s();</span>
//  agnameof(n) = &quot;virtual&quot;;
<span class="fc" id="L417">    AGTYPE(n, AGNODE);</span>
<span class="fc" id="L418">    n.base.data = new ST_Agnodeinfo_t();</span>
<span class="fc" id="L419">    n.root = agroot(g);</span>
<span class="fc" id="L420">    ND_node_type(n, VIRTUAL);</span>
<span class="fc" id="L421">    ND_rw(n, 1); ND_lw(n, 1);</span>
<span class="fc" id="L422">    ND_ht(n, 1);</span>
<span class="fc" id="L423">    ND_UF_size(n, 1);</span>
<span class="fc" id="L424">    alloc_elist(4, ND_in(n));</span>
<span class="fc" id="L425">    alloc_elist(4, ND_out(n));</span>
<span class="fc" id="L426">    fast_node(g, n);</span>
<span class="fc" id="L427">    GD_n_nodes(g, GD_n_nodes(g)+1);</span>
<span class="fc" id="L428">    return n;</span>
} finally {
<span class="fc" id="L430">LEAVING(&quot;eg08ajzojsm0224btmfi7kdxt&quot;,&quot;virtual_node&quot;);</span>
}
}




@Difficult
@Reviewed(when = &quot;15/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;flat_edge&quot;, key=&quot;8dvukicq96g5t3xgdl0ue35mj&quot;, definition=&quot;void flat_edge(graph_t * g, edge_t * e)&quot;)
public static void flat_edge(ST_Agraph_s g, ST_Agedge_s e) {
<span class="fc" id="L441">ENTERING(&quot;8dvukicq96g5t3xgdl0ue35mj&quot;,&quot;flat_edge&quot;);</span>
try {
<span class="fc" id="L443">    elist_append(e, ND_flat_out(agtail(e)));</span>
<span class="fc" id="L444">    elist_append(e, ND_flat_in(aghead(e)));</span>
<span class="fc" id="L445">    GD_has_flat_edges(g, true);</span>
<span class="fc" id="L446">    GD_has_flat_edges(dot_root(g), true);</span>
} finally {
<span class="fc" id="L448">LEAVING(&quot;8dvukicq96g5t3xgdl0ue35mj&quot;,&quot;flat_edge&quot;);</span>
}
<span class="fc" id="L450">}</span>




//3 clspalhiuedfnk9g9rlvfqpg7
// void delete_flat_edge(edge_t * e) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;delete_flat_edge&quot;, key=&quot;clspalhiuedfnk9g9rlvfqpg7&quot;, definition=&quot;void delete_flat_edge(edge_t * e)&quot;)
public static void delete_flat_edge(ST_Agedge_s e) {
<span class="nc" id="L460">ENTERING(&quot;clspalhiuedfnk9g9rlvfqpg7&quot;,&quot;delete_flat_edge&quot;);</span>
try {
<span class="nc bnc" id="L462" title="All 2 branches missed.">    assert(e != null);</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">    if (ED_to_orig(e)!=null &amp;&amp; ED_to_virt(ED_to_orig(e)) == e)</span>
<span class="nc" id="L464">	ED_to_virt(ED_to_orig(e), null);</span>
<span class="nc" id="L465">    zapinlist((ND_flat_out(agtail(e))), e);</span>
<span class="nc" id="L466">    zapinlist((ND_flat_in(aghead(e))), e);</span>
} finally {
<span class="nc" id="L468">LEAVING(&quot;clspalhiuedfnk9g9rlvfqpg7&quot;,&quot;delete_flat_edge&quot;);</span>
}
<span class="nc" id="L470">}</span>




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;basic_merge&quot;, key=&quot;dcfpol11cvlt6aaa6phqbp6fo&quot;, definition=&quot;static void  basic_merge(edge_t * e, edge_t * rep)&quot;)
public static void basic_merge(ST_Agedge_s e, ST_Agedge_s rep) {
<span class="fc" id="L478">ENTERING(&quot;dcfpol11cvlt6aaa6phqbp6fo&quot;,&quot;basic_merge&quot;);</span>
try {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">    if (ED_minlen(rep) &lt; ED_minlen(e))</span>
<span class="nc" id="L481">	ED_minlen(rep, ED_minlen(e));</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">    while (rep!=null) {</span>
<span class="fc" id="L483">	ED_count(rep, ED_count(rep) + ED_count(e));</span>
<span class="fc" id="L484">	ED_xpenalty(rep, ED_xpenalty(rep) + ED_xpenalty(e));</span>
<span class="fc" id="L485">	ED_weight(rep, ED_weight(rep) + ED_weight(e));</span>
<span class="fc" id="L486">	rep = ED_to_virt(rep);</span>
    }
} finally {
<span class="fc" id="L489">LEAVING(&quot;dcfpol11cvlt6aaa6phqbp6fo&quot;,&quot;basic_merge&quot;);</span>
}
<span class="fc" id="L491">}</span>




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/dotgen/fastgr.c&quot;, name=&quot;merge_oneway&quot;, key=&quot;6dxgtoii76tmonlnvz4rmiytd&quot;, definition=&quot;void  merge_oneway(edge_t * e, edge_t * rep)&quot;)
public static void merge_oneway(ST_Agedge_s e, ST_Agedge_s rep) {
<span class="fc" id="L499">ENTERING(&quot;6dxgtoii76tmonlnvz4rmiytd&quot;,&quot;merge_oneway&quot;);</span>
try {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">    if (rep == ED_to_virt(e)) {</span>
<span class="nc" id="L502">UNSUPPORTED(&quot;84xxsh1cgsif42hgizyxw36ul&quot;); // 	agerr(AGWARN, &quot;merge_oneway glitch\n&quot;);</span>
<span class="nc" id="L503">UNSUPPORTED(&quot;a7fgam0j0jm7bar0mblsv3no4&quot;); // 	return;</span>
    }
    //assert(ED_to_virt(e) == NULL);
<span class="fc" id="L506">    ED_to_virt(e, rep);</span>
<span class="fc" id="L507">    basic_merge(e, rep);</span>
} finally {
<span class="fc" id="L509">LEAVING(&quot;6dxgtoii76tmonlnvz4rmiytd&quot;,&quot;merge_oneway&quot;);</span>
}
<span class="fc" id="L511">}</span>




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>