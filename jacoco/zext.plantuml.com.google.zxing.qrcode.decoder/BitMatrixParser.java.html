<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BitMatrixParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">zext.plantuml.com.google.zxing.qrcode.decoder</a> &gt; <span class="el_source">BitMatrixParser.java</span></div><h1>BitMatrixParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package zext.plantuml.com.google.zxing.qrcode.decoder;

import zext.plantuml.com.google.zxing.FormatException;
import zext.plantuml.com.google.zxing.common.BitMatrix;

/**
 * @author Sean Owen
 */
final class BitMatrixParser {

  private final BitMatrix bitMatrix;
  private Version parsedVersion;
  private FormatInformation parsedFormatInfo;

  /**
   * @param bitMatrix {@link BitMatrix} to parse
   * @throws FormatException if dimension is not &gt;= 21 and 1 mod 4
   */
<span class="nc" id="L35">  BitMatrixParser(BitMatrix bitMatrix) throws FormatException {</span>
<span class="nc" id="L36">    int dimension = bitMatrix.getHeight();</span>
<span class="nc bnc" id="L37" title="All 4 branches missed.">    if (dimension &lt; 21 || (dimension &amp; 0x03) != 1) {</span>
<span class="nc" id="L38">      throw FormatException.getFormatInstance();</span>
    }
<span class="nc" id="L40">    this.bitMatrix = bitMatrix;</span>
<span class="nc" id="L41">  }</span>

  /**
   * &lt;p&gt;Reads format information from one of its two locations within the QR Code.&lt;/p&gt;
   *
   * @return {@link FormatInformation} encapsulating the QR Code's format info
   * @throws FormatException if both format information locations cannot be parsed as
   * the valid encoding of format information
   */
  FormatInformation readFormatInformation() throws FormatException {

<span class="nc bnc" id="L52" title="All 2 branches missed.">    if (parsedFormatInfo != null) {</span>
<span class="nc" id="L53">      return parsedFormatInfo;</span>
    }

    // Read top-left format info bits
<span class="nc" id="L57">    int formatInfoBits1 = 0;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">    for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc" id="L59">      formatInfoBits1 = copyBit(i, 8, formatInfoBits1);</span>
    }
    // .. and skip a bit in the timing pattern ...
<span class="nc" id="L62">    formatInfoBits1 = copyBit(7, 8, formatInfoBits1);</span>
<span class="nc" id="L63">    formatInfoBits1 = copyBit(8, 8, formatInfoBits1);</span>
<span class="nc" id="L64">    formatInfoBits1 = copyBit(8, 7, formatInfoBits1);</span>
    // .. and skip a bit in the timing pattern ...
<span class="nc bnc" id="L66" title="All 2 branches missed.">    for (int j = 5; j &gt;= 0; j--) {</span>
<span class="nc" id="L67">      formatInfoBits1 = copyBit(8, j, formatInfoBits1);</span>
    }

    // Read the top-right/bottom-left pattern too
<span class="nc" id="L71">    int dimension = bitMatrix.getHeight();</span>
<span class="nc" id="L72">    int formatInfoBits2 = 0;</span>
<span class="nc" id="L73">    int iMin = dimension - 8;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">    for (int i = dimension - 1; i &gt;= iMin; i--) {</span>
<span class="nc" id="L75">      formatInfoBits2 = copyBit(i, 8, formatInfoBits2);</span>
    }
<span class="nc bnc" id="L77" title="All 2 branches missed.">    for (int j = dimension - 7; j &lt; dimension; j++) {</span>
<span class="nc" id="L78">      formatInfoBits2 = copyBit(8, j, formatInfoBits2);</span>
    }

<span class="nc" id="L81">    parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">    if (parsedFormatInfo != null) {</span>
<span class="nc" id="L83">      return parsedFormatInfo;</span>
    }
<span class="nc" id="L85">    throw FormatException.getFormatInstance();</span>
  }

  /**
   * &lt;p&gt;Reads version information from one of its two locations within the QR Code.&lt;/p&gt;
   *
   * @return {@link Version} encapsulating the QR Code's version
   * @throws FormatException if both version information locations cannot be parsed as
   * the valid encoding of version information
   */
  Version readVersion() throws FormatException {

<span class="nc bnc" id="L97" title="All 2 branches missed.">    if (parsedVersion != null) {</span>
<span class="nc" id="L98">      return parsedVersion;</span>
    }

<span class="nc" id="L101">    int dimension = bitMatrix.getHeight();</span>

<span class="nc" id="L103">    int provisionalVersion = (dimension - 17) &gt;&gt; 2;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">    if (provisionalVersion &lt;= 6) {</span>
<span class="nc" id="L105">      return Version.getVersionForNumber(provisionalVersion);</span>
    }

    // Read top-right version info: 3 wide by 6 tall
<span class="nc" id="L109">    int versionBits = 0;</span>
<span class="nc" id="L110">    int ijMin = dimension - 11;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">    for (int j = 5; j &gt;= 0; j--) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">      for (int i = dimension - 9; i &gt;= ijMin; i--) {</span>
<span class="nc" id="L113">        versionBits = copyBit(i, j, versionBits);</span>
      }
    }

<span class="nc" id="L117">    parsedVersion = Version.decodeVersionInformation(versionBits);</span>
<span class="nc bnc" id="L118" title="All 4 branches missed.">    if (parsedVersion != null &amp;&amp; parsedVersion.getDimensionForVersion() == dimension) {</span>
<span class="nc" id="L119">      return parsedVersion;</span>
    }

    // Hmm, failed. Try bottom left: 6 wide by 3 tall
<span class="nc" id="L123">    versionBits = 0;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">    for (int i = 5; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">      for (int j = dimension - 9; j &gt;= ijMin; j--) {</span>
<span class="nc" id="L126">        versionBits = copyBit(i, j, versionBits);</span>
      }
    }

<span class="nc" id="L130">    parsedVersion = Version.decodeVersionInformation(versionBits);</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">    if (parsedVersion != null &amp;&amp; parsedVersion.getDimensionForVersion() == dimension) {</span>
<span class="nc" id="L132">      return parsedVersion;</span>
    }
<span class="nc" id="L134">    throw FormatException.getFormatInstance();</span>
  }

  private int copyBit(int i, int j, int versionBits) {
<span class="nc bnc" id="L138" title="All 2 branches missed.">    return bitMatrix.get(i, j) ? (versionBits &lt;&lt; 1) | 0x1 : versionBits &lt;&lt; 1;</span>
  }

  /**
   * &lt;p&gt;Reads the bits in the {@link BitMatrix} representing the finder pattern in the
   * correct order in order to reconstitute the codewords bytes contained within the
   * QR Code.&lt;/p&gt;
   *
   * @return bytes encoded within the QR Code
   * @throws FormatException if the exact number of bytes expected is not read
   */
  byte[] readCodewords() throws FormatException {

<span class="nc" id="L151">    FormatInformation formatInfo = readFormatInformation();</span>
<span class="nc" id="L152">    Version version = readVersion();</span>

    // Get the data mask for the format used in this QR Code. This will exclude
    // some bits from reading as we wind through the bit matrix.
<span class="nc" id="L156">    DataMask dataMask = DataMask.forReference((int) formatInfo.getDataMask());</span>
<span class="nc" id="L157">    int dimension = bitMatrix.getHeight();</span>
<span class="nc" id="L158">    dataMask.unmaskBitMatrix(bitMatrix, dimension);</span>

<span class="nc" id="L160">    BitMatrix functionPattern = version.buildFunctionPattern();</span>

<span class="nc" id="L162">    boolean readingUp = true;</span>
<span class="nc" id="L163">    byte[] result = new byte[version.getTotalCodewords()];</span>
<span class="nc" id="L164">    int resultOffset = 0;</span>
<span class="nc" id="L165">    int currentByte = 0;</span>
<span class="nc" id="L166">    int bitsRead = 0;</span>
    // Read columns in pairs, from right to left
<span class="nc bnc" id="L168" title="All 2 branches missed.">    for (int j = dimension - 1; j &gt; 0; j -= 2) {</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">      if (j == 6) {</span>
        // Skip whole column with vertical alignment pattern;
        // saves time and makes the other code proceed more cleanly
<span class="nc" id="L172">        j--;</span>
      }
      // Read alternatingly from bottom to top then top to bottom
<span class="nc bnc" id="L175" title="All 2 branches missed.">      for (int count = 0; count &lt; dimension; count++) {</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        int i = readingUp ? dimension - 1 - count : count;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (int col = 0; col &lt; 2; col++) {</span>
          // Ignore bits covered by the function pattern
<span class="nc bnc" id="L179" title="All 2 branches missed.">          if (!functionPattern.get(j - col, i)) {</span>
            // Read a bit
<span class="nc" id="L181">            bitsRead++;</span>
<span class="nc" id="L182">            currentByte &lt;&lt;= 1;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">            if (bitMatrix.get(j - col, i)) {</span>
<span class="nc" id="L184">              currentByte |= 1;</span>
            }
            // If we've made a whole byte, save it off
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (bitsRead == 8) {</span>
<span class="nc" id="L188">              result[resultOffset++] = (byte) currentByte;</span>
<span class="nc" id="L189">              bitsRead = 0;</span>
<span class="nc" id="L190">              currentByte = 0;</span>
            }
          }
        }
      }
<span class="nc" id="L195">      readingUp ^= true; // readingUp = !readingUp; // switch directions</span>
    }
<span class="nc bnc" id="L197" title="All 2 branches missed.">    if (resultOffset != version.getTotalCodewords()) {</span>
<span class="nc" id="L198">      throw FormatException.getFormatInstance();</span>
    }
<span class="nc" id="L200">    return result;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>