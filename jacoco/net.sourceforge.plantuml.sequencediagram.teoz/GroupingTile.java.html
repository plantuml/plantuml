<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupingTile.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">net.sourceforge.plantuml.sequencediagram.teoz</a> &gt; <span class="el_source">GroupingTile.java</span></div><h1>GroupingTile.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * (C) Copyright 2009-2024, Arnaud Roques
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of PlantUML.
 *
 * PlantUML is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PlantUML distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
 * License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 *
 * Original Author:  Arnaud Roques
 * 
 *
 */
package net.sourceforge.plantuml.sequencediagram.teoz;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import net.sourceforge.plantuml.klimt.UTranslate;
import net.sourceforge.plantuml.klimt.color.HColor;
import net.sourceforge.plantuml.klimt.creole.Display;
import net.sourceforge.plantuml.klimt.drawing.UGraphic;
import net.sourceforge.plantuml.klimt.font.StringBounder;
import net.sourceforge.plantuml.klimt.geom.XDimension2D;
import net.sourceforge.plantuml.klimt.shape.UDrawable;
import net.sourceforge.plantuml.real.Real;
import net.sourceforge.plantuml.real.RealUtils;
import net.sourceforge.plantuml.sequencediagram.Event;
import net.sourceforge.plantuml.sequencediagram.Grouping;
import net.sourceforge.plantuml.sequencediagram.GroupingLeaf;
import net.sourceforge.plantuml.sequencediagram.GroupingStart;
import net.sourceforge.plantuml.sequencediagram.GroupingType;
import net.sourceforge.plantuml.skin.Area;
import net.sourceforge.plantuml.skin.Component;
import net.sourceforge.plantuml.skin.ComponentType;
import net.sourceforge.plantuml.skin.Context2D;
import net.sourceforge.plantuml.skin.rose.Rose;
import net.sourceforge.plantuml.style.ISkinParam;
import net.sourceforge.plantuml.style.PName;
import net.sourceforge.plantuml.style.Style;

public class GroupingTile extends AbstractTile {

	public static final int EXTERNAL_MARGINX1 = 3;
	public static final int EXTERNAL_MARGINX2 = 9;
	private static final int MARGINX = 16;
	// private static final int MARGINY = 10;
	private static final int MARGINY_MAGIC = 20;
<span class="fc" id="L73">	private List&lt;Tile&gt; tiles = new ArrayList&lt;&gt;();</span>
	private final Real min;
	private final Real max;
	private final GroupingStart start;
	private final YGauge yGauge;

	private final Rose skin;
	private final ISkinParam skinParam;
	private final Display display;

	private double bodyHeight;

	public Event getEvent() {
<span class="fc" id="L86">		return start;</span>
	}

	@Override
	public double getContactPointRelative() {
<span class="fc" id="L91">		return 0;</span>
	}

	@Override
	public YGauge getYGauge() {
<span class="nc" id="L96">		return yGauge;</span>
	}

	public GroupingTile(Iterator&lt;Event&gt; it, GroupingStart start, TileArguments tileArgumentsBackColorChanged,
			TileArguments tileArgumentsOriginal, YGauge currentY) {
<span class="fc" id="L101">		super(tileArgumentsBackColorChanged.getStringBounder(), currentY);</span>
<span class="fc" id="L102">		final Real firstY = currentY.getMax();</span>
<span class="fc" id="L103">		final StringBounder stringBounder = tileArgumentsOriginal.getStringBounder();</span>
<span class="fc" id="L104">		this.start = start;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">		this.display = start.getTitle().equals(&quot;group&quot;) ? Display.create(start.getComment())</span>
<span class="fc" id="L106">				: Display.create(start.getTitle(), start.getComment());</span>
<span class="fc" id="L107">		this.skin = tileArgumentsOriginal.getSkin();</span>
		// this.skinParam = tileArgumentsOriginal.getSkinParam();
<span class="fc" id="L109">		this.skinParam = tileArgumentsBackColorChanged.getSkinParam();</span>

<span class="fc" id="L111">		final List&lt;Real&gt; min2 = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L112">		final List&lt;Real&gt; max2 = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L114">		final List&lt;Tile&gt; allElses = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L115">		final XDimension2D dim1 = getPreferredDimensionIfEmpty(stringBounder);</span>

<span class="fc" id="L117">		final double h = dim1.getHeight() + MARGINY_MAGIC / 2;</span>
<span class="fc" id="L118">		currentY = YGauge.create(currentY.getMax().addAtLeast(h), 0);</span>

<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		while (it.hasNext()) {</span>
<span class="fc" id="L121">			final Event ev = it.next();</span>
<span class="fc bfc" id="L122" title="All 4 branches covered.">			if (ev instanceof GroupingLeaf &amp;&amp; ((Grouping) ev).getType() == GroupingType.END)</span>
<span class="fc" id="L123">				break;</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">			for (Tile tile : TileBuilder.buildOne(it, tileArgumentsOriginal, ev, this, currentY)) {</span>
<span class="fc" id="L126">				tiles.add(tile);</span>
				if (YGauge.USE_ME)
					currentY = tile.getYGauge();
<span class="fc" id="L129">			}</span>

<span class="fc" id="L131">		}</span>

<span class="fc" id="L133">		tiles = mergeParallel(getStringBounder(), tiles);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="fc" id="L136">			bodyHeight += tile.getPreferredHeight();</span>
<span class="fc" id="L137">			final Event ev = tile.getEvent();</span>
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">			if (ev instanceof GroupingLeaf &amp;&amp; ((Grouping) ev).getType() == GroupingType.ELSE) {</span>
<span class="fc" id="L139">				allElses.add(tile);</span>
<span class="fc" id="L140">				continue;</span>
			}
<span class="fc" id="L142">			min2.add(tile.getMinX().addFixed(-MARGINX));</span>
<span class="fc" id="L143">			final Real m = tile.getMaxX();</span>
			// max2.add(m == tileArgumentsOriginal.getOmega() ? m : m.addFixed(MARGINX));
<span class="fc" id="L145">			max2.add(m.addFixed(MARGINX));</span>
<span class="fc" id="L146">		}</span>
<span class="fc" id="L147">		final double width = dim1.getWidth();</span>
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (min2.size() == 0)</span>
<span class="nc" id="L149">			min2.add(tileArgumentsOriginal.getXOrigin());</span>

<span class="fc" id="L151">		this.min = RealUtils.min(min2);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">		for (Tile anElse : allElses)</span>
<span class="fc" id="L153">			max2.add(anElse.getMaxX());</span>

<span class="fc" id="L155">		max2.add(this.min.addFixed(width + 16));</span>
<span class="fc" id="L156">		this.max = RealUtils.max(max2);</span>
<span class="fc" id="L157">		this.yGauge = YGauge.create(firstY, getPreferredHeight());</span>

<span class="fc" id="L159">	}</span>

	private Component getComponent(StringBounder stringBounder) {
<span class="fc" id="L162">		final Component comp = skin.createComponent(start.getUsedStyles(), ComponentType.GROUPING_HEADER_TEOZ, null,</span>
				skinParam, display);
<span class="fc" id="L164">		return comp;</span>
	}

	private XDimension2D getPreferredDimensionIfEmpty(StringBounder stringBounder) {
<span class="fc" id="L168">		return getComponent(stringBounder).getPreferredDimension(stringBounder);</span>
	}

	public void drawU(UGraphic ug) {
<span class="fc" id="L172">		final StringBounder stringBounder = ug.getStringBounder();</span>

<span class="fc" id="L174">		final Area area = Area.create(max.getCurrentValue() - min.getCurrentValue(), getTotalHeight(stringBounder));</span>

<span class="fc" id="L176">		final Component comp = getComponent(stringBounder);</span>
<span class="fc" id="L177">		final XDimension2D dim1 = getPreferredDimensionIfEmpty(stringBounder);</span>

		if (YGauge.USE_ME) {
			comp.drawU(ug.apply(new UTranslate(min.getCurrentValue(), getYGauge().getMin().getCurrentValue())), area,
					(Context2D) ug);
		} else {
<span class="fc bfc" id="L183" title="All 2 branches covered.">			if (((Context2D) ug).isBackground()) {</span>
<span class="fc" id="L184">				drawBackground(ug, area);</span>
<span class="fc" id="L185">				return;</span>
			}
<span class="fc" id="L187">			comp.drawU(ug.apply(UTranslate.dx(min.getCurrentValue())), area, (Context2D) ug);</span>
<span class="fc" id="L188">			drawAllElses(ug);</span>
		}

<span class="fc" id="L191">		double h = dim1.getHeight() + MARGINY_MAGIC / 2;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
			if (YGauge.USE_ME)
				((UDrawable) tile).drawU(ug);
			else
<span class="fc" id="L196">				((UDrawable) tile).drawU(ug.apply(UTranslate.dy(h)));</span>
<span class="fc" id="L197">			final double preferredHeight = tile.getPreferredHeight();</span>
<span class="fc" id="L198">			h += preferredHeight;</span>
<span class="fc" id="L199">		}</span>
<span class="fc" id="L200">	}</span>

	private void drawBackground(UGraphic ug, Area area) {
<span class="fc" id="L203">		final Style style = start.getUsedStyles()[0];</span>
<span class="fc" id="L204">		final HColor back = style.value(PName.BackGroundColor).asColor(skinParam.getIHtmlColorSet());</span>
<span class="fc" id="L205">		final double round = style.value(PName.RoundCorner).asDouble();</span>
<span class="fc" id="L206">		final XDimension2D dimensionToUse = area.getDimensionToUse();</span>
<span class="fc" id="L207">		final Blotter blotter = new Blotter(dimensionToUse, back, round);</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">		for (Tile tile : tiles)</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">			if (tile instanceof ElseTile) {</span>
<span class="fc" id="L211">				final ElseTile elseTile = (ElseTile) tile;</span>
<span class="fc" id="L212">				final double ypos = elseTile.getTimeHook().getValue() - getTimeHook().getValue() + MARGINY_MAGIC / 2;</span>
<span class="fc" id="L213">				blotter.addChange(ypos + 1, elseTile.getBackColorGeneral());</span>
			}

<span class="fc" id="L216">		blotter.closeChanges();</span>
<span class="fc" id="L217">		blotter.drawU(ug.apply(UTranslate.dx(min.getCurrentValue())));</span>

<span class="fc" id="L219">		final StringBounder stringBounder = ug.getStringBounder();</span>

<span class="fc" id="L221">		final XDimension2D dim1 = getPreferredDimensionIfEmpty(stringBounder);</span>
<span class="fc" id="L222">		double h = dim1.getHeight() + MARGINY_MAGIC / 2;</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
			if (YGauge.USE_ME)
				((UDrawable) tile).drawU(ug);
			else
<span class="fc" id="L227">				((UDrawable) tile).drawU(ug.apply(UTranslate.dy(h)));</span>
<span class="fc" id="L228">			final double preferredHeight = tile.getPreferredHeight();</span>
<span class="fc" id="L229">			h += preferredHeight;</span>
<span class="fc" id="L230">		}</span>

<span class="fc" id="L232">	}</span>

	private double getTotalHeight(StringBounder stringBounder) {
<span class="fc" id="L235">		final XDimension2D dimIfEmpty = getPreferredDimensionIfEmpty(stringBounder);</span>
<span class="fc" id="L236">		return bodyHeight + dimIfEmpty.getHeight() + MARGINY_MAGIC / 2;</span>
	}

	private void drawAllElses(UGraphic ug) {
<span class="fc" id="L240">		final StringBounder stringBounder = ug.getStringBounder();</span>

<span class="fc" id="L242">		final List&lt;Double&gt; ys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">			if (tile instanceof ElseTile) {</span>
<span class="fc" id="L245">				final ElseTile elseTile = (ElseTile) tile;</span>
				final double ypos;
				if (YGauge.USE_ME)
					ypos = elseTile.getYGauge().getMin().getCurrentValue() - getYGauge().getMin().getCurrentValue()
							+ MARGINY_MAGIC / 2;
				else
<span class="fc" id="L251">					ypos = elseTile.getTimeHook().getValue() - getTimeHook().getValue() + MARGINY_MAGIC / 2;</span>
<span class="fc" id="L252">				ys.add(ypos);</span>
			}
<span class="fc" id="L254">		}</span>
<span class="fc" id="L255">		final double totalHeight = getTotalHeight(stringBounder);</span>
<span class="fc" id="L256">		ys.add(totalHeight);</span>
<span class="fc" id="L257">		int i = 0;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			if (tile instanceof ElseTile) {</span>
<span class="fc" id="L260">				final ElseTile elseTile = (ElseTile) tile;</span>
<span class="fc" id="L261">				final Component comp = elseTile.getComponent(stringBounder);</span>
<span class="fc" id="L262">				final Area area = Area.create(max.getCurrentValue() - min.getCurrentValue(), ys.get(i + 1) - ys.get(i));</span>
<span class="fc" id="L263">				comp.drawU(ug.apply(new UTranslate(min.getCurrentValue(), ys.get(i))), area, (Context2D) ug);</span>
<span class="fc" id="L264">				i++;</span>
			}
<span class="fc" id="L266">		}</span>
<span class="fc" id="L267">	}</span>

	@Override
	public double getPreferredHeight() {
<span class="fc" id="L271">		final XDimension2D dim1 = getPreferredDimensionIfEmpty(getStringBounder());</span>
<span class="fc" id="L272">		return dim1.getHeight() + bodyHeight + MARGINY_MAGIC;</span>
	}

	public void addConstraints() {
<span class="fc bfc" id="L276" title="All 2 branches covered.">		for (Tile tile : tiles)</span>
<span class="fc" id="L277">			tile.addConstraints();</span>

<span class="fc" id="L279">	}</span>

	public Real getMinX() {
<span class="fc" id="L282">		return min.addFixed(-EXTERNAL_MARGINX1);</span>
	}

	public Real getMaxX() {
<span class="fc" id="L286">		return max.addFixed(EXTERNAL_MARGINX2);</span>
	}

	public static TimeHook fillPositionelTiles(StringBounder stringBounder, TimeHook y, List&lt;Tile&gt; tiles,
			final List&lt;CommonTile&gt; local, List&lt;CommonTile&gt; full) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">		for (Tile tile : mergeParallel(stringBounder, tiles)) {</span>
<span class="fc" id="L292">			tile.callbackY(y);</span>
<span class="fc" id="L293">			local.add((CommonTile) tile);</span>
<span class="fc" id="L294">			full.add((CommonTile) tile);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">			if (tile instanceof GroupingTile) {</span>
<span class="fc" id="L296">				final GroupingTile groupingTile = (GroupingTile) tile;</span>
<span class="fc" id="L297">				fillPositionalSubGroupTiles(stringBounder, y, full, groupingTile);</span>
			}
<span class="fc bfc" id="L299" title="All 2 branches covered.">			if (tile instanceof TileParallel) {</span>
<span class="fc" id="L300">				final TileParallel tileParallel = (TileParallel) tile;</span>
<span class="fc" id="L301">				fillPositionalParallelTiles(stringBounder, y, full, tileParallel);</span>
			}
<span class="fc" id="L303">			y = new TimeHook(y.getValue() + tile.getPreferredHeight());</span>
<span class="fc" id="L304">		}</span>
<span class="fc" id="L305">		return y;</span>

	}

	private static void fillPositionalSubGroupTiles(StringBounder stringBounder, TimeHook y, List&lt;CommonTile&gt; full, GroupingTile groupingTile) {
<span class="fc" id="L310">		final double headerHeight = groupingTile.getHeaderHeight(stringBounder);</span>
<span class="fc" id="L311">		final ArrayList&lt;CommonTile&gt; local2 = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L312">		fillPositionelTiles(stringBounder, new TimeHook(y.getValue() + headerHeight), groupingTile.tiles,</span>
				local2, full);
<span class="fc" id="L314">	}</span>

	private static void fillPositionalParallelTiles(StringBounder stringBounder, TimeHook yArg, List&lt;CommonTile&gt; full, TileParallel tileParallel) {
<span class="fc" id="L317">		final double yPointAll = tileParallel.getContactPointRelative();</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">		for (Tile tile : tileParallel.getTiles()) {</span>

<span class="fc" id="L320">			final double yPoint = tile.getContactPointRelative();</span>
<span class="fc" id="L321">			final double adjustment = yPointAll - yPoint;</span>
<span class="fc" id="L322">			TimeHook yAdjusted = new TimeHook(yArg.getValue() + adjustment);</span>

<span class="fc" id="L324">			tile.callbackY(yAdjusted);</span>
<span class="fc" id="L325">			full.add((CommonTile) tile);</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">			if (tile instanceof GroupingTile)</span>
<span class="fc" id="L328">				fillPositionalSubGroupTiles(stringBounder, yAdjusted, full, (GroupingTile) tile);</span>
<span class="fc" id="L329">		}</span>
<span class="fc" id="L330">	}</span>

	private double getHeaderHeight(StringBounder stringBounder) {
<span class="fc" id="L333">		return getPreferredDimensionIfEmpty(stringBounder).getHeight() + 10;</span>
	}

	private static List&lt;Tile&gt; mergeParallel(StringBounder stringBounder, List&lt;Tile&gt; tiles) {
		if (YGauge.USE_ME)
			return tiles;

<span class="fc" id="L340">		TileParallel pending = null;</span>
<span class="fc" id="L341">		tiles = removeEmptyCloseToParallel(tiles);</span>
<span class="fc" id="L342">		final List&lt;Tile&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="pc bpc" id="L344" title="1 of 4 branches missed.">			if (!isParallel(tile) || result.size() == 0) {</span>
<span class="fc" id="L345">				result.add(tile);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">				if (tile instanceof LifeEventTile == false)</span>
<span class="fc" id="L347">					pending = null;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">			} else if (pending == null) {</span>
<span class="fc" id="L349">				pending = new TileParallel(stringBounder, null);</span>
<span class="fc" id="L350">				moveRecentParallelTilesToPending(result, pending);</span>
<span class="fc" id="L351">				pending.add(tile);</span>
<span class="fc" id="L352">				result.add(pending);</span>
			} else {
<span class="fc" id="L354">				moveRecentParallelTilesToPending(result, pending);</span>
<span class="fc" id="L355">				pending.add(tile);</span>
			}
<span class="fc" id="L357">		}</span>
<span class="fc" id="L358">		return result;</span>
	}

	private static void moveRecentParallelTilesToPending(List&lt;Tile&gt; result, TileParallel pending) {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">		if (result.size() == 0)</span>
<span class="nc" id="L363">			return;</span>

<span class="fc" id="L365">		int capture = 1;</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">		while (result.get(result.size() - capture) instanceof LifeEventTile)</span>
<span class="fc" id="L367">			capture++;</span>

<span class="fc bfc" id="L369" title="All 2 branches covered.">		if (result.get(result.size() - capture) == pending)</span>
<span class="fc" id="L370">			capture--;</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">		for (int i = result.size() - capture; i &lt; result.size(); i++)</span>
<span class="fc" id="L373">			pending.add(result.get(i));</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">		for (int i = 1; i &lt;= capture; i++)</span>
<span class="fc" id="L376">			result.remove(result.size() - 1);</span>
<span class="fc" id="L377">	}</span>

	private static List&lt;Tile&gt; removeEmptyCloseToParallel(List&lt;Tile&gt; tiles) {
<span class="fc" id="L380">		final List&lt;Tile&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">			if (isParallel(tile))</span>
<span class="fc" id="L383">				removeHeadEmpty(result);</span>

<span class="fc" id="L385">			result.add(tile);</span>
<span class="fc" id="L386">		}</span>
<span class="fc" id="L387">		return result;</span>

	}

	private static void removeHeadEmpty(List&lt;Tile&gt; tiles) {
<span class="pc bpc" id="L392" title="1 of 4 branches missed.">		while (tiles.size() &gt; 0 &amp;&amp; tiles.get(tiles.size() - 1) instanceof EmptyTile)</span>
<span class="fc" id="L393">			tiles.remove(tiles.size() - 1);</span>

<span class="fc" id="L395">	}</span>

	public static boolean isParallel(Tile tile) {
<span class="pc bpc" id="L398" title="1 of 4 branches missed.">		return tile instanceof TileParallel == false &amp;&amp; tile.getEvent().isParallel();</span>
	}

	void addYNewPages(Collection&lt;Double&gt; yNewPages) {
<span class="fc bfc" id="L402" title="All 2 branches covered.">		for (Tile tile : tiles) {</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">			if (tile instanceof GroupingTile)</span>
<span class="fc" id="L404">				((GroupingTile) tile).addYNewPages(yNewPages);</span>

<span class="pc bpc" id="L406" title="1 of 2 branches missed.">			if (tile instanceof NewpageTile) {</span>
<span class="nc" id="L407">				final double y = ((NewpageTile) tile).getTimeHook().getValue();</span>
<span class="nc" id="L408">				yNewPages.add(y);</span>
			}
<span class="fc" id="L410">		}</span>
<span class="fc" id="L411">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>