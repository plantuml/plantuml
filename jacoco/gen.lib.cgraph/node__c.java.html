<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>node__c.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">gen.lib.cgraph</a> &gt; <span class="el_source">node__c.java</span></div><h1>node__c.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of Smetana.
 * Smetana is a partial translation of Graphviz/Dot sources from C to Java.
 *
 * (C) Copyright 2009-2022, Arnaud Roques
 *
 * This translation is distributed under the same Licence as the original C program:
 * 
 *************************************************************************
 * Copyright (c) 2011 AT&amp;T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 * LICENSE (&quot;AGREEMENT&quot;). [Eclipse Public License - v 1.0]
 * 
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package gen.lib.cgraph;
import static gen.lib.cdt.dtsize__c.dtsize_;
import static gen.lib.cgraph.attr__c.AgDataRecName;
import static gen.lib.cgraph.attr__c.agnodeattr_init;
import static gen.lib.cgraph.edge__c.agsubrep;
import static gen.lib.cgraph.graph__c.agnextseq;
import static gen.lib.cgraph.id__c.agmapnametoid;
import static gen.lib.cgraph.id__c.agregister;
import static gen.lib.cgraph.mem__c.agalloc;
import static gen.lib.cgraph.obj__c.agmethod_init;
import static gen.lib.cgraph.obj__c.agroot;
import static gen.lib.cgraph.rec__c.agbindrec;
import static gen.lib.cgraph.subg__c.agparent;
import static smetana.core.Macro.AGID;
import static smetana.core.Macro.AGNODE;
import static smetana.core.Macro.AGSEQ;
import static smetana.core.Macro.AGTYPE;
import static smetana.core.Macro.UNSUPPORTED;
import static smetana.core.Macro.dtfirst;
import static smetana.core.Macro.dtnext;
import static smetana.core.Macro.dtsearch;
import static smetana.core.debug.SmetanaDebug.ENTERING;
import static smetana.core.debug.SmetanaDebug.LEAVING;

import gen.annotation.Original;
import gen.annotation.Reviewed;
import gen.annotation.Unused;
import h.ST_Agdesc_s;
import h.ST_Agnode_s;
import h.ST_Agraph_s;
import h.ST_Agsubnode_s;
import h.ST_dt_s;
import h.ST_dtdisc_s;
import smetana.core.CFunction;
import smetana.core.CFunctionAbstract;
import smetana.core.CString;
import smetana.core.Globals;
import smetana.core.ZType;
import smetana.core.__ptr__;
import smetana.core.size_t;

<span class="nc" id="L87">public class node__c {</span>



@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;&quot;, key=&quot;4w89du6uel405pm3vxsr3ayxt&quot;, definition=&quot;Agnode_t *agfindnode_by_id(Agraph_t * g, unsigned long id)&quot;)
public static ST_Agnode_s agfindnode_by_id(Globals zz, ST_Agraph_s g, int id) {
<span class="fc" id="L94">ENTERING(&quot;4w89du6uel405pm3vxsr3ayxt&quot;,&quot;agfindnode_by_id&quot;);</span>
try {
    ST_Agsubnode_s sn;
    
    
<span class="fc" id="L99">    zz.dummy.base.tag.id = id;</span>
<span class="fc" id="L100">    zz.template.node = zz.dummy;</span>
<span class="fc" id="L101">    sn = (ST_Agsubnode_s) dtsearch(zz, g.n_id, zz.template);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">    return sn!=null ? sn.node : null;</span>
} finally {
<span class="fc" id="L104">LEAVING(&quot;4w89du6uel405pm3vxsr3ayxt&quot;,&quot;agfindnode_by_id&quot;);</span>
}
}



@Reviewed(when = &quot;12/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;agfstnode&quot;, key=&quot;55wopi2gd93zpmycxoywlxm0y&quot;, definition=&quot;Agnode_t *agfstnode(Agraph_t * g)&quot;)
public static ST_Agnode_s agfstnode(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L113">ENTERING(&quot;55wopi2gd93zpmycxoywlxm0y&quot;,&quot;agfstnode&quot;);</span>
try {
	ST_Agsubnode_s sn;
<span class="fc" id="L116">    sn = (ST_Agsubnode_s) dtfirst(zz, g.n_seq);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">    return sn!=null ? sn.node : null;</span>
} finally {
<span class="fc" id="L119">LEAVING(&quot;55wopi2gd93zpmycxoywlxm0y&quot;,&quot;agfstnode&quot;);</span>
}
}






@Reviewed(when = &quot;12/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;agnxtnode&quot;, key=&quot;bek79ccvjys1j9q404i3y6oh8&quot;, definition=&quot;Agnode_t *agnxtnode(Agraph_t * g, Agnode_t * n)&quot;)
public static ST_Agnode_s agnxtnode(Globals zz, ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L131">ENTERING(&quot;bek79ccvjys1j9q404i3y6oh8&quot;,&quot;agnxtnode&quot;);</span>
try {
    ST_Agsubnode_s sn;
<span class="fc" id="L134">    sn = agsubrep(zz, g, n);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    if (sn!=null) sn = (ST_Agsubnode_s) dtnext(zz, g.n_seq, sn);</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">    return sn!=null ? sn.node : null;</span>
} finally {
<span class="fc" id="L138">LEAVING(&quot;bek79ccvjys1j9q404i3y6oh8&quot;,&quot;agnxtnode&quot;);</span>
}
}



//3 dzb7m0p5xsngvtyr8zs912og4
// static Agnode_t *newnode(Agraph_t * g, unsigned long id, unsigned long seq) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;&quot;, key=&quot;dzb7m0p5xsngvtyr8zs912og4&quot;, definition=&quot;static Agnode_t *newnode(Agraph_t * g, unsigned long id, unsigned long seq)&quot;)
public static ST_Agnode_s newnode(Globals zz, ST_Agraph_s g, int id, int seq) {
<span class="fc" id="L149">ENTERING(&quot;dzb7m0p5xsngvtyr8zs912og4&quot;,&quot;newnode&quot;);</span>
try {
    ST_Agnode_s n;
<span class="fc" id="L152">    n = (ST_Agnode_s) ((__ptr__)agalloc(g, new size_t(ZType.ST_Agnode_s)));</span>
<span class="fc" id="L153">    AGTYPE(n, AGNODE);</span>
<span class="fc" id="L154">    AGID(n, id);</span>
<span class="fc" id="L155">    AGSEQ(n, seq);</span>
<span class="fc" id="L156">    n.root = agroot(g);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">    if (((ST_Agdesc_s)agroot(g).desc).has_attrs!=0)</span>
<span class="fc" id="L158">	  agbindrec(zz, n, AgDataRecName, new size_t(ZType.ST_Agattr_s), false);</span>
    /* nodeattr_init and method_init will be called later, from the
     * subgraph where the node was actually created, but first it has
     * to be installed in all the (sub)graphs up to root. */
<span class="fc" id="L162">    return n;</span>
} finally {
<span class="fc" id="L164">LEAVING(&quot;dzb7m0p5xsngvtyr8zs912og4&quot;,&quot;newnode&quot;);</span>
}
}




//3 4m26dpgaiw44hcleugjy71eus
// static void installnode(Agraph_t * g, Agnode_t * n) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;installnode&quot;, key=&quot;4m26dpgaiw44hcleugjy71eus&quot;, definition=&quot;static void installnode(Agraph_t * g, Agnode_t * n)&quot;)
public static void installnode(Globals zz, ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L176">ENTERING(&quot;4m26dpgaiw44hcleugjy71eus&quot;,&quot;installnode&quot;);</span>
try {
	ST_Agsubnode_s sn;
    int osize;
<span class="fc" id="L180">    osize = dtsize_((ST_dt_s)g.n_id);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (g == agroot(g)) sn = (ST_Agsubnode_s) n.mainsub;</span>
<span class="fc" id="L182">    else sn = (ST_Agsubnode_s) ((__ptr__)agalloc(g, new size_t(ZType.ST_Agsubnode_s))).castTo(ST_Agsubnode_s.class);</span>
<span class="fc" id="L183">    sn.node = n;</span>
<span class="fc" id="L184">    g.n_id.searchf.exe(zz, g.n_id,sn,0000001);</span>
<span class="fc" id="L185">    g.n_seq.searchf.exe(zz, g.n_seq,sn,0000001);</span>
} finally {
<span class="fc" id="L187">LEAVING(&quot;4m26dpgaiw44hcleugjy71eus&quot;,&quot;installnode&quot;);</span>
}
<span class="fc" id="L189">}</span>




//3 3mfxjcaeepn8nitirs3yoqaed
// static void installnodetoroot(Agraph_t * g, Agnode_t * n) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;installnodetoroot&quot;, key=&quot;3mfxjcaeepn8nitirs3yoqaed&quot;, definition=&quot;static void installnodetoroot(Agraph_t * g, Agnode_t * n)&quot;)
public static void installnodetoroot(Globals zz, ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L199">ENTERING(&quot;3mfxjcaeepn8nitirs3yoqaed&quot;,&quot;installnodetoroot&quot;);</span>
try {
    ST_Agraph_s par;
<span class="fc" id="L202">    installnode(zz, g, n);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">    if ((par = agparent(g))!=null)</span>
<span class="fc" id="L204">	installnodetoroot(zz, par, n);</span>
} finally {
<span class="fc" id="L206">LEAVING(&quot;3mfxjcaeepn8nitirs3yoqaed&quot;,&quot;installnodetoroot&quot;);</span>
}
<span class="fc" id="L208">}</span>




//3 85bb9mezhsgtzar3kqz95mq1
// static void initnode(Agraph_t * g, Agnode_t * n) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;initnode&quot;, key=&quot;85bb9mezhsgtzar3kqz95mq1&quot;, definition=&quot;static void initnode(Agraph_t * g, Agnode_t * n)&quot;)
public static void initnode(Globals zz, ST_Agraph_s g, ST_Agnode_s n) {
<span class="fc" id="L218">ENTERING(&quot;85bb9mezhsgtzar3kqz95mq1&quot;,&quot;initnode&quot;);</span>
try {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (((ST_Agdesc_s)agroot(g).desc).has_attrs!=0)</span>
<span class="fc" id="L221">	agnodeattr_init(zz, g,n);</span>
<span class="fc" id="L222">    agmethod_init(g, n);</span>
} finally {
<span class="fc" id="L224">LEAVING(&quot;85bb9mezhsgtzar3kqz95mq1&quot;,&quot;initnode&quot;);</span>
}
<span class="fc" id="L226">}</span>




/* external node constructor - create by id */
@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;&quot;, key=&quot;1m6sl9df2yaolmufyq5i577a3&quot;, definition=&quot;Agnode_t *agidnode(Agraph_t * g, unsigned long id, int cflag)&quot;)
public static ST_Agnode_s agidnode(Globals zz, ST_Agraph_s g, int id, int cflag) {
<span class="fc" id="L235">ENTERING(&quot;1m6sl9df2yaolmufyq5i577a3&quot;,&quot;agidnode&quot;);</span>
try {
    ST_Agraph_s root;
    ST_Agnode_s n;
    
<span class="fc" id="L240">    n = agfindnode_by_id(zz, g, id);</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">    if ((n == null) &amp;&amp; cflag!=0) {</span>
<span class="nc" id="L242">UNSUPPORTED(&quot;7zol2448bccu90sqoxkvnbuif&quot;); // 	root = agroot(g);</span>
<span class="nc" id="L243">UNSUPPORTED(&quot;1zcb29h7sxm7axw8qeuz9f38w&quot;); // 	if ((g != root) &amp;&amp; ((n = agfindnode_by_id(root, id))))	/*old */</span>
<span class="nc" id="L244">UNSUPPORTED(&quot;9fusma9293koujpr79eyfhxn6&quot;); // 	    agsubnode(g, n, (!(0)));	/* insert locally */</span>
<span class="nc" id="L245">UNSUPPORTED(&quot;8k75h069sv2k9b6tgz77dscwd&quot;); // 	else {</span>
<span class="nc" id="L246">UNSUPPORTED(&quot;5pefvv55zys4ya7lgh0v8595s&quot;); // 	    if (agallocid(g, AGNODE, id)) {	/* new */</span>
<span class="nc" id="L247">UNSUPPORTED(&quot;dfn6cx0kwd44mv0ntbzf3p463&quot;); // 		n = newnode(g, id, agnextseq(g, AGNODE));</span>
<span class="nc" id="L248">UNSUPPORTED(&quot;6qcjp92a88ggl3ea7mxel9cn&quot;); // 		installnodetoroot(g, n);</span>
<span class="nc" id="L249">UNSUPPORTED(&quot;45uf6o7ubd9hy5s65g0f0bbgj&quot;); // 		initnode(g, n);</span>
<span class="nc" id="L250">UNSUPPORTED(&quot;afk9bpom7x393euamnvwwkx6b&quot;); // 	    } else</span>
<span class="nc" id="L251">UNSUPPORTED(&quot;5l8briolxhuic5avv0112aj90&quot;); // 		n = ((Agnode_t*)0);	/* allocid for new node failed */</span>
<span class="nc" id="L252">UNSUPPORTED(&quot;flupwh3kosf3fkhkxllllt1&quot;); // 	}</span>
    }
    /* else return probe result */
<span class="fc" id="L255">    return n;</span>
} finally {
<span class="fc" id="L257">LEAVING(&quot;1m6sl9df2yaolmufyq5i577a3&quot;,&quot;agidnode&quot;);</span>
}
}




//3 4yh1h1cwoitzb1t8869b79e3g
// Agnode_t *agnode(Agraph_t * g, char *name, int cflag) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;&quot;, key=&quot;4yh1h1cwoitzb1t8869b79e3g&quot;, definition=&quot;Agnode_t *agnode(Agraph_t * g, char *name, int cflag)&quot;)
public static ST_Agnode_s agnode(Globals zz, ST_Agraph_s g, CString name, boolean cflag) {
<span class="fc" id="L269">ENTERING(&quot;4yh1h1cwoitzb1t8869b79e3g&quot;,&quot;agnode&quot;);</span>
try {
    ST_Agraph_s root;
    ST_Agnode_s n;
<span class="fc" id="L273">    int id[] = new int[1];</span>
<span class="fc" id="L274">    root = agroot(g);</span>
    /* probe for existing node */
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">    if (agmapnametoid(zz, g, AGNODE, name, id, false)!=0) {</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">	if ((n = agfindnode_by_id(zz, g, id[0]))!=null)</span>
<span class="nc" id="L278">	    return n;</span>
	/* might already exist globally, but need to insert locally */
<span class="pc bpc" id="L280" title="2 of 6 branches missed.">	if (cflag &amp;&amp; (g != root) &amp;&amp; ((n = agfindnode_by_id(zz, root, id[0])))!=null) {</span>
<span class="nc" id="L281">	    return agsubnode(zz, g, n, (true));</span>
    }
    }
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">    if (cflag &amp;&amp; agmapnametoid(zz, g, AGNODE, name, id, (true))!=0) {	/* reserve id */</span>
<span class="fc" id="L285">	n = newnode(zz, g, id[0], agnextseq(g, AGNODE));</span>
<span class="fc" id="L286">	installnodetoroot(zz, g, n);</span>
<span class="fc" id="L287">	initnode(zz, g, n);</span>

<span class="fc" id="L289">	agregister(zz, g, AGNODE, n); /* register in external namespace */</span>
<span class="fc" id="L290">	return n;</span>
    }
<span class="nc" id="L292">    return null;</span>
} finally {
<span class="fc" id="L294">LEAVING(&quot;4yh1h1cwoitzb1t8869b79e3g&quot;,&quot;agnode&quot;);</span>
}
}



/* lookup or insert &lt;n&gt; in &lt;g&gt; */
@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;&quot;, key=&quot;d5farp22buvesyi4pydjam4g2&quot;, definition=&quot;Agnode_t *agsubnode(Agraph_t * g, Agnode_t * n0, int cflag)&quot;)
public static ST_Agnode_s agsubnode(Globals zz, ST_Agraph_s g, ST_Agnode_s n0, boolean cflag) {
<span class="fc" id="L304">ENTERING(&quot;d5farp22buvesyi4pydjam4g2&quot;,&quot;agsubnode&quot;);</span>
try {
    ST_Agraph_s par;
    ST_Agnode_s n;
    
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">    if ((agroot(g) != n0.root))</span>
<span class="nc" id="L310">	return null;</span>
<span class="fc" id="L311">    n = agfindnode_by_id(zz, g, n0.tag.id);</span>
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">    if ((n == null) &amp;&amp; cflag) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">	if ((par = agparent(g))!=null) {</span>
<span class="nc" id="L314">	    n = agsubnode(zz, par, n0, cflag);</span>
<span class="nc" id="L315">	    installnode(zz, g, n);</span>
	    /* no callback for existing node insertion in subgraph (?) */
	}
	/* else impossible that &lt;n&gt; doesn't belong to &lt;g&gt; */
    }
    /* else lookup succeeded */
<span class="fc" id="L321">    return n;</span>
} finally {
<span class="fc" id="L323">LEAVING(&quot;d5farp22buvesyi4pydjam4g2&quot;,&quot;agsubnode&quot;);</span>
}
}


<span class="fc" id="L328">public static CFunction agsubnodeidcmpf = new CFunctionAbstract(&quot;agsubnodeidcmpf&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="fc" id="L331">		return agsubnodeidcmpf((ST_dt_s)args[0], (__ptr__)args[1], (__ptr__)args[2], (ST_dtdisc_s)args[3]);</span>
	}};

@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;agsubnodeidcmpf&quot;, key=&quot;awwiazixy9c76hvyxlkvvb3vo&quot;, definition=&quot;int agsubnodeidcmpf(Dict_t * d, void *arg0, void *arg1, Dtdisc_t * disc)&quot;)
public static int agsubnodeidcmpf(ST_dt_s d, __ptr__ arg0, __ptr__ arg1, ST_dtdisc_s disc) {
<span class="fc" id="L337">ENTERING(&quot;awwiazixy9c76hvyxlkvvb3vo&quot;,&quot;agsubnodeidcmpf&quot;);</span>
try {
    int	v;
    ST_Agsubnode_s sn0, sn1;
<span class="fc" id="L341">    sn0 = (ST_Agsubnode_s) arg0.castTo(ST_Agsubnode_s.class);</span>
<span class="fc" id="L342">    sn1 = (ST_Agsubnode_s) arg1.castTo(ST_Agsubnode_s.class);</span>
<span class="fc" id="L343">    v = (sn0.node.tag.id - sn1.node.tag.id);</span>
<span class="fc bfc" id="L344" title="All 4 branches covered.">    return ((v==0)?0:(v&lt;0?-1:1));</span>
} finally {
<span class="fc" id="L346">LEAVING(&quot;awwiazixy9c76hvyxlkvvb3vo&quot;,&quot;agsubnodeidcmpf&quot;);</span>
}
}



<span class="fc" id="L352">public static CFunction agsubnodeseqcmpf = new CFunctionAbstract(&quot;agsubnodeseqcmpf&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="fc" id="L355">		return agsubnodeseqcmpf((ST_dt_s)args[0], (__ptr__)args[1], (__ptr__)args[2], (ST_dtdisc_s)args[3]);</span>
	}};
	
@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;agsubnodeseqcmpf&quot;, key=&quot;41fjseux0nxzpr0aq7igym9ux&quot;, definition=&quot;int agsubnodeseqcmpf(Dict_t * d, void *arg0, void *arg1, Dtdisc_t * disc)&quot;)
public static int agsubnodeseqcmpf(ST_dt_s d, __ptr__ arg0, __ptr__ arg1, ST_dtdisc_s disc) {
<span class="fc" id="L361">ENTERING(&quot;41fjseux0nxzpr0aq7igym9ux&quot;,&quot;agsubnodeseqcmpf&quot;);</span>
try {
	ST_Agsubnode_s sn0, sn1;
    int	v;
<span class="fc" id="L365">    sn0 = (ST_Agsubnode_s) arg0.castTo(ST_Agsubnode_s.class);</span>
<span class="fc" id="L366">    sn1 = (ST_Agsubnode_s) arg1.castTo(ST_Agsubnode_s.class);</span>
<span class="fc" id="L367">    v = (sn0.node.tag.seq - sn1.node.tag.seq);</span>
<span class="fc bfc" id="L368" title="All 4 branches covered.">    return ((v==0)?0:(v&lt;0?-1:1));</span>
} finally {
<span class="fc" id="L370">LEAVING(&quot;41fjseux0nxzpr0aq7igym9ux&quot;,&quot;agsubnodeseqcmpf&quot;);</span>
}
}




<span class="fc" id="L377">public static CFunction free_subnode = new CFunctionAbstract(&quot;free_subnode&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="nc" id="L380">		return free_subnode(args);</span>
	}};
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/node.c&quot;, name=&quot;free_subnode&quot;, key=&quot;a7tb3b1kvq6ykrxzhbaduvg9r&quot;, definition=&quot;static void free_subnode (Dt_t* d, Agsubnode_t* sn, Dtdisc_t * disc)&quot;)
public static Object free_subnode(Object... arg_) {
<span class="nc" id="L385">UNSUPPORTED(&quot;e2z2o5ybnr5tgpkt8ty7hwan1&quot;); // static void</span>
<span class="nc" id="L386">UNSUPPORTED(&quot;9e4h6d4hxsvsnaiuubzlmccsm&quot;); // free_subnode (Dt_t* d, Agsubnode_t* sn, Dtdisc_t * disc)</span>
<span class="nc" id="L387">UNSUPPORTED(&quot;erg9i1970wdri39osu8hx2a6e&quot;); // {</span>
<span class="nc" id="L388">UNSUPPORTED(&quot;eiac02o593gy0a55vv1w8mkmi&quot;); //    if (!AGSNMAIN(sn)) </span>
<span class="nc" id="L389">UNSUPPORTED(&quot;263bmzd9ilyyeb9w34squ7iw8&quot;); // 	agfree (sn-&gt;node-&gt;root, sn);</span>
<span class="nc" id="L390">UNSUPPORTED(&quot;c24nfmv9i7o5eoqaymbibp7m7&quot;); // }</span>

<span class="nc" id="L392">throw new UnsupportedOperationException();</span>
}



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>