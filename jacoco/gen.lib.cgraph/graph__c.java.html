<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>graph__c.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">plantuml</a> &gt; <a href="index.source.html" class="el_package">gen.lib.cgraph</a> &gt; <span class="el_source">graph__c.java</span></div><h1>graph__c.java</h1><pre class="source lang-java linenums">/* ========================================================================
 * PlantUML : a free UML diagram generator
 * ========================================================================
 *
 * Project Info:  https://plantuml.com
 * 
 * If you like this project or if you find it useful, you can support us at:
 * 
 * https://plantuml.com/patreon (only 1$ per month!)
 * https://plantuml.com/paypal
 * 
 * This file is part of Smetana.
 * Smetana is a partial translation of Graphviz/Dot sources from C to Java.
 *
 * (C) Copyright 2009-2022, Arnaud Roques
 *
 * This translation is distributed under the same Licence as the original C program:
 * 
 *************************************************************************
 * Copyright (c) 2011 AT&amp;T Intellectual Property 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors: See CVS logs. Details at http://www.graphviz.org/
 *************************************************************************
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC
 * LICENSE (&quot;AGREEMENT&quot;). [Eclipse Public License - v 1.0]
 * 
 * ANY USE, REPRODUCTION OR DISTRIBUTION OF THE PROGRAM CONSTITUTES
 * RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package gen.lib.cgraph;
import static gen.lib.cdt.dtextract__c.dtextract;
import static gen.lib.cdt.dtrestore__c.dtrestore;
import static gen.lib.cdt.dtsize__c.dtsize_;
import static gen.lib.cgraph.attr__c.agraphattr_init;
import static gen.lib.cgraph.edge__c.agsubrep;
import static gen.lib.cgraph.id__c.agmapnametoid;
import static gen.lib.cgraph.id__c.agregister;
import static gen.lib.cgraph.node__c.agfstnode;
import static gen.lib.cgraph.node__c.agnxtnode;
import static gen.lib.cgraph.obj__c.agmethod_init;
import static gen.lib.cgraph.obj__c.agroot;
import static gen.lib.cgraph.subg__c.agparent;
import static gen.lib.cgraph.utils__c.agdtopen;
import static smetana.core.Macro.AGID;
import static smetana.core.Macro.AGRAPH;
import static smetana.core.Macro.AGSEQ;
import static smetana.core.Macro.AGTYPE;
import static smetana.core.debug.SmetanaDebug.ENTERING;
import static smetana.core.debug.SmetanaDebug.LEAVING;

import gen.annotation.Difficult;
import gen.annotation.Original;
import gen.annotation.Reviewed;
import gen.annotation.Unused;
import h.ST_Agclos_s;
import h.ST_Agdesc_s;
import h.ST_Agdisc_s;
import h.ST_Agmemdisc_s;
import h.ST_Agnode_s;
import h.ST_Agraph_s;
import h.ST_Agsubnode_s;
import h.ST_dt_s;
import h.ST_dtdisc_s;
import h.ST_dtlink_s;
import smetana.core.CFunction;
import smetana.core.CFunctionAbstract;
import smetana.core.CStarStar;
import smetana.core.CString;
import smetana.core.Globals;
import smetana.core.ZType;
import smetana.core.__ptr__;
import smetana.core.size_t;

<span class="nc" id="L90">public class graph__c {</span>


//3 bb2bu9iyqx0u6xx44l282vmch
// static Agclos_t *agclos(Agdisc_t * proto) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;&quot;, key=&quot;bb2bu9iyqx0u6xx44l282vmch&quot;, definition=&quot;static Agclos_t *agclos(Agdisc_t * proto)&quot;)
public static ST_Agclos_s agclos(Globals zz, ST_Agdisc_s proto) {
<span class="fc" id="L98">ENTERING(&quot;bb2bu9iyqx0u6xx44l282vmch&quot;,&quot;agclos&quot;);</span>
try {
	ST_Agmemdisc_s memdisc;
		__ptr__  memclosure;
		ST_Agclos_s rv;
		/* establish an allocation arena */
<span class="pc bpc" id="L104" title="3 of 4 branches missed.">		memdisc = (ST_Agmemdisc_s) ((proto != null &amp;&amp; proto.mem != null) ? proto.mem : zz.AgMemDisc);</span>
<span class="fc" id="L105">		memclosure = (__ptr__) memdisc.open.exe(zz, proto);</span>
<span class="fc" id="L106">		rv = (ST_Agclos_s) memdisc.alloc.exe(zz, memclosure, new size_t(ZType.ST_Agclos_s));</span>
<span class="fc" id="L107">		rv.disc.mem = memdisc;</span>
<span class="fc" id="L108">		rv.state.mem = memclosure;</span>
<span class="pc bpc" id="L109" title="3 of 4 branches missed.">		rv.disc.id = ((proto != null &amp;&amp; proto.id != null) ? proto.id : zz.AgIdDisc);</span>
		// Translation bug in next line: should be AgIoDisc and not AgIdDisc
		// rv.disc.io = ((proto != null &amp;&amp; proto.getPtr(&quot;io&quot;) != null) ? proto.getPtr(&quot;io&quot;) : Z.z().AgIoDisc));
<span class="fc" id="L112">		rv.callbacks_enabled = (true);</span>
<span class="fc" id="L113">		return rv;</span>
} finally {
<span class="fc" id="L115">LEAVING(&quot;bb2bu9iyqx0u6xx44l282vmch&quot;,&quot;agclos&quot;);</span>
}
}




//3 d5yqn56yii8cdoahswt4n6bug
// Agraph_t *agopen(char *name, Agdesc_t desc, Agdisc_t * arg_disc) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;&quot;, key=&quot;d5yqn56yii8cdoahswt4n6bug&quot;, definition=&quot;Agraph_t *agopen(char *name, Agdesc_t desc, Agdisc_t * arg_disc)&quot;)
public static ST_Agraph_s agopen(Globals zz, CString name, final ST_Agdesc_s desc, ST_Agdisc_s arg_disc) {
// WARNING!! STRUCT
<span class="fc" id="L128">return agopen_w_(zz, name, (ST_Agdesc_s) desc.copy(), arg_disc);</span>
}
private static ST_Agraph_s agopen_w_(Globals zz, CString name, final ST_Agdesc_s desc, ST_Agdisc_s arg_disc) {
<span class="fc" id="L131">ENTERING(&quot;d5yqn56yii8cdoahswt4n6bug&quot;,&quot;agopen&quot;);</span>
try {
		ST_Agraph_s g;
		ST_Agclos_s clos;
<span class="fc" id="L135">		int gid[] = new int[1];</span>
<span class="fc" id="L136">		clos = agclos(zz, arg_disc);</span>
<span class="fc" id="L137">		g = (ST_Agraph_s) clos.disc.mem.alloc.exe(zz, clos.state.mem, new size_t(ZType.ST_Agraph_s));</span>
<span class="fc" id="L138">    	AGTYPE(g, AGRAPH);</span>
<span class="fc" id="L139">		g.clos = clos;</span>
<span class="fc" id="L140">		g.desc.___(desc);</span>
<span class="fc" id="L141">		((ST_Agdesc_s)g.desc).maingraph = (true) ? 1 : 0;</span>
<span class="fc" id="L142">		g.root = g;</span>
<span class="fc" id="L143">		g.clos.state.id = (__ptr__) g.clos.disc.id.open.exe(zz, g, arg_disc);</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		 if (agmapnametoid(zz, g, AGRAPH, name, gid, (true))!=0)</span>
<span class="fc" id="L145">		   AGID(g, gid[0]);</span>
		// /* else AGID(g) = 0 because we have no alternatives */
<span class="fc" id="L147">		g = agopen1(zz, g);</span>
<span class="fc" id="L148">		agregister(zz, g, AGRAPH, g);</span>
<span class="fc" id="L149">		return g;</span>
} finally {
<span class="fc" id="L151">LEAVING(&quot;d5yqn56yii8cdoahswt4n6bug&quot;,&quot;agopen&quot;);</span>
}
}




//3 8jyhwfdfm0a877qfz8cjlb8rk
// Agraph_t *agopen1(Agraph_t * g) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;&quot;, key=&quot;8jyhwfdfm0a877qfz8cjlb8rk&quot;, definition=&quot;Agraph_t *agopen1(Agraph_t * g)&quot;)
public static ST_Agraph_s agopen1(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L163">ENTERING(&quot;8jyhwfdfm0a877qfz8cjlb8rk&quot;,&quot;agopen1&quot;);</span>
try {
    ST_Agraph_s par;
<span class="fc" id="L166">    g.n_seq = agdtopen(zz, g, zz.Ag_subnode_seq_disc, zz.Dttree);</span>
<span class="fc" id="L167">    g.n_id = agdtopen(zz, g, zz.Ag_subnode_id_disc, zz.Dttree);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">    g.e_seq = agdtopen(zz, g, g == agroot(g)? zz.Ag_mainedge_seq_disc : zz.Ag_subedge_seq_disc, zz.Dttree);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">    g.e_id = agdtopen(zz, g, g == agroot(g)? zz.Ag_mainedge_id_disc : zz.Ag_subedge_id_disc, zz.Dttree);</span>
<span class="fc" id="L170">    g.g_dict = agdtopen(zz, g, zz.Ag_subgraph_id_disc, zz.Dttree);</span>
<span class="fc" id="L171">    par = agparent(g);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (par!=null) {</span>
<span class="fc" id="L173">	AGSEQ(g, agnextseq(par, AGRAPH));</span>
<span class="fc" id="L174">  	par.g_dict.searchf.exe(zz, par.g_dict,g,0000001);</span>
    }				/* else AGSEQ=0 */
<span class="pc bpc" id="L176" title="1 of 4 branches missed.">    if ((par) == null || ((ST_Agdesc_s)par.desc).has_attrs!=0)</span>
<span class="fc" id="L177">	agraphattr_init(zz, g);</span>
<span class="fc" id="L178">    agmethod_init(g, g);</span>
<span class="fc" id="L179">    return g;</span>
} finally {
<span class="fc" id="L181">LEAVING(&quot;8jyhwfdfm0a877qfz8cjlb8rk&quot;,&quot;agopen1&quot;);</span>
}
}




//3 axmdmml95l55vlp1vqmh0v5sn
// unsigned long agnextseq(Agraph_t * g, int objtype) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agnextseq&quot;, key=&quot;axmdmml95l55vlp1vqmh0v5sn&quot;, definition=&quot;unsigned long agnextseq(Agraph_t * g, int objtype)&quot;)
public static int agnextseq(ST_Agraph_s g, int objtype) {
<span class="fc" id="L193">ENTERING(&quot;axmdmml95l55vlp1vqmh0v5sn&quot;,&quot;agnextseq&quot;);</span>
try {
<span class="fc" id="L195">	int tmp = g.clos.seq[objtype];</span>
<span class="fc" id="L196">	tmp++;</span>
<span class="fc" id="L197">	g.clos.seq[objtype]=tmp;</span>
<span class="fc" id="L198">	return tmp;</span>
} finally {
<span class="fc" id="L200">LEAVING(&quot;axmdmml95l55vlp1vqmh0v5sn&quot;,&quot;agnextseq&quot;);</span>
}
}




@Reviewed(when = &quot;12/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agnnodes&quot;, key=&quot;688euygrkbl10cveflgwalo2n&quot;, definition=&quot;int agnnodes(Agraph_t * g)&quot;)
public static int agnnodes(ST_Agraph_s g) {
<span class="fc" id="L210">ENTERING(&quot;688euygrkbl10cveflgwalo2n&quot;,&quot;agnnodes&quot;);</span>
try {
<span class="fc" id="L212">    return dtsize_((ST_dt_s)g.n_id);</span>
} finally {
<span class="fc" id="L214">LEAVING(&quot;688euygrkbl10cveflgwalo2n&quot;,&quot;agnnodes&quot;);</span>
}
}




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agnedges&quot;, key=&quot;8zjne7uv8rfpmbv5t96zhnr4u&quot;, definition=&quot;int agnedges(Agraph_t * g)&quot;)
public static int agnedges(Globals zz, ST_Agraph_s g) {
<span class="fc" id="L224">ENTERING(&quot;8zjne7uv8rfpmbv5t96zhnr4u&quot;,&quot;agnedges&quot;);</span>
try {
    ST_Agnode_s n;
<span class="fc" id="L227">    int rv = 0;</span>
    
<span class="fc bfc" id="L229" title="All 2 branches covered.">    for (n = agfstnode(zz, g); n!=null; n = agnxtnode(zz, g, n))</span>
<span class="fc" id="L230">	rv += agdegree(zz, g, n, false, true);	/* must use OUT to get self-arcs */</span>
<span class="fc" id="L231">    return rv;</span>
} finally {
<span class="fc" id="L233">LEAVING(&quot;8zjne7uv8rfpmbv5t96zhnr4u&quot;,&quot;agnedges&quot;);</span>
}
}




@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agisdirected&quot;, key=&quot;blvn1w3v0icnucu5m5xvbrba1&quot;, definition=&quot;int agisdirected(Agraph_t * g)&quot;)
public static boolean agisdirected(ST_Agraph_s g) {
<span class="fc" id="L243">ENTERING(&quot;blvn1w3v0icnucu5m5xvbrba1&quot;,&quot;agisdirected&quot;);</span>
try {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">    return g.desc.directed!=0;</span>
} finally {
<span class="fc" id="L247">LEAVING(&quot;blvn1w3v0icnucu5m5xvbrba1&quot;,&quot;agisdirected&quot;);</span>
}
}




@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agisundirected&quot;, key=&quot;8thgds4eioot64flko26m8ns0&quot;, definition=&quot;int agisundirected(Agraph_t * g)&quot;)
public static boolean agisundirected(ST_Agraph_s g) {
<span class="nc" id="L257">ENTERING(&quot;8thgds4eioot64flko26m8ns0&quot;,&quot;agisundirected&quot;);</span>
try {
<span class="nc bnc" id="L259" title="All 2 branches missed.">    return !agisdirected(g);</span>
} finally {
<span class="nc" id="L261">LEAVING(&quot;8thgds4eioot64flko26m8ns0&quot;,&quot;agisundirected&quot;);</span>
}
}




@Reviewed(when = &quot;13/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agisstrict&quot;, key=&quot;9qgdebmdfrcfjm394bg59a7y5&quot;, definition=&quot;int agisstrict(Agraph_t * g)&quot;)
public static boolean agisstrict(ST_Agraph_s g) {
<span class="fc" id="L271">ENTERING(&quot;9qgdebmdfrcfjm394bg59a7y5&quot;,&quot;agisstrict&quot;);</span>
try {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    return g.desc.strict!=0;</span>
} finally {
<span class="fc" id="L275">LEAVING(&quot;9qgdebmdfrcfjm394bg59a7y5&quot;,&quot;agisstrict&quot;);</span>
}
}




@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;cnt&quot;, key=&quot;abaldeo2ie6zi60cazxp7rv47&quot;, definition=&quot;static int cnt(Dict_t * d, Dtlink_t ** set)&quot;)
public static int cnt(ST_dt_s d, CStarStar&lt;ST_dtlink_s&gt; set) {
<span class="fc" id="L285">ENTERING(&quot;abaldeo2ie6zi60cazxp7rv47&quot;,&quot;cnt&quot;);</span>
try {
	int rv;
<span class="fc" id="L288">    dtrestore(d, set.star());</span>
<span class="fc" id="L289">    rv = dtsize_(d);</span>
<span class="fc" id="L290">    set.star(dtextract(d));</span>
<span class="fc" id="L291">	return rv;</span>
} finally {
<span class="fc" id="L293">LEAVING(&quot;abaldeo2ie6zi60cazxp7rv47&quot;,&quot;cnt&quot;);</span>
}
}



@Difficult
@Reviewed(when = &quot;14/11/2020&quot;)
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agdegree&quot;, key=&quot;2bz40qf0qo7pd6er1ut25gthp&quot;, definition=&quot;int agdegree(Agraph_t * g, Agnode_t * n, int want_in, int want_out)&quot;)
public static int agdegree(Globals zz, ST_Agraph_s g, ST_Agnode_s n, boolean want_in, boolean want_out) {
<span class="fc" id="L303">ENTERING(&quot;2bz40qf0qo7pd6er1ut25gthp&quot;,&quot;agdegree&quot;);</span>
try {
	ST_Agsubnode_s sn;
<span class="fc" id="L306">    int rv = 0;</span>
    
<span class="fc" id="L308">    sn = agsubrep(zz, g, n);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">    if (sn!=null) {</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">	if (want_out) rv += cnt(g.e_seq, sn.out_seq_AMP());</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">	if (want_in) rv += cnt(g.e_seq, sn.in_seq_AMP());</span>
    }
<span class="fc" id="L313">	return rv;</span>
} finally {
<span class="fc" id="L315">LEAVING(&quot;2bz40qf0qo7pd6er1ut25gthp&quot;,&quot;agdegree&quot;);</span>
}
}



<span class="fc" id="L321">public static CFunction agraphidcmpf = new CFunctionAbstract(&quot;agraphidcmpf&quot;) {</span>
	
	public Object exe(Globals zz, Object... args) {
<span class="fc" id="L324">		return agraphidcmpf((ST_dt_s)args[0], (ST_Agraph_s)args[1], (ST_Agraph_s)args[2], (ST_dtdisc_s)args[3]);</span>
	}};
	
//3 dhbtfzzp8n5yygqmhmluo9bxl
// int agraphidcmpf(Dict_t * d, void *arg0, void *arg1, Dtdisc_t * disc) 
@Unused
@Original(version=&quot;2.38.0&quot;, path=&quot;lib/cgraph/graph.c&quot;, name=&quot;agraphidcmpf&quot;, key=&quot;dhbtfzzp8n5yygqmhmluo9bxl&quot;, definition=&quot;int agraphidcmpf(Dict_t * d, void *arg0, void *arg1, Dtdisc_t * disc)&quot;)
public static int agraphidcmpf(ST_dt_s d, ST_Agraph_s arg0, ST_Agraph_s arg1, ST_dtdisc_s disc) {
<span class="fc" id="L332">ENTERING(&quot;dhbtfzzp8n5yygqmhmluo9bxl&quot;,&quot;agraphidcmpf&quot;);</span>
try {
    int v;
    ST_Agraph_s sg0, sg1;
<span class="fc" id="L336">    sg0 = (ST_Agraph_s) arg0;</span>
<span class="fc" id="L337">    sg1 = (ST_Agraph_s) arg1;</span>
<span class="fc" id="L338">    v = (sg0.tag.id - sg1.tag.id);</span>
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">    return ((v==0)?0:(v&lt;0?-1:1));</span>
} finally {
<span class="fc" id="L341">LEAVING(&quot;dhbtfzzp8n5yygqmhmluo9bxl&quot;,&quot;agraphidcmpf&quot;);</span>
}
}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>